
#index}
artemis.index.artemis1        = Artemis es una plataforma web enfocada en el aprendizaje de programaci\u00f3n y en el entrenamiento de programaci\u00f3n competitiva, creada como biblioteca de conocimiento, ejercicios de practica y algoritmos de soluci\u00f3n, los cuales en conjunto permiten el crecimiento laboral y personal de programador.
artemis.index.artemis2        = Artemis busca dar al programador estrategias y metodologias que le permitan dise\u00f1ar soluciones a problemas de la vida real conventidos en ejercicios de programaci\u00f3n, y a medida que el programador crece en su conocimiento, al tiempo crece en su competitivad laboral.
artemis.index.introduccion1   = Dentro del \u00e1rea de las ciencias de la computaci\u00f3n, un tema que a\u00f1o con a\u00f1o cobra m\u00e1s importancia es la programaci\u00f3n competitiva; presentada en torneos en los cuales varios grupos de personas intentan resolver problemas a trav\u00e9s de c\u00f3digo y algoritmos.
artemis.index.introduccion2   = El trabajo en equipo, pensamiento cr\u00edtico y actuar bajo presi\u00f3n, adem\u00e1s de otras actividades, son desarrolladas e impulsadas a trav\u00e9s de estas competencias. Se trata de un deporte mental en el que participan e impulsan compa\u00f1\u00edas multinacionales de software como Google, IBM y Facebook.
artemis.index.introduccion3   = El desarrollo de las habilidades de programaci\u00f3n de algoritmos se potencia a trav\u00e9s de la colaboraci\u00f3n, es por ello que colegios y universidades de todo el mundo buscan que los alumnos participen en este tipo de torneos.
artemis.index.introduccion4   = A su vez, el impulso de talento es crucial para actividades cada vez m\u00e1s demandantes y demandadas, como es la programaci\u00f3n. De ah\u00ed que empresas de gran relevancia nacional e internacional este interesadas en egresados de carreras relacionadas.
artemis.index.codejam1        = Es una competencia de programaci\u00f3n internacional organizada y administrada por Google. Su inicio se dio en 2003 como un medio para identificar a los mejores talentos de ingenier\u00eda para un empleo potencial en Google. 
artemis.index.codejam2        = La competencia consiste en un conjunto de problemas algor\u00edtmicos que deben resolverse en un per\u00edodo de tiempo fijo. Los competidores pueden usar cualquier lenguaje de programaci\u00f3n y entorno de desarrollo para crear sus soluciones.
artemis.index.hackercup1      = Es una competencia de programaci\u00f3n internacional organizada y administrada por Facebook. La competencia comenz\u00f3 en 2011 como un medio para identificar a los mejores talentos de ingenier\u00eda para posibles empleos en Facebook.
artemis.index.hackercup2      = La competencia consiste en un conjunto de problemas matematico-algoritmicos que deben resolverse en un per\u00edodo de tiempo fijo. Los competidores pueden usar cualquier lenguaje de programaci\u00f3n y entorno de desarrollo para escribir sus soluciones.
artemis.index.icpc1           = La Competici\u00f3n Internacional Universitaria ACM de Programaci\u00f3n (ACM International Collegiate Programming Contest) es una competici\u00f3n anual de programaci\u00f3n y algor\u00edtmica entre universidades de todo el mundo patrocinada por IBM y JetBrains. 
artemis.index.icpc2           = En la competici\u00f3n prima el trabajo en equipo, el an\u00e1lisis de problemas y el desarrollo r\u00e1pido de software. ICPC es un evento auspiciado por la Association for Computing Machinery (ACM).
artemis.index.ccpl1           = Colombian Collegiate Programming League (CCPL) es la liga de competencia en programaci\u00f3n m\u00e1s grande de Colombia, realizando diferentes rondas por a\u00f1o en donde las diferentes entidades de educaci\u00f3n superior env\u00edan equipos de estudiantes a competir, las competencias se realizan en diferentes sedes cada ronda y funcionan como entrenamiento para las competencias clasificatorias nacionales en Colombia.
artemis.index.ccpl2           = Algunas universidades tambi\u00e9n realizan competencias internas o interuniversitarias con el fin de atraer p\u00fablico y competidores al mundo de la programaci\u00f3n competitiva, algunas de estas se realizan de forma amistosa y formativa, otras con fines competitivos y comparativos.
# registro
artemis.registro.exito  = \u00c9xito
artemis.registro.creado = Cuenta creada con \u00e9xito, ya puede acceder via INICIO SESI\u00d3N
artemis.registro.error  = Error

#lenguajes
artemis.lenguajes.java.intro       = Es un lenguaje de programaci\u00f3n de prop\u00f3sito general, concurrente, orientado a objetos, que fue dise\u00f1ado espec\u00edficamente para tener tan pocas dependencias de implementaci\u00f3n como fuera posible. Su intenci\u00f3n es permitir que los desarrolladores de aplicaciones escriban el programa una vez y lo ejecuten en cualquier dispositivo, lo que quiere decir que el c\u00f3digo que es ejecutado en una plataforma no tiene que ser recompilado para correr en otra. Java es, a partir de 2012, uno de los lenguajes de programaci\u00f3n m\u00e1s populares en uso, particularmente para aplicaciones de cliente-servidor de web, con unos diez millones de usuarios reportados.  
artemis.lenguajes.python.intro     = Es un lenguaje de programaci\u00f3n interpretado cuya filosof\u00eda hace hincapi\u00e9 en una sintaxis que favorezca un c\u00f3digo legible. Se trata de un lenguaje de programaci\u00f3n multiparadigma, ya que soporta orientaci\u00f3n a objetos, programaci\u00f3n imperativa y, en menor medida, programaci\u00f3n funcional. Es un lenguaje interpretado, usa tipado din\u00e1mico y es multiplataforma.
artemis.lenguajes.cpp.intro        = Es un lenguaje de programaci\u00f3n dise\u00f1ado en 1979 por Bjarne Stroustrup. La intenci\u00f3n de su creaci\u00f3n fue extender al lenguaje de programaci\u00f3n C mecanismos que permiten la manipulaci\u00f3n de objetos. En ese sentido, desde el punto de vista de los lenguajes orientados a objetos, el C++ es un lenguaje h\u00edbrido. Posteriormente se a\u00f1adieron facilidades de programaci\u00f3n gen\u00e9rica, que se sumaron a los paradigmas de estructurada y programaci\u00f3n orientada a objetos. Por esto se suele decir que el C++ es un lenguaje de programaci\u00f3n multiparadigma.


# programacion competitiva
artemis.pcompetitiva.intro              = Las competencias de programaci\u00f3n a nivel mundial han demostrado ser una valiosa herramienta para el aprendizaje y desarrollo de habilidades relacionadas a la programaci\u00f3n en funci\u00f3n de resoluci\u00f3n de problemas, muchas de estas competencias emplean diversos aplicativos webs para el entrenamiento y evaluaci\u00f3n de los estudiantes.
artemis.pcompetitiva.introb             = Es un concurso de programaci\u00f3n algor\u00edtmica para estudiantes universitarios. Equipos de uno a tres integrantes, que representan a su universidad, trabajan para resolver los problemas de la vida real, fomentando la colaboraci\u00f3n, la creatividad, la innovaci\u00f3n y la capacidad de actuar bajo presi\u00f3n. A trav\u00e9s del entrenamiento y la competencia, los equipos se desaf\u00edan unos a otros para elevar la presi\u00f3n y la rapidez con el cual realizan los problemas.  
artemis.pcompetitiva.problema.intro     = Un problema de programaci\u00f3n competitiva es un peque\u00f1o ejercicio de programaci\u00f3n que puede abordar cualquier tema de la vida cotidiana, ciencias puras como la matem\u00e1tica o la f\u00edsica, un juego de mesa como el ajedrez o un rompecabezas. Utilizando la programaci\u00f3n se pueden resolver estos ejercicios y buscar una soluci\u00f3n \u00f3ptima al mismo utilizando matem\u00e1tica, algoritmos matem\u00e1ticos especializados o incluso l\u00f3gica b\u00e1sica.
artemis.pcompetitiva.intro.img.title    = XXXI Marat\u00f3n Nacional de Programaci\u00f3n ACIS-REDIS, Bogot\u00e1 - Colombia

#competencias
artemis.competencias.icpc.title     = The ACM-ICPC International Collegiate Programming Contest
artemis.competencias.icpc.text      = El Concurso Internacional de Programaci\u00f3n Colegial (International Collegiate Programming Contest ICPC) es un concurso de programaci\u00f3n algor\u00edtmica para estudiantes universitarios. Equipos de tres, que representan a su universidad, trabajan para resolver los problemas m\u00e1s reales del mundo, fomentando la colaboraci\u00f3n, la creatividad, la innovaci\u00f3n y la capacidad de desempe\u00f1arse bajo presi\u00f3n. A trav\u00e9s del entrenamiento y la competencia, los equipos se desaf\u00edan entre s\u00ed para elevar el nivel de lo posible. En pocas palabras, es el concurso de programaci\u00f3n m\u00e1s antiguo, m\u00e1s grande y m\u00e1s prestigioso del mundo.
artemis.competencias.icpc.textb     = El ICPC se remonta a 1970, cuando los pioneros del Cap\u00edtulo Alfa de la Sociedad de Honor de Ciencias de la Computaci\u00f3n de la UPE organizaron la primera competencia. La iniciativa se difundi\u00f3 r\u00e1pidamente dentro de los Estados Unidos y Canad\u00e1 como un programa innovador para aumentar la ambici\u00f3n, la capacidad de resoluci\u00f3n de problemas y las oportunidades de los estudiantes m\u00e1s s\u00f3lidos en el campo de la inform\u00e1tica.
artemis.competencias.icpc.textc     = Con el tiempo, el concurso se convirti\u00f3 en una competencia de varios niveles con la primera ronda de campeonato llevada a cabo en 1977. Desde entonces, el concurso se ha convertido en una colaboraci\u00f3n mundial de universidades que organizan competiciones regionales que hacen avanzar a los equipos a la ronda de campeonatos mundial anual,  Las finales mundiales de ICPC (ICPC World Finals). 
artemis.competencias.google.title   = Google\u2019s Coding Competitions
artemis.competencias.google.text    = Google Code Jam es una competencia anual de programaci\u00f3n en la que se pide a los programadores profesionales y estudiantes que resuelvan desaf\u00edos algor\u00edtmicos complejos en un tiempo limitado, utilizando el lenguaje de programaci\u00f3n de su elecci\u00f3n. Este concurso comienza en l\u00ednea y los programadores pueden practicar probando problemas de a\u00f1os pasados.
artemis.competencias.google.textb   = Google Hash Code es un desaf\u00edo de codificaci\u00f3n para equipos de estudiantes y profesionales de todo el mundo. Los mejores equipos ser\u00e1n invitados a una oficina de Google para la ronda final.
artemis.competencias.google.textc   = Google Kick Start es una competencia global de codificaci\u00f3n en l\u00ednea, que consta de rondas de tres horas de una variedad de desaf\u00edos algor\u00edtmicos dise\u00f1ados por ingenieros de Google. Estas competencias se llevan a cabo durante todo el a\u00f1o y los participantes pueden tener la oportunidad de ser invitados a entrevistarse en Google
artemis.competencias.acis.title     = Marat\u00f3n Nacional de Programaci\u00f3n ACIS - REDIS
artemis.competencias.acis.text      = La Marat\u00f3n Nacional de Programaci\u00f3n, organizada por la Asociaci\u00f3n Colombiana de Ingenieros de Sistemas ACIS sirve de mecanismo para clasificar a la Marat\u00f3n Regional Latinoamericana ICPC  que, a su vez, sirve de selectivo para participar en la final mundial de la International Collegiate Programming Contest.
artemis.competencias.ccpl.title     = Colombian Collegiate Programming League
artemis.competencias.ccpl.text      = Colombian Collegiate Programming League (CCPL) es la liga de competencia en programaci\u00f3n m\u00e1s grande de Colombia, realizando diferentes rondas por a\u00f1o en donde las diferentes entidades de educaci\u00f3n superior env\u00edan equipos de estudiantes a competir, las competencias se realizan en diferentes sedes cada ronda y funcionan como entrenamiento para las competencias clasificatorias nacionales en Colombia.
artemis.competencias.masinfo.label  = Mas informaci\u00f3n en: 

#paginas entrenamiento
artemis.entrenamiento.p\u00e1ginas.text          = La comunidad de programaci\u00f3n competitiva alrededor del mundo ha creado y mantenido varios recursos dedicados de internet para la programaci\u00f3n competitiva, ellos ofrecen competencias internas con o sin premios, tambi\u00e9n los archivos de problemas pasados tambi\u00e9n se encuentran en estos para entrenamiento.
artemis.entrenamieto.primera.nombre         = CodeChef
artemis.entrenamieto.primera.descripcion    = Administrado por  by Directi, hostea competencias de 10 d\u00edas de largo un par de competencias peque\u00f1as cada mes, provee una plataforma de creaci\u00f3n de competencias para institutos acad\u00e9micos gratuitamente. El top 10 de ganadores de las competencias grandes obtiene premios en met\u00e1lico y camisetas de tazas de t\u00e9.
artemis.entrenamieto.primera.sitio          = www.codechef.com
artemis.entrenamieto.segundo.nombre         = CodeCup
artemis.entrenamieto.segundo.descripcion    = Competencia anual de programaci\u00f3n IA organizada por la Dutch Olympiad in Informatics desde  2003. 
artemis.entrenamieto.segundo.sitio          = www.codecup.nl
artemis.entrenamieto.tercero.nombre         = Codeforces
artemis.entrenamieto.tercero.descripcion    = Recurso ruso, manten\u00eda por la universidad ITMO, la cual mayormente provee competencias peque\u00f1as una o dos por semana.
artemis.entrenamieto.tercero.sitio          = www.codeforces.com
artemis.entrenamieto.cuarto.nombre          = CodinGame
artemis.entrenamieto.cuarto.descripcion     = Rompecabezas, code golf, organiza regularmente competencias de IA y problemas de optimizaci\u00f3n.
artemis.entrenamieto.cuarto.sitio           = www.codingame.com
artemis.entrenamieto.quinto.nombre          = HackerEarth
artemis.entrenamieto.quinto.descripcion     = Compa\u00f1\u00eda Hind\u00fa que provee entornos de competencia para reclutamiento de personal.
artemis.entrenamieto.quinto.sitio           = www.hackerearth.com
artemis.entrenamieto.sexto.nombre           = HackerRank
artemis.entrenamieto.sexto.descripcion      = Ofrece problemas de programaci\u00f3n en diferentes dominios de las ciencias de la computaci\u00f3n, tambi\u00e9n aloja una competencia anual que permite conexi\u00f3n entre los programadores y los diferentes Startups de Silicon Valley.
artemis.entrenamieto.sexto.sitio            = www.hackerrank.com
artemis.entrenamieto.septimo.nombre         = Project Euler
artemis.entrenamieto.septimo.descripcion    = Gran colecci\u00f3n de problemas matem\u00e1ticos computacionales.
artemis.entrenamieto.septimo.sitio          = www.projecteuler.net
artemis.entrenamieto.octavo.nombre          = Topcoder
artemis.entrenamieto.octavo.descripcion     = Recurso Norteamericano, el cual organiza competencias y tambi\u00e9n provee problemas de clase industrial, como trabajos Freelance, realiza docenas de competencias cada a\u00f1o.
artemis.entrenamieto.octavo.sitio           = www.topcoder.com
artemis.entrenamieto.noveno.nombre          = Online Judge
artemis.entrenamieto.noveno.descripcion     = Contiene m\u00e1s de 10.000 problemas de entrenamiento, almacena los diferentes problemas realizados en competencias clasificatorias en todo el mundo.
artemis.entrenamieto.noveno.sitio           = www.onlinejudge.org


#Biblioteca - Basico
artemis.biblioteca.general.codigoejemplo.title              = C\u00f3digo de ejemplo:
artemis.biblioteca.basico.operadores.text                   = Los operadores l\u00f3gicos nos proporcionan un resultado a partir de que se cumpla o no una cierta condici\u00f3n, producen un resultado booleano, y sus operandos son tambi\u00e9n valores l\u00f3gicos o asimilables a ellos (los valores num\u00e9ricos son asimilados a cierto o falso seg\u00fan su valor sea cero o distinto de cero). Esto genera una serie de valores que, en los casos m\u00e1s sencillos, pueden ser parametrizados con los valores num\u00e9ricos 0 y 1. La combinaci\u00f3n de dos o m\u00e1s operadores l\u00f3gicos conforma una funci\u00f3n l\u00f3gica.
artemis.biblioteca.basico.lecturaescritura.text             = Las lecturas e impresiones de nuestros ejercicios de programaci\u00f3n competitiva, sus algoritmos base y sus modificaciones se realizan por la consola (STDIN, STDOUT), por lo que la programaci\u00f3n de entornos gr\u00e1ficos para nuestros c\u00f3digos no es v\u00e1lida, los siguientes c\u00f3digos muestran ejemplos de c\u00f3mo se realizan las entradas y salidas de diferentes tipos de variables.
artemis.biblioteca.basico.tiempodeejecucion.text            = El tiempo de ejecuci\u00f3n es el per\u00edodo en el que un programa es ejecutado por el sistema operativo. El per\u00edodo comienza cuando el programa es llevado a la memoria primaria y comienzan a ejecutarse sus instrucciones. El per\u00edodo finaliza cuando el programa env\u00eda la se\u00f1al de t\u00e9rmino (normal o anormal) al sistema operativo. Suele decirse tambi\u00e9n que un programa se encuentra "corriendo" mientras est\u00e1 siendo ejecutado. Otros tiempos de un programa son el tiempo de compilaci\u00f3n, el tiempo de enlazado y el tiempo de carga.
artemis.biblioteca.basico.expresionesregulares.text         = Una expresi\u00f3n regular, o expresi\u00f3n racional, es una secuencia de caracteres que conforma un patr\u00f3n de b\u00fasqueda. Tambi\u00e9n son conocidas como regex por su contracci\u00f3n de las palabras inglesas regular expression. Son principalmente utilizadas para la b\u00fasqueda de patrones de cadenas de caracteres u operaciones de sustituciones.
artemis.biblioteca.basico.expresionesregularesa.text        = \u2022  x|y: x o y
artemis.biblioteca.basico.expresionesregularesb.text        = \u2022  xy: x seguido de y
artemis.biblioteca.basico.expresionesregularesc.text        = \u2022  (): Agrupaci\u00f3n 
artemis.biblioteca.basico.expresionesregularesd.text        = \u2022  [abc]: Cualquiera de los caracteres entre corchetes. Pueden especificarse rangos, por ejemplo ([a-d] que equivale a [abcd]).
artemis.biblioteca.basico.expresionesregularese.text        = \u2022  [^abc]: Cualquier car\u00e1cter que no est\u00e9 entre los corchetes.
artemis.biblioteca.basico.expresionesregularesf.text        = \u2022  [a-zA-Z]: a a la z o A a la Z (Rango).
artemis.biblioteca.basico.expresionesregularesg.text        = \u2022  [a-z&&[def]]: d,e, o f (Intersecci\u00f3n)
artemis.biblioteca.basico.expresionesregularesh.text        = \u2022  [a-b&&[^bc]]: (Substracci\u00f3n) 
artemis.biblioteca.basico.expresionesregularesi.text        = \u2022  .: Cualquier car\u00e1cter individual, salvo el de salto de l\u00ednea
artemis.biblioteca.basico.expresionesregularesj.text        = \u2022  \d: Cualquier car\u00e1cter de digito, equivalente a [0-9]
artemis.biblioteca.basico.expresionesregularesk.text        = \u2022  \D: Cualquier car\u00e1cter que no sea del digito, equivalente a [^0-9]
artemis.biblioteca.basico.expresionesregularesl.text        = \u2022  \s: Cualquier car\u00e1cter individual de espacio en blanco (Espacios, tabulaciones, saltos de p\u00e1gina o saltos de l\u00ednea)
artemis.biblioteca.basico.expresionesregularesm.text        = \u2022  \S: Cualquier car\u00e1cter individual que no sea un espacio en blanco
artemis.biblioteca.basico.expresionesregularesn.text        = \u2022  \w: Cualquier car\u00e1cter alfanum\u00e9rico
artemis.biblioteca.basico.expresionesregulareso.text        = \u2022  \W: Cualquier car\u00e1cter que no sea alfanum\u00e9rico
artemis.biblioteca.basico.complejidad.text                  = En Ciencias de la Computaci\u00f3n, el t\u00e9rmino eficiencia algor\u00edtmica es usado para describir aquellas propiedades de los algoritmos que est\u00e1n relacionadas con la cantidad de recursos utilizados por el algoritmo. Un algoritmo debe ser analizado para determinar el uso de los recursos que realiza. La eficiencia algor\u00edtmica puede ser vista como an\u00e1logo a la ingenier\u00eda de productividad de un procesorepetitivo o continuo.
artemis.biblioteca.basico.ciclos.texta                      = Un condicional, como su nombre lo indica, es una condici\u00f3n para discernir entre una opci\u00f3n u otra, y en el proceso mental normalmente se manifiesta con un \u201cSi\u201d; por ejemplo: Si (va a llover), coge el paraguas. Sint\u00e1cticamente, IF es la palabra reservada para desencadenar el poder de los condicionales en el c\u00f3digo. ELSE expresa \u201cen el caso contrario\u201d. Siguiendo con el ejemplo anterior de la lluvia: if (va a llover) coge el paraguas else coge el ba\u00f1ador.
artemis.biblioteca.basico.ciclos.textb                      = Un bucle o ciclo, en programaci\u00f3n, es una secuencia que ejecuta repetidas veces un trozo de c\u00f3digo, hasta que la condici\u00f3n asignada a dicho bucle deja de cumplirse. Los tres bucles m\u00e1s utilizados en programaci\u00f3n son el bucle while, el bucle for y el bucle do-while.
artemis.biblioteca.basico.ciclos.ejemplo                    = Ejemplo de entrada : 5


#Estructuras de datos B\u00e1sicas
artemis.estructuras.descripcion.text                                    = Lo habitual es que un vector tenga una cantidad fija de memoria asignada, aunque dependiendo del tipo de vector y del lenguaje de programaci\u00f3n un vector podr\u00eda tener una cantidad variable de datos. En este caso, se les denomina vectores din\u00e1micos, en oposici\u00f3n, a los vectores con una cantidad fija de memoria asignada se los denomina vectores est\u00e1ticos. El uso de vectores din\u00e1micos requiere realizar una apropiada gesti\u00f3n de memoria din\u00e1mica. Un uso incorrecto de los vectores din\u00e1micos, o mejor dicho, una mala gesti\u00f3n de la memoria din\u00e1mica, puede conducir a una fuga de memoria. Al utilizar vectores din\u00e1micos siempre habr\u00e1 que liberar la memoria utilizada cuando \u00e9sta ya no se vaya a seguir utilizando. Lenguajes m\u00e1s modernos y de m\u00e1s alto nivel, cuentan con un mecanismo denominado recolector de basura que permiten que el programa decida si debe liberar el espacio bas\u00e1ndose en si se va a utilizar en el futuro o no un determinado objeto.
artemis.estructuras.vector.text                                         = Se le denomina vector o formaci\u00f3n (en ingl\u00e9s Array) a una zona de almacenamiento contiguo que contiene una serie de elementos del mismo tipo, los elementos de la matriz. Desde el punto de vista l\u00f3gico una matriz se puede ver como un conjunto de elementos ordenados en fila (o filas y columnas si tuviera dos dimensiones). Estas estructuras de datos son adecuadas para situaciones en las que el acceso a los datos se realice de forma aleatoria e impredecible. Por el contrario, si los elementos pueden estar ordenados y se va a utilizar acceso secuencial ser\u00eda m\u00e1s adecuado utilizar una lista, ya que esta estructura puede cambiar de tama\u00f1o f\u00e1cilmente durante la ejecuci\u00f3n de un programa.
artemis.estructuras.vectordinamico.text                                 = En programaci\u00f3n, un arreglo din\u00e1mico o Array din\u00e1mico, es un Array de elementos que crece o mengua din\u00e1micamente conforme los elementos se agregan o se eliminan. Se suministra como librer\u00edas est\u00e1ndar en muchos lenguajes modernos de programaci\u00f3n. 
artemis.estructuras.vectorsinrepetir.text                               = Set es una interfaz que ampl\u00eda la colecci\u00f3n. Es una colecci\u00f3n desordenada de objetos en la que no se pueden almacenar valores duplicados. Set tiene varios m\u00e9todos para agregar, eliminar, borrar, tama\u00f1o, etc. 
artemis.estructuras.matriz.text                                         = Es una tabla bidimensional de n\u00fameros consistentes en cantidades abstractas con las que se pueden realizar diferentes operaciones, como por ejemplo la suma, multiplicaci\u00f3n y descomposici\u00f3n de las mismas de varias formas, lo que tambi\u00e9n las hace un concepto clave en el campo del \u00e1lgebra lineal. Las matrices se utilizan para describir sistema de ecuaciones lineales, realizar un seguimiento de los coeficientes de una aplicaci\u00f3n lineal y registrar los datos que dependen de varios par\u00e1metros.
artemis.estructuras.diccionario.text                                    = Los mapas son contenedores asociativos que almacenan elementos de forma mapeada. Cada elemento tiene un valor clave y un valor asignado. No hay dos valores asignados que puedan tener los mismos valores clave
artemis.estructuras.pila.text                                           = Es una lista ordenada o estructura de datos que permite almacenar y recuperar datos, el modo de acceso a sus elementos es de tipo LIFO (del ingl\u00e9s Last In, First Out, \u00ab\u00faltimo en entrar, primero en salir\u00bb). Esta estructura se aplica en multitud de supuestos en el \u00e1rea de inform\u00e1tica debido a su simplicidad y capacidad de dar respuesta a numerosos procesos.
artemis.estructuras.cola.text                                           = Es una estructura de datos, caracterizada por ser una secuencia de elementos en la que la operaci\u00f3n de inserci\u00f3n push se realiza por un extremo y la operaci\u00f3n de extracci\u00f3n pop por el otro. Tambi\u00e9n se le llama estructura FIFO (del ingl\u00e9s First In First Out), debido a que el primer elemento en entrar ser\u00e1 tambi\u00e9n el primero en salir.
artemis.biblioteca.basico.condicionales_ciclos.condicional.text         = Un condicional, como su nombre lo indica, es una condici\u00f3n para discernir entre una opci\u00f3n u otra, y en el proceso mental normalmente se manifiesta con un \u201cSi\u201d; por ejemplo: Si (va a llover), coge el paraguas. Sint\u00e1cticamente, IF es la palabra reservada para desencadenar el poder de los condicionales en el c\u00f3digo. ELSE expresa \u201cen el caso contrario\u201d. Siguiendo con el ejemplo anterior de la lluvia: if (va a llover) coge el paraguas else coge el ba\u00f1ador.
artemis.biblioteca.basico.condicionales_ciclos.ciclo.text               = Un bucle o ciclo, en programaci\u00f3n, es una secuencia que ejecuta repetidas veces un trozo de c\u00f3digo, hasta que la condici\u00f3n asignada a dicho bucle deja de cumplirse. Los tres bucles m\u00e1s utilizados en programaci\u00f3n son el bucle while, el bucle for y el bucle do-while.
artemis.biblioteca.basico.excepciones.text                              = El manejo de excepciones es una t\u00e9cnica de programaci\u00f3n que permite al programador controlar los errores ocasionados durante la ejecuci\u00f3n de un programa inform\u00e1tico. Cuando ocurre cierto tipo de error, el sistema reacciona ejecutando un fragmento de c\u00f3digo que resuelve la situaci\u00f3n, por ejemplo retornando un mensaje de error o devolviendo un valor por defecto.
artemis.biblioteca.basico.excepciones.ejemplo_entrada.text              = Ejemplo de entrada = 5
artemis.biblioteca.basico.excepciones.c++_comentario.text               = No es necesario controlar las excepciones, no almacena nada nuevo por lo que  el programa mostrara el valor que anteriormente ten\u00eda esa posici\u00f3n de memoria 

#Biblioteca - identidades
artemis.biblioteca.identidades.text                             = Una identidad es la constataci\u00f3n de que dos objetos que matem\u00e1ticamente se escriben diferente, son de hecho el mismo objeto. En particular, una identidad es a una igualdad entre dos expresiones, lo que es cierto sean cuales sean los valores de las distintas variables empleadas. Las identidades, al confirmarse invariablemente su igualdad, suelen utilizarse para transformar una expresi\u00f3n matem\u00e1tica en otra equivalente, particularmente para resolver una ecuaci\u00f3n.

#Biblioteca - Busquedas
artemis.biblioteca.busquedas.fibonacci.text                     = La b\u00fasqueda de Fibonacci es una t\u00e9cnica basada en la comparaci\u00f3n que utiliza los n\u00fameros de Fibonacci para buscar un elemento en un array ordenado.
artemis.biblioteca.busquedas.fibonacci.text1                    = Similitudes con la b\u00fasqueda binaria:
artemis.biblioteca.busquedas.fibonacci.texta                    =-	Trabaja con arrays ordenados.
artemis.biblioteca.busquedas.fibonacci.textb                    =-	Es un algoritmo de dividir y conquistar.
artemis.biblioteca.busquedas.fibonacci.textc                    =-	Tiene una complejidad de registro y tiempo.
artemis.biblioteca.busquedas.fibonacci.textd                    = Diferencias con la b\u00fasqueda binaria:
artemis.biblioteca.busquedas.fibonacci.texte                    =-	La b\u00fasqueda de Fibonacci divide un array dado en partes desiguales
artemis.biblioteca.busquedas.fibonacci.textf                    =-	La b\u00fasqueda binaria usa el operador de divisi\u00f3n para dividir el rango. La b\u00fasqueda de Fibonacci no usa /, pero usa + y -. El operador de la divisi\u00f3n puede ser costoso en algunas CPU.
artemis.biblioteca.busquedas.fibonacci.textg                    =-	La b\u00fasqueda de Fibonacci examina elementos relativamente m\u00e1s cercanos en pasos subsiguientes. Por lo tanto, cuando la matriz de entrada es grande y no cabe en la memoria cach\u00e9 de la CPU o incluso en la RAM, la b\u00fasqueda de Fibonacci puede ser \u00fatil.
artemis.biblioteca.busquedas.fibonacci.texth                    =-	La idea es encontrar primero el n\u00famero de Fibonacci m\u00e1s peque\u00f1o que sea mayor o igual a la longitud de la matriz dada.
artemis.biblioteca.busquedas.saltos.text                        =  Al igual que Binary Search, Jump Search es un algoritmo de b\u00fasqueda para matrices ordenadas. La idea b\u00e1sica es verificar menos elementos (que la b\u00fasqueda lineal) saltando hacia delante con pasos fijos u salteando algunos elementos en lugar de buscar todos los elementos. En el peor de los casos, tenemos que realizar saltos de n / m y, si el \u00faltimo valor verificado es mayor que el elemento a buscar, realizamos comparaciones de m-1 m\u00e1s para la b\u00fasqueda lineal. Por lo tanto, el n\u00famero total de comparaciones en el peor de los casos ser\u00e1 ((n / m) + m-1). El valor de la funci\u00f3n ((n / m) + m-1) ser\u00e1 m\u00ednimo cuando m = \u221an. Por lo tanto, el mejor tama\u00f1o de paso es m = \u221an.
artemis.biblioteca.busquedas.saltos.texta                       = Puntos importantes:
artemis.biblioteca.busquedas.saltos.textb                       =-	Trabaja solo arreglos ordenados.
artemis.biblioteca.busquedas.saltos.textc                       =-	El tama\u00f1o \u00f3ptimo de un bloque a saltar es (\u221a n). Esto hace que la complejidad del tiempo de Jump Search O (\u221a n).
artemis.biblioteca.busquedas.saltos.textd                       =-	La complejidad temporal de la b\u00fasqueda por salto es entre la b\u00fasqueda lineal ((O (n)) y la b\u00fasqueda binaria (O (Log n)).
artemis.biblioteca.busquedas.saltos.texte                       =-	La b\u00fasqueda binaria es mejor que la b\u00fasqueda por salto, pero la b\u00fasqueda por salto tiene la ventaja de que retrocedemos solo una vez (la b\u00fasqueda binaria puede requerir saltos O (Log n), considere una situaci\u00f3n en la que el elemento a buscar es el elemento m\u00e1s peque\u00f1o o m\u00e1s peque\u00f1o que el m\u00e1s peque\u00f1o). Entonces, en un sistema donde el salto hacia atr\u00e1s es costoso, usamos Jump Search.
artemis.biblioteca.busqueda.diferencia_pares.parrafo1.text      = Dada una matriz sin orden y un n\u00famero n, busque si existe un par de elementos en la matriz cuya diferencia es n. El m\u00e9todo m\u00e1s simple es ejecutar dos bucles, el bucle externo selecciona el primer elemento (elemento m\u00e1s peque\u00f1o) y el bucle interno busca el elemento seleccionado por el bucle externo m\u00e1s n. La complejidad del tiempo de este m\u00e9todo es O (n ^ 2).
artemis.biblioteca.busqueda.diferencia_pares.parrafo2.text      = Podemos usar la ordenaci\u00f3n y la b\u00fasqueda binaria para mejorar la complejidad del tiempo a O (nLogn). El primer paso es ordenar el array en orden ascendente. Una vez que el array est\u00e9 ordenado, recorra el array de izquierda a derecha y, para cada elemento arr [i], la b\u00fasqueda binaria de arr [i] + n en arr [i + 1...n-1]. Si se encuentra el elemento, devuelva el par. Tanto el primer como el segundo paso toman O (nLogn). As\u00ed que la complejidad global es O (nLogn).
artemis.biblioteca.busqueda.diferencia_pares.parrafo3.text      = El segundo paso del algoritmo anterior se puede mejorar a O (n). El primer paso sigue siendo el mismo. La idea para el segundo paso es tomar dos variables de \u00edndice i y j, inicializarlas como 0 y 1 respectivamente. Ahora ejecuta un bucle lineal. Si arr [j] - arr [i] es m\u00e1s peque\u00f1o que n, debemos buscar un arr mayor [j], as\u00ed que aumente j. Si arr [j] - arr [i] es mayor que n, debemos buscar un arr mayor [i], entonces incremente i.
artemis.biblioteca.busquedas.missingno.texta                    = Se le da una lista de n-1 enteros y estos enteros est\u00e1n en el rango de 1 a n. No hay duplicados en la lista. Falta uno de los enteros en la lista.
artemis.biblioteca.busquedas.missingno.textb                    = 1) XOR todos los elementos del array, que el resultado de XOR sea X1.
artemis.biblioteca.busquedas.missingno.textc                    = 2) XOR todos los n\u00fameros del 1 al n, sea XOR sea X2.
artemis.biblioteca.busquedas.missingno.textd                    = 3) XOR de X1 y X2 da el n\u00famero que falta.
artemis.biblioteca.busquedas.minimumsum.texta                   = Dos elementos cuya suma es la m\u00e1s cercana a cero. Para cada elemento, encuentre la suma con cada otro elemento en el array y compare las sumas. Por \u00faltimo, devolver la suma m\u00ednima.
artemis.biblioteca.busquedas.minmax.texta                       = Cuando tenemos un Array en donde queremos buscar el valor m\u00e1s peque\u00f1o y el valor m\u00e1s grande del mismo de forma eficiente haciendo la menor cantidad de comparaciones.
artemis.biblioteca.busquedas.exponentialsearch.texta            = El nombre de este algoritmo de b\u00fasqueda puede ser enga\u00f1oso, ya que funciona en tiempo O (Log n). El nombre proviene de la forma en que busca un elemento. La b\u00fasqueda binaria exponencial es particularmente \u00fatil para b\u00fasquedas ilimitadas, donde el tama\u00f1o de la matriz es infinito.
artemis.biblioteca.busquedas.binarysearch.text                  = La b\u00fasqueda binaria, tambi\u00e9n conocida como b\u00fasqueda de intervalo medio o b\u00fasqueda logar\u00edtmica, es un algoritmo de b\u00fasqueda que encuentra la posici\u00f3n de un valor en un arreglo ordenado. Compara el valor con el elemento en el medio del arreglo, si no son iguales, la mitad en la cual el valor no puede estar es eliminada y la b\u00fasqueda sigue en la mitad restante hasta que el valor se encuentre. La b\u00fasqueda binaria es computada en el peor de los casos en un tiempo logar\u00edtmico, realizando  O (log n)  comparaciones, donde n es el n\u00famero de elementos del arreglo y log es el logaritmo.
artemis.biblioteca.busquedas.ternarysearch.texta                = La b\u00fasqueda ternaria es un algoritmo de dividir y conquistar que se puede usar para encontrar un elemento en un array. Es similar a la b\u00fasqueda binaria donde dividimos el array en dos partes pero en este algoritmo. En esto, dividimos el array dado en tres partes y determinamos cu\u00e1l tiene la clave (elemento buscado). Podemos dividir el array en tres partes tomando mid1 y mid2, que se pueden calcular como se muestra a continuaci\u00f3n.
artemis.biblioteca.busquedas.ternarysearch.textb                = mid1 = l + (r-l) / 3
artemis.biblioteca.busquedas.ternarysearch.textc                = mid2 = r - (r-l) / 3
artemis.biblioteca.busquedas.ternarysearch.textd                = Inicialmente, l y r ser\u00e1n iguales a 0 y n-1 respectivamente, donde n es la longitud de la matriz.
artemis.biblioteca.busquedas.ternarysearch.texte                = El array debe ordenarse para realizar una b\u00fasqueda ternaria en ella.

#biblioteca - ordenamientos
artemis.biblioteca.ordenamientos.threewaymerge.texta        = Merge sort envuelve separaci\u00f3n recursiva del array en dos partes, ordenamiento y finalmente uni\u00f3n de las mismas. Una variante de merge sort es llamado merge sort de tres v\u00edas donde en vez de separar el array en dos partes se separa en tres. Merge sort recursivamente rompe los arrays en arrays de tama\u00f1o medio, Merge de tres v\u00edas hace lo mismo en arrays de tama\u00f1o de un tercio.
artemis.biblioteca.ordenamientos.threewaymerge.textb        = Complejidad de tiempo: En caso de Merge Sort se tiene la ecuaci\u00f3n T(n) = 2T(n/2) + O(n). Igualmente en caso de Merge de tres v\u00edas se tiene la ecuaci\u00f3n(n) = 3T(n/3) + O(n) por lo que la aproximaci\u00f3n m\u00e1s cercana de su complejidad es: O(n log 3n).
artemis.biblioteca.ordenamientos.binaryinsertion.texta      = Podemos usar la b\u00fasqueda binaria para reducir el n\u00famero de comparaciones en la clasificaci\u00f3n de inserci\u00f3n normal. La clasificaci\u00f3n de inserci\u00f3n binaria utiliza la b\u00fasqueda binaria para encontrar la ubicaci\u00f3n adecuada para insertar el elemento seleccionado en cada iteraci\u00f3n.
artemis.biblioteca.ordenamientos.binaryinsertion.textb      = En la clasificaci\u00f3n de inserci\u00f3n normal, se necesitan comparaciones O(n) (en la iteraci\u00f3n n) en el peor de los casos. Podemos reducirlo a O (log n) mediante la b\u00fasqueda binaria.
artemis.biblioteca.ordenamientos.binaryinsertion.textc      = El algoritmo en su conjunto a\u00fan tiene un tiempo de ejecuci\u00f3n en el peor de los casos de O (n2) debido a la serie de intercambios necesarios para cada inserci\u00f3n
artemis.biblioteca.ordenamientos.bitonic.texta              = Bitonic Sort es un algoritmo paralelo cl\u00e1sico para ordenamiento. La ordenaci\u00f3n bit\u00f3nica hace comparaciones O (n Log 2n). El n\u00famero de comparaciones realizadas por Bitonic Sort son m\u00e1s que los algoritmos de clasificaci\u00f3n populares como Merge Sort [hace O (nLogn) comparaciones], pero Bitonic es mejor para la implementaci\u00f3n en paralelo porque siempre comparamos elementos en una secuencia predefinida y la secuencia de comparaci\u00f3n no. Depende de los datos. Por lo tanto, es adecuado para la implementaci\u00f3n en hardware y array de procesado paralelo. Para entender el ordenamiento bit\u00f3nico, primero debemos entender qu\u00e9 es la secuencia bit\u00f3nica y c\u00f3mo hacer una secuencia dada bit\u00f3nica.
artemis.biblioteca.ordenamientos.bitonic.textb              = Una secuencia es bit\u00f3nica si primero aumenta, luego disminuye. En otras palabras, una matriz arr [0...n-i] es Bitonic si existe un \u00edndice i donde 0 <= i <= n-1 tal que
artemis.biblioteca.ordenamientos.bitonic.textc              = x0 <= x1 ... .. <= xi y xi> = xi + 1 ... ..> = xn-1
artemis.biblioteca.ordenamientos.bitonic.textd              = Para formar una secuencia ordenada de longitud n a partir de dos secuencias ordenadas de longitud n / 2, se requieren comparaciones de log (n) (por ejemplo: log (8) = 3 cuando el tama\u00f1o de la secuencia. Por lo tanto, el n\u00famero de comparaciones T (n) de La clasificaci\u00f3n completa est\u00e1 dada por:
artemis.biblioteca.ordenamientos.bitonic.texte              = T (n) = log (n) + T (n / 2)
artemis.biblioteca.ordenamientos.bitonic.textf              = La soluci\u00f3n de esta ecuaci\u00f3n de recurrencia es:
artemis.biblioteca.ordenamientos.bitonic.textg              = T (n) = log (n) + log (n) -1 + log (n) -2 +\u2026 + 1 = log (n) \u2022 (log (n) +1) / 2
artemis.biblioteca.ordenamientos.bitonic.texth              = Como, cada etapa de la red de clasificaci\u00f3n consiste en n / 2 comparaciones. Por lo tanto un total de O (n log2n) comparaciones.
artemis.biblioteca.ordenamientos.bubble.text                = Ordenamiento burbuja es el algoritmo de ordenamiento m\u00e1s simple que existe, funciona intercambiando repetidamente los elementos adyacentes si est\u00e1n en orden incorrecto.
artemis.biblioteca.ordenamientos.cocktail.texta             = Cocktail Sort es una variaci\u00f3n de Bubble Sort. El algoritmo de clasificaci\u00f3n de burbuja siempre atraviesa elementos de la izquierda y mueve el elemento m\u00e1s grande a su posici\u00f3n correcta en la primera iteraci\u00f3n y el segundo m\u00e1s grande en la segunda iteraci\u00f3n, y as\u00ed sucesivamente. La clasificaci\u00f3n de c\u00f3ctel atraviesa una matriz dada en ambas direcciones alternativamente.
artemis.biblioteca.ordenamientos.cocktail.textb             = Las complejidades de tiempo son iguales, pero Cocktail se desempe\u00f1a mejor que Bubble Sort. Por lo general, el c\u00f3ctel es menos de dos veces m\u00e1s r\u00e1pido que el tipo burbuja. Considere el ejemplo (2, 3, 4, 5, 1). La clasificaci\u00f3n de burbuja requiere cuatro recorridos de matriz para este ejemplo, mientras que la clasificaci\u00f3n de c\u00f3ctel requiere solo dos recorridos.
artemis.biblioteca.ordenamientos.cocktail.textc             = Tiempo del peor caso y caso promedio O (n * n). Tiempo del mejor caso es O (n). El mejor caso ocurre cuando el array ya est\u00e1 ordenado.
artemis.biblioteca.ordenamientos.comb.text                  = Comb Sort es principalmente una mejora sobre Bubble Sort. La ordenaci\u00f3n de burbuja siempre compara valores adyacentes. As\u00ed que todas las inversiones se eliminan una por una. Comb Sort mejora en Bubble Sort usando un espacio de tama\u00f1o mayor que 1. El espacio comienza con un gran valor y se reduce en un factor de 1.3 en cada iteraci\u00f3n hasta que alcanza el valor 1. Por lo tanto, Comb Sort elimina m\u00e1s de una cuenta de inversi\u00f3n con cada Intercambio y funciona mejor que Bubble Sort. Aunque funciona mejor que Bubble Sort en promedio, el peor de los casos sigue siendo O (n^2).
artemis.biblioteca.ordenamientos.counting.texta             = El ordenamiento por conteo es una t\u00e9cnica de ordenamiento basada en claves entre un rango espec\u00edfico. Funciona contando el n\u00famero de objetos que tienen valores clave distintos (tipo de hashing). Luego, hacer algo de aritm\u00e9tica para calcular la posici\u00f3n de cada objeto en la secuencia de salida.
artemis.biblioteca.ordenamientos.counting.textb             = 1. La ordenaci\u00f3n de conteo es eficiente si el rango de datos de entrada no es significativamente mayor que el n\u00famero de objetos a clasificar. 
artemis.biblioteca.ordenamientos.counting.textc             = 2. No es una comparaci\u00f3n basada en la clasificaci\u00f3n. La complejidad del tiempo de ejecuci\u00f3n es O (n) con espacio proporcional al rango de datos.
artemis.biblioteca.ordenamientos.counting.textd             = 3. A menudo se usa como una sub-rutina para otro algoritmo de clasificaci\u00f3n como la clasificaci\u00f3n por radix.
artemis.biblioteca.ordenamientos.counting.texte             = 4. La ordenaci\u00f3n de conteo usa un hashing parcial para contar la ocurrencia del objeto de datos en O (1).
artemis.biblioteca.ordenamientos.counting.textf             = 5. La ordenaci\u00f3n de conteo tambi\u00e9n se puede extender para que funcione con entradas negativas.
artemis.biblioteca.ordenamientos.cycle.texta                = El ordenamiento de ciclos es un algoritmo de ordenamiento en el lugar, una ordenaci\u00f3n de comparaci\u00f3n que es te\u00f3ricamente \u00f3ptima en t\u00e9rminos del n\u00famero total de escrituras en el array original.
artemis.biblioteca.ordenamientos.cycle.textb                = Es \u00f3ptimo en t\u00e9rminos de cantidad de escrituras de memoria. Minimiza el n\u00famero de escrituras de memoria para ordenar (cada valor se escribe cero veces, si ya est\u00e1 en su posici\u00f3n correcta, o se escribe una vez en su posici\u00f3n correcta).
artemis.biblioteca.ordenamientos.merge.texta                = Al igual que Quick Sort, Merge Sort es un algoritmo de Dividir y Conquistar. Divide el arreglo de entrada en dos mitades, se llama a s\u00ed misma para las dos mitades y luego combina las dos mitades clasificadas. La funci\u00f3n merge () se usa para fusionar dos mitades.
artemis.biblioteca.ordenamientos.merge.textb                = El merge (arr, l, m, r) es un proceso clave que asume que arr [l...m] y arr [m + 1...r] est\u00e1n ordenados y combina los dos subarreglos ordenados en uno solo.
artemis.biblioteca.ordenamientos.merge.textc                = Merge Sort es \u00fatil para ordenar listas enlazadas en tiempo O (nLogn). En el caso de listas enlazadas, el caso es diferente principalmente debido a la diferencia en la asignaci\u00f3n de memoria de los arrays y las listas enlazadas. A diferencia de los arrays, los nodos de listas enlazadas pueden no estar adyacentes en la memoria. A diferencia del array, en la lista enlazada, podemos insertar elementos en el medio en O (1) espacio adicional y O (1) tiempo. Por lo tanto, la operaci\u00f3n de fusi\u00f3n de la ordenaci\u00f3n de fusi\u00f3n se puede implementar sin espacio adicional para las listas vinculadas.
artemis.biblioteca.ordenamientos.merge.textd                = En arrays, podemos hacer acceso aleatorio ya que los elementos son continuos en la memoria.
artemis.biblioteca.ordenamientos.pigeon.texta               = Ordenamiento nido de Paloma es un algoritmo de ordenamiento que es adecuado para ordenar listas de elementos donde el n\u00famero de elementos y el n\u00famero de valores de los mismos son aproximadamente lo mismo.
artemis.biblioteca.ordenamientos.pigeon.textb               = Este requiere un tiempo de  O(n + Rango) donde n es el n\u00famero de elementos en el array de entrada y Rango es el n\u00famero de posibles valores en el array. Este algoritmo es similar a Counting sort, pero difiere en la forma en que mueve los datos, dos veces.
artemis.biblioteca.ordenamientos.quick.texta                = Quick Sort es un algoritmo de Dividir y Conquistar. Selecciona un elemento como pivote y divide el array dado alrededor del pivote seleccionado. Hay muchas versiones diferentes de quick Sort que seleccionan pivote de diferentes maneras.
artemis.biblioteca.ordenamientos.quick.textb                = -	Elije siempre el primer elemento como pivote.
artemis.biblioteca.ordenamientos.quick.textc                = -	Siempre elije el \u00faltimo elemento como pivote.
artemis.biblioteca.ordenamientos.quick.textd                = -	Elige un elemento aleatorio como pivote.
artemis.biblioteca.ordenamientos.quick.texte                = -	Elije la mediana como pivote.
artemis.biblioteca.ordenamientos.quick.textf                = El proceso clave en quick Sort es partition (). El destino de las particiones es, dada un array y un elemento x del array como pivote, coloca x en su posici\u00f3n correcta en el array ordenado y coloca todos los elementos m\u00e1s peque\u00f1os (m\u00e1s peque\u00f1os que x) antes de x, y coloca todos los elementos mayores (mayores que x) despu\u00e9s de X. Todo esto debe hacerse en tiempo lineal.
artemis.biblioteca.ordenamientos.radix.texta                = La idea de Radix Sort es hacer una clasificaci\u00f3n de d\u00edgito por d\u00edgito desde el d\u00edgito menos significativo hasta el d\u00edgito m\u00e1s significativo. La ordenaci\u00f3n de Radix usa la ordenaci\u00f3n de conteo como una subrutina para ordenar.
artemis.biblioteca.ordenamientos.radix.textb                = Si tenemos bits log2n para cada d\u00edgito, el tiempo de ejecuci\u00f3n de Radix parece ser mejor que Quick Sort para una amplia gama de n\u00fameros de entrada. Los factores constantes ocultos en la notaci\u00f3n asint\u00f3tica son mayores para Radix Sort y Quick-Sort usa cach\u00e9s de hardware de manera m\u00e1s efectiva.
artemis.biblioteca.ordenamientos.shell.texta                = Shell Sort es principalmente una variaci\u00f3n de Insertion Sort. En la ordenaci\u00f3n por inserci\u00f3n, movemos los elementos solo una posici\u00f3n adelante. Cuando un elemento tiene que moverse mucho m\u00e1s adelante, hay muchos movimientos involucrados. La idea de shell Sort es permitir el intercambio de elementos lejanos. En shell Sort, hacemos el array h-ordenado para un gran valor de h. Continuamos reduciendo el valor de h hasta que se convierte en 1. Se dice que un array est\u00e1 ordenado por h si todas las sublistas de cada elemento h est\u00e1n ordenadas.
artemis.biblioteca.ordenamientos.shell.textb                = La complejidad de tiempo de la implementaci\u00f3n de shell Sort es O (n2). En la implementaci\u00f3n la brecha se reduce a la mitad en cada iteraci\u00f3n.
artemis.biblioteca.ordenamientos.tim.texta                  = TimSort es un algoritmo de ordenamiento basado en Insertion Sort y Merge Sort.
artemis.biblioteca.ordenamientos.tim.textb                  = -	Es un algoritmo de ordenamiento estable funciona en tiempo O (n Log n)
artemis.biblioteca.ordenamientos.tim.textc                  = -	Se utiliza en Arrays.sort () de Java, as\u00ed como en Python sorted() y C++ sort()
artemis.biblioteca.ordenamientos.tim.textd                  = -	Primero clasifica las piezas peque\u00f1as utilizando el ordenamiento de Inserci\u00f3n, luego fusione las piezas utilizando la combinaci\u00f3n de ordenaci\u00f3n por fusi\u00f3n (Merge).
artemis.biblioteca.ordenamientos.tim.texte                  = Dividimos el array en bloques conocidos como Run. Ordenamos esas ejecuciones utilizando la ordenaci\u00f3n por inserci\u00f3n una por una y luego las combinamos utilizando la funci\u00f3n de combinaci\u00f3n utilizada en Merge Sort. Si el tama\u00f1o del array es menor que run, entonces el array se clasifica simplemente utilizando el orden de inserci\u00f3n.
artemis.biblioteca.ordenamientos.tim.textf                  = El tama\u00f1o de run puede variar de 32 a 64, dependiendo del tama\u00f1o del array. Tenga en cuenta que la funci\u00f3n de combinaci\u00f3n funciona bien cuando los arreglos secundarios de tama\u00f1o son potencias de 2. La idea se basa en el hecho de que la ordenaci\u00f3n por inserci\u00f3n funciona bien para arreglos peque\u00f1os.
artemis.biblioteca.ordenamientos.tree.texta                 = Ordenamiento \u00e1rbol es un algoritmo de clasificaci\u00f3n que se basa en la estructura de datos del Binary Search Tree. Primero crea un \u00e1rbol de b\u00fasqueda binario a partir de los elementos de la lista de entrada o un array luego realiza un recorrido inorden en el \u00e1rbol de b\u00fasqueda binario creado para obtener los elementos ordenados.
artemis.biblioteca.ordenamientos.tree.textb                 = Su complejidad de tiempo es O (nLogn) en el mejor de los casos y O(n^2) en el peor.

#biblioteca - Strings
artemis.biblioteca.strings.ahocorasick.texta    = Dada una entrada de texto y un array de k palabras, arr[], encontrar todas las ocurrencias de todas las palabras en el texto de entrada. Sea n la longitud del texto y m sea el n\u00famero total de caracteres en todas las palabras, por ejemplo: m = length (arr [0]) + length (arr [1]) +\u2026 + length (arr [k-1]). Si usamos un algoritmo de tiempo linear como KMP, entonces necesitaremos una b\u00fasqueda uno por uno de todas las palabras en text[]. Esto nos da un total de complejidad de tiempo de O(n + length(word[0]) + O(n + length(word[1]) + O(n + length(word[2]) + \u2026 O(n + length(word[k-1]).  Esta complejidad de tiempo puede ser escrita como  O(n*k + m).
artemis.biblioteca.strings.ahocorasick.textb    = Aho-corasick encuentra todas las palabras en tiempo O(n+m+z) donde z es el n\u00famero total de ocurrencias de las palabras en el texto, este algoritmo forma las bases del comando original de Unix fgrep. 
artemis.biblioteca.strings.ahocorasick.textc    = Este algoritmo tiene dos pasos principales:
artemis.biblioteca.strings.ahocorasick.textd    = - Preprocesado: Construye un automaton de todas las palabras en arr[].
artemis.biblioteca.strings.ahocorasick.texte    = - Cotejamiento: Atraviesa el texto dado sobre el automaton formado para encontrar las palabras a cotejar. Por un estado s, los \u00edndices de todas las palabras terminados en s son almacenadas. Estos \u00edndices son almacenados en un map de BitWise (Haciendo OR a lo valores. Esto tambi\u00e9n computa usando b\u00fasqueda primera en anchura con fallo.
artemis.biblioteca.strings.anagrams.texta       = Dado un texto txt [0...n-1] y un patr\u00f3n pat [0...m-11], use una funci\u00f3n que imprima todas las ocurrencias de pat [] y sus permutaciones (o anagramas) en txt [], se asume que n es menor que m. La complejidad de tiempo esperada es de O(n).
artemis.biblioteca.strings.anagrams.textb       = Este problema es ligeramente diferente a la b\u00fasqueda de patrones est\u00e1ndar, aqu\u00ed necesitamos buscar por anagramas tambi\u00e9n. Por lo tanto no podemos aplicar directamente la b\u00fasqueda de patrones est\u00e1ndar de algoritmos como KMP, Rabin Karp o Boyer Moore. Podemos conseguir una complejidad de tiempo de O(n) asumiendo que el tama\u00f1o del alfabeto est\u00e1 arreglado en los 256 caracteres ASCII. La idea es usar dos arrays de conteo:
artemis.biblioteca.strings.anagrams.textc       = 1)	El primer array de conteo almacena la frecuencia de los caracteres en el patr\u00f3n.
artemis.biblioteca.strings.anagrams.textd       = 2)	El Segundo array de conteo almacena la frecuencia en la actual ventana de texto.
artemis.biblioteca.strings.anagrams.texte       = Una cosa importante a tener en cuenta es, la complejidad de tiempo de comparar dos arrays de conteo es O(1) como el n\u00famero de elementos en ellos. Estos son los pasos de este algoritmo:
artemis.biblioteca.strings.anagrams.textf       = 1)	Almacena conteos de frecuencia del patr\u00f3n en el primer array de conteo countP []. Tambi\u00e9n almacena conteo de frecuencias de la primera ventana de texto en el array countTW[].
artemis.biblioteca.strings.anagrams.textg       = 2)	Ahora ejecuta un ciclo de i=M hasta N-1 haciendo lo siguiente en cada ciclo:
artemis.biblioteca.strings.anagrams.texth       = a)	Si los dos arrays de conteo son id\u00e9nticos, hemos encontrado una ocurrencia.
artemis.biblioteca.strings.anagrams.texti       = b)	Incrementa el conteo del actual car\u00e1cter del texto en countTW[]
artemis.biblioteca.strings.anagrams.textj       = c)	Decrementa conteo del primer car\u00e1cter en la ventana anterior en countWT[]
artemis.biblioteca.strings.anagrams.textk       = 3) La \u00faltima ventana no es revisada por este ciclo, se revisa expl\u00edcitamente.
artemis.biblioteca.strings.boyermoore.texta     = Cuando realizamos una b\u00fasqueda de un string en Notepad, Word, buscador o una base de datos, los algoritmos de b\u00fasquedas de patrones son usados para buscar los resultados. Un enunciado de este problema podr\u00eda ser:
artemis.biblioteca.strings.boyermoore.textb     = Dado un texto txt[0\u2026n-1] y un patr\u00f3n pat[0...m-1] busque una funci\u00f3n que imprima todas las ocurrencias de pat en txt, se asume que n es mayor que m. Como KMP y Finite Automata, Boyer Moore tambi\u00e9n preprocesa el patr\u00f3n, Boyer Moore es la combinaci\u00f3n de las siguientes dos aproximaciones:
artemis.biblioteca.strings.boyermoore.textc     = 1) Heur\u00edstica de caracteres malos
artemis.biblioteca.strings.boyermoore.textd     = 2) Heur\u00edstica de buenos sufijos
artemis.biblioteca.strings.boyermoore.texte     = Ambas de las dos heur\u00edsticas de arriba pueden tambi\u00e9n ser usadas independientemente para buscar un patr\u00f3n en un texto. Primero entendamos como estas dos aproximaciones trabajan juntos en Boyer Moore. Si tomamos un vistazo a cualquier algoritmo ingenuo, desliza el patr\u00f3n sobre el texto car\u00e1cter por car\u00e1cter. KMP hace preprocesado sobre el patr\u00f3n de tal forma que el patr\u00f3n puede ser cambiado m\u00e1s de una vez.
artemis.biblioteca.strings.boyermoore.textf     = El algoritmo de Boyer Moore hace preprocesado por la misma raz\u00f3n. Este procesa el patr\u00f3n y crea arrays diferentes para cada heur\u00edstica. En cada paso desliza el patr\u00f3n por el m\u00e1ximo de deslices sugeridos por las dos heur\u00edsticas, entonces usa la mejor de las dos heur\u00edsticas en cada paso. 
artemis.biblioteca.strings.boyermoore.textg     = A diferencia de los anteriores algoritmos de b\u00fasqueda de patrones, Boyer Moore comienza el cotejamiento desde el \u00faltimo car\u00e1cter del patr\u00f3n.
artemis.biblioteca.strings.boyermoore.texth     = Heur\u00edstica de caracteres malos
artemis.biblioteca.strings.boyermoore.texti     = La idea de esta heur\u00edstica es simple. El car\u00e1cter del texto que no coincida con el car\u00e1cter actual del patr\u00f3n es llamado un car\u00e1cter malo. Con esta no coincidencia nosotros movemos el patr\u00f3n hasta:
artemis.biblioteca.strings.boyermoore.textj     = 1) La no coincidencia se convierta en un cotejamiento positivo.
artemis.biblioteca.strings.boyermoore.textk     = 2) Patr\u00f3n P se mueve despu\u00e9s del car\u00e1cter no coincidente.
artemis.biblioteca.strings.boyermoore.textl     = Caso 1: No coincidencia se convierte en una coincidencia
artemis.biblioteca.strings.boyermoore.textm     = Buscamos la posici\u00f3n de la \u00faltima ocurrencia del car\u00e1cter no coincidente en el patr\u00f3n y si el car\u00e1cter no coincidente existe en el patr\u00f3n, entones movemos el patr\u00f3n de tal manera que quede alineado con el car\u00e1cter no coincidente en el texto T.
artemis.biblioteca.strings.boyermoore.textn     = Caso 2: El patr\u00f3n se mueve pasado el car\u00e1cter no coincidente
artemis.biblioteca.strings.boyermoore.texto     = Nosotros buscamos la posici\u00f3n de la \u00faltima ocurrencia del car\u00e1cter no coincidente en el patr\u00f3n y si el car\u00e1cter no existe deber\u00edamos mover el patr\u00f3n pasado ese car\u00e1cter. 
artemis.biblioteca.strings.finiteautomata.texta = Dado un texto txt[0...n-1] y un patr\u00f3n pat[0...m-1], busque todas las ocurrencias de pat en txt e impr\u00edmalas, asuma que n es mayor que m.
artemis.biblioteca.strings.finiteautomata.textb = En el algoritmo basado en Finite aut\u00f3mata, nosotros preprocesamos el patr\u00f3n y construimos un array de dos dimensiones que represente un aut\u00f3mata finito. Construcci\u00f3n del FA es la parte complicada de este algoritmo. Una vez el FA este construido, la b\u00fasqueda es simple, En la b\u00fasqueda nosotros simplemente necesitamos iniciar desde el primer estado del aut\u00f3mata y el primer car\u00e1cter del texto. En cada paso, consideramos el siguiente car\u00e1cter del texto, miramos por el siguiente estado en el FA construido y nos movemos a un nuevo estado. Si alcanzamos el estado final, entonces el patr\u00f3n fue encontrado en el texto.
artemis.biblioteca.strings.finiteautomata.textc = La complejidad de tiempo en el proceso de b\u00fasqueda es de O(n).
artemis.biblioteca.strings.kmp.texta            = Dado un texto txt[0\u2026n-1] y un patr\u00f3n pat[0...m-1] busque todas las ocurrencias de pat en txt e impr\u00edmalas, asuma que n es mayor que m.
artemis.biblioteca.strings.kmp.textb            = El algoritmo KMP usa la propiedad de degeneraci\u00f3n (Patr\u00f3n teniendo el mismo sub patr\u00f3n apareciendo m\u00e1s de una vez en el patr\u00f3n) del patr\u00f3n y mejora el peor caso de complejidad de O(n). La idea b\u00e1sica detr\u00e1s de KMP es: Cuando no detectemos una no coincidencia (luego de algunas coincidencias), ya sabemos algunos de los caracteres en el texto de la siguiente ventana. Tomamos ventaja de esta informaci\u00f3n para evadir coincidencias de caracteres que sabemos que de todas maneras coincidir\u00e1n.
artemis.biblioteca.strings.kmp.textc            = Revisi\u00f3n del preprocesado:
artemis.biblioteca.strings.kmp.textd            = KMP preprocesa pat[] y construye un lps[] auxiliar de tama\u00f1o m (El mismo tama\u00f1o que el patr\u00f3n) el cual es usado para saltar caracteres mientras se coteja.
artemis.biblioteca.strings.kmp.texte            = El nombre lps indica el prefijo propio m\u00e1s largo el cual es tambi\u00e9n sufijo. Un prefijo propio es un prefijo  con todo el string no permitido. Por ejemplo, prefijos de \u201cABC\u201d son \u201c\u201d,\u201dA\u201d,\u201dAB\u201d Y \u201cABC\u201d, prefijos propios son \u201c\u201d, \u201cA\u201d y \u201cAB\u201d. Sufijos del string son \u201c\u201d, \u201cC\u201d,\u201dBC\u201d y \u201cABC\u201d.
artemis.biblioteca.strings.kmp.textf            = Buscamos por lps en subpatrones. M\u00e1s claramente nos enfocamos en los subsring de patrones que son prefijos y sufijos. Por cada subpatron pat[0...i] donde i=0 hasta m-1, lps[i] almacena la longitud del m\u00e1ximo prefijo propio coincidente el cual tambi\u00e9n es sufijo del subpatron pat[0...i].
artemis.biblioteca.strings.kmp.textg            = Algoritmo de b\u00fasqueda:
artemis.biblioteca.strings.kmp.texth            = A diferencia de los algoritmos ingenuos, donde deslizamos el patr\u00f3n uno por uno y comparamos todos los caracteres en cada movimientos, usamos un valor de lps[] para decidir los nuevos caracteres que ser\u00e1n cotejados, la idea es no cotejar un car\u00e1cter que sabemos que va a aparecer.
artemis.biblioteca.strings.kmp.texti            = \u00bfC\u00f3mo usamos lps [] para decidir las siguientes posiciones o n\u00famero de caracteres que ser\u00e1n saltadas?
artemis.biblioteca.strings.kmp.textj            = Comenzamos la comparaci\u00f3n de pat [j] con j=0 con los caracteres de la actual ventana de texto. Seguimos cotejando caracteres de txt[i] y pat [j] y seguimos incrementando i y j mientras pat[j] y txt [i] sigan coincidiendo.
artemis.biblioteca.strings.kmp.textk            = Cuando vemos una no coincidencia, sabemos que los caracteres pat[0\u2026j-1] coinciden con txt[i-j\u2026..i-1] (N\u00f3tese que j inicia en 0 e incrementa solo cuando hay una coincidencia). Tambi\u00e9n sabemos que lps[j-1] est\u00e1 contando los caracteres de pat[o\u2026j-1] que son prefijo propio y sufijo.
artemis.biblioteca.strings.kmp.textl            = De estos puntos podemos concluir que nosotros no necesitaremos cotejar estos lps[j-1] caracteres con txt porque sabemos que de todas formas esos caracteres coincidir\u00e1n.
artemis.biblioteca.strings.manacher.texta       = Dado un string, encuentre el substring m\u00e1s largo que sea pal\u00edndromo.
artemis.biblioteca.strings.manacher.textb       = Si el string dado es \u201cabaaba\u201d la salida deber\u00e1 ser \u201cabaaba\u201d
artemis.biblioteca.strings.manacher.textc       = Vamos a considerar el string \u201cabababa\u201d.
artemis.biblioteca.strings.manacher.textd       = Aqu\u00ed el centro del string es el 4to car\u00e1cter con \u00edndice 3, si cotejamos m\u00e1s caracteres en la izquierda y derecha del centro todos los caracteres coinciden y el string es pal\u00edndromo.
artemis.biblioteca.strings.manacher.texte       = Para encontrar el substring m\u00e1s largo pal\u00edndromo de un string de tama\u00f1o N, una v\u00eda es tomar cada posible 2*N+1 centros (las N posiciones de caracteres, N-1 entre dos caracteres y dos posiciones en los fines de derecha e izquierda), haga que el car\u00e1cter coincida en ambas direcciones en cada 2*N+1 centros y siga rastreando por LPS.
artemis.biblioteca.strings.manacher.textf       = Si el string dado es \u201cabababa\u201d la salida debe ser \u201cabababa\u201d
artemis.biblioteca.strings.manacher.textg       = Si el string dado es \u201cabcbabcbabcba\u201d la salida debe ser \u201cabcbabcba\u201d. 
artemis.biblioteca.strings.rabinkarp.texta      = Dado un texto txt[0...n-1] y un patr\u00f3n pat[0...m-1] busque todas las ocurrencias de pat en txt e impr\u00edmalas, asuma que n es mayor que m.
artemis.biblioteca.strings.rabinkarp.textb      = Como los algoritmos ingenuos, Rabin-Karp tambi\u00e9n desliza el patr\u00f3n uno por uno, pero a diferencia de este, RK coteja el valor hash del patr\u00f3n con el valor hash del actual substring de texto y su los valores hash coinciden entonces solo empieza a cotejar caracteres individuales, entonces RK necesita calcular los valores hash de los siguientes strings.
artemis.biblioteca.strings.rabinkarp.textc      = 1)	El string patr\u00f3n
artemis.biblioteca.strings.rabinkarp.textd      = 2)	Todos los substrings del texto de tama\u00f1o m.
artemis.biblioteca.strings.rabinkarp.texte      = Desde que necesitamos calcular eficientemente los valores hash de todos los substrings de tama\u00f1o m del texto, debemos tener una funci\u00f3n hash la cual tenga la siguiente propiedad.
artemis.biblioteca.strings.rabinkarp.textf      = El hash del siguiente cambio debe ser eficientemente calculable desde el hash actual y el siguiente car\u00e1cter en el texto o podemos decir hashtxt[s+1\u2026.. s+m])= rehash (txt[s+m], hash(txt[s\u2026.s+m-1]) y rehash debe ser una operaci\u00f3n O(1).
artemis.biblioteca.strings.rabinkarp.textg      = La funci\u00f3n hash sugerida por Rabin y Karp calcula un valor entero, el valor entero para  un string es un valor n\u00famero de un string, por ejemplo el n\u00famero si todos los posibles caracteres son de 1 a 10, el valor n\u00famero de \u201c122\u201d seria 122. El n\u00famero de posibles caracteres es mayor que 10 (256 en general) y la longitud el patr\u00f3n puede ser larga. Entonces los valores num\u00e9ricos no pueden ser pr\u00e1cticamente almacenados como un entero. Sin embargo el valor n\u00famero es calculado usando matem\u00e1tica modular para asegurar que los valores hash pueden ser almacenados en una variable entra (puede caber en palabras de memoria). Para hacer rehashing, necesitamos tomar el m\u00e1s significante digito y a\u00f1adirlo nuestro nuevo digito significante para el valor hash, el rehashing se realiza con la siguiente formula
artemis.biblioteca.strings.rabinkarp.texth      = -	hash( txt[s+1 .. s+m] ) = ( d ( hash( txt[s .. s+m-1]) \u2013 txt[s]*h ) + txt[s + m] ) mod q
artemis.biblioteca.strings.rabinkarp.texti      = -	hash( txt[s .. s+m-1] ) :  Valor hash en cambio s.
artemis.biblioteca.strings.rabinkarp.textj      = -	hash( txt[s+1 .. s+m] ) : Valor has en nuevo cambio ( cambio s+1)
artemis.biblioteca.strings.rabinkarp.textk      = -	d:N\u00famero de caracteres en el alfabeto
artemis.biblioteca.strings.rabinkarp.textl      = -	q: Un n\u00famero primo
artemis.biblioteca.strings.rabinkarp.textm      = -	h: d^(m-1)
artemis.biblioteca.strings.rabinkarp.textn      = Esto es matem\u00e1tica simple, calculamos el valor decimal de la actual ventana desde la ventana anterior.
artemis.biblioteca.strings.rabinkarp.texto      = Por ejemplo el tama\u00f1o del patr\u00f3n es 3 y el string es \u201c23456\u201d Se calcula el valor de la primera ventana el cual es 234 (String ventana es \u201c234\u201d). \u00bfC\u00f3mo puedes calcular el valor de la siguiente ventana \u201c345\u201d? se puede hacer (234 \u2013 2*100)*10 + 5 y obtener 345.
artemis.biblioteca.strings.rabinkarp.textp      = El promedio y mejor tiempo de ejecuci\u00f3n en un caso de RK es de O(n+m) pero su peor caso es O(nm). El peor caso de Rabin-Karp ocurre cuando todos los caracteres del patr\u00f3n y el texto tienen los mismos valores hash de todos los substrings de txt, por ejemplo pat[]=\u201dAAA\u201d  y txt[]=\u201dAAAAAAA\u201d.
artemis.biblioteca.strings.wildcard.texta       = Dado un texto y un patr\u00f3n de wildcards, se debe implementar un algoritmo que encuentre si el patr\u00f3n wildcard concuerda con el texto, el cotejamiento debe cubrir todo el texto.
artemis.biblioteca.strings.wildcard.textb       = El patr\u00f3n wildcard puede incluir los caracteres \u2018?\u2019 y \u2018*\u2019:
artemis.biblioteca.strings.wildcard.textc       = \u2018?\u2019 \u2013 Coteja cualquier car\u00e1cter solitario.
artemis.biblioteca.strings.wildcard.textd       = \u2018*\u2019 \u2013 Coteja cualquier secuencia de caracteres (Incluyendo una secuencia vac\u00eda).
artemis.biblioteca.strings.wildcard.texte       = Cada ocurrencia de \u2018?\u2019 en el patr\u00f3n wildcard puede ser reemplazado con cualquier otro car\u00e1cter y cada ocurrencia de \u2018*\u2019 con una secuencia de caracteres tales que el patr\u00f3n de wildcard se convierta en id\u00e9ntico al string de entrada luego del reemplazo.
artemis.biblioteca.strings.wildcard.textf       = Consideremos cualquier car\u00e1cter en el patr\u00f3n.
artemis.biblioteca.strings.wildcard.textg       = Caso 1: El car\u00e1cter es \u2018*\u2019
artemis.biblioteca.strings.wildcard.texth       = Aqu\u00ed dos cosas pueden pasar:
artemis.biblioteca.strings.wildcard.texti       = -	Podemos ignorar el car\u00e1cter \u2018*\u2019 y movernos al siguiente car\u00e1cter del patr\u00f3n.
artemis.biblioteca.strings.wildcard.textj       = -	El car\u00e1cter \u2018*\u2019 coincide con uno o m\u00e1s caracteres en el texto, aqu\u00ed podemos movernos al car\u00e1cter siguiente en el string.
artemis.biblioteca.strings.wildcard.textk       = Caso 2: El car\u00e1cter es \u2018?\u2019:
artemis.biblioteca.strings.wildcard.textl       = Podemos ignorar el actual car\u00e1cter en el texto y movernos al siguiente car\u00e1cter en el patr\u00f3n y texto.
artemis.biblioteca.strings.wildcard.textm       = Caso 3: El car\u00e1cter no es un car\u00e1cter wildcard
artemis.biblioteca.strings.wildcard.textn       = Si el car\u00e1cter actual en el texto coincide con el actual car\u00e1cter en el patr\u00f3n, podemos movernos al siguiente car\u00e1cter en el patr\u00f3n y el texto, si no concuerdan, el patr\u00f3n wildcard y el texto.
artemis.biblioteca.strings.wildcard.texto       = La complejidad de tiempo es O(m x n) 

# biblioteca - matem\u00e1tica
artemis.biblioteca.math.gcdlcm.texta                =  El m\u00e1ximo com\u00fan divisor (MCD) de dos o m\u00e1s n\u00famero natural o enteros (no n\u00fameros con decimales) es el n\u00famero m\u00e1s grande que les divide.
artemis.biblioteca.math.gcdlcm.textb                = El m\u00ednimo com\u00fan m\u00faltiplo de dos n\u00fameros a y b es el n\u00famero m\u00e1s peque\u00f1o que es m\u00faltiplo de a y m\u00faltiplo de b.
artemis.biblioteca.math.primalitytest.texta         = Un n\u00famero primo es un n\u00famero natural mayor que 1 que tiene \u00fanicamente dos divisores distintos: \u00e9l mismo y el 1. Por el contrario, los n\u00fameros compuestos son los n\u00fameros naturales que tienen alg\u00fan divisor natural aparte de s\u00ed mismos y del 1, y, por lo tanto, pueden factorizarse. El n\u00famero 1, por convenio, no se considera ni primo ni compuesto.
artemis.biblioteca.math.primalitytest.textb         = La propiedad de ser n\u00famero primo se denomina primalidad. El estudio de los n\u00fameros primos es una parte importante de la teor\u00eda de n\u00fameros, rama de las matem\u00e1ticas que trata las propiedades, b\u00e1sicamente aritm\u00e9ticas, de los n\u00fameros enteros.
artemis.biblioteca.math.primalitytest.textc         = El teorema fundamental de la aritm\u00e9tica establece que todo n\u00famero natural tiene una representaci\u00f3n \u00fanica como producto de factores primos, salvo el orden. Un mismo factor primo puede aparecer varias veces. El 1 se representa entonces como un producto vac\u00edo.
artemis.biblioteca.math.primefactors.texta          = Los factores primos de un n\u00famero entero son los n\u00fameros primos divisores exactos de ese n\u00famero entero. El proceso de b\u00fasqueda de esos divisores se denomina factorizaci\u00f3n de enteros, o factorizaci\u00f3n en n\u00fameros primos.
artemis.biblioteca.math.primefactors.textb          = Determinar el n\u00famero de factores primos de un n\u00famero es un ejemplo de problema matem\u00e1tico frecuentemente empleado para asegurar la seguridad de los sistemas criptogr\u00e1ficos: se cree que este problema requiere un tiempo superior al tiempo polin\u00f3mico en el n\u00famero de d\u00edgitos implicados; de hecho, es relativamente sencillo construir un problema que precisar\u00eda m\u00e1s tiempo que la Edad del Universo si se intentase calcular con los ordenadores actuales utilizando algoritmos actuales.
artemis.biblioteca.math.divisibility.texta          = Los criterios de divisibilidad son reglas que sirven para saber si un n\u00famero es divisible por otro sin necesidad de realizar la divisi\u00f3n.
artemis.biblioteca.math.divisibility.textb          = Estas son las reglas m\u00e1s comunes:
artemis.biblioteca.math.divisibility.textc          = DIVISIBILIDAD POR 2: Un n\u00famero es divisible por dos si termina en cero o en cifra par.
artemis.biblioteca.math.divisibility.textd          = -	24 es divisible por 2 porque es par.
artemis.biblioteca.math.divisibility.texte          = -	31 no es divisible por 2 porque no es par.
artemis.biblioteca.math.divisibility.textf          = DIVISIBILIDAD POR 3: Un n\u00famero es divisible por tres, si la suma de sus cifras es m\u00faltiplo de tres.
artemis.biblioteca.math.divisibility.textg          = -	42 es divisible por 3 porque 4 + 2 = 6 es m\u00faltiplo de tres.
artemis.biblioteca.math.divisibility.texth          = -	43 no es divisible por 3 porque 4 + 3 = 7 que no es m\u00faltiplo de tres.
artemis.biblioteca.math.divisibility.texti          = DIVISIBILIDAD POR 5: Un n\u00famero es divisible por cinco cuando acaba en cero o en cinco.
artemis.biblioteca.math.divisibility.textj          = -	35 es divisible por 5 porque acaba en cinco.
artemis.biblioteca.math.divisibility.textk          = -	540 es m\u00faltiplo de 5 porque acaba en cero.
artemis.biblioteca.math.divisibility.textl          = DIVISIBILIDAD POR 9: Un n\u00famero es divisible por nueve cuando la suma de sus cifras es m\u00faltiplo de nueve.
artemis.biblioteca.math.divisibility.textm          = -	45 es divisible por 9 porque la suma de sus cifras es m\u00faltiplo de 9 (4 + 5 = 9)
artemis.biblioteca.math.divisibility.textn          = -	738 es m\u00faltiplo de 9 porque 7 + 3 + 8 = 18, que es m\u00faltiplo de 9.
artemis.biblioteca.math.divisibility.texto          = DIVISIBILIDAD POR 10: Un n\u00famero es divisible por 10 si termina en cero. De manera similar, si termina en 00 es divisible por 100; si termina en 000 es divisible por 1000.
artemis.biblioteca.math.divisibility.textp          = -	El n\u00famero 70 es divisible por 10 porque termina en cero
artemis.biblioteca.math.divisors.texta              = Los divisores de un n\u00famero son aquellos valores que dividen al n\u00famero en partes exactas. As\u00ed, dado un n\u00famero a, si la divisi\u00f3n a/b es exacta (el resto es cero), entonces se dice que b es divisor de a. Tambi\u00e9n se puede decir que a es divisible por b o que a es un m\u00faltiplo de b. Esto nos resulta \u00fatil, por ejemplo, a la hora de agrupar una cantidad de objetos en partes iguales sin que nos sobre ninguno.
artemis.biblioteca.math.divisors.textb              = L\u00f3gicamente, el 1 siempre es divisor de cualquier n\u00famero, porque siempre podemos hacer paquetes individuales y no nos sobrar\u00e1 ninguno. De igual forma, todo n\u00famero es divisible por s\u00ed mismo, lo que equivaldr\u00eda a hacer un \u00fanico paquete.
artemis.biblioteca.math.eratostenes.texta           = Criba de Erat\u00f3stenes es un algoritmo que permite hallar todos los n\u00fameros primos menores que un n\u00famero natural dado n. Se forma una tabla con todos los n\u00fameros naturales comprendidos entre 2 y n, y se van tachando los n\u00fameros que no son primos de la siguiente manera: 
artemis.biblioteca.math.eratostenes.textb           = Comenzando por el 2, se tachan todos sus m\u00faltiplos; comenzando de nuevo, cuando se encuentra un n\u00famero entero que no ha sido tachado, ese n\u00famero es declarado primo, y se procede a tachar todos sus m\u00faltiplos, as\u00ed sucesivamente. El proceso termina cuando el cuadrado del siguiente n\u00famero confirmado como primo es mayor que n.
artemis.biblioteca.math.fibonacci.texta             = La sucesi\u00f3n o serie de Fibonacci es la siguiente sucesi\u00f3n infinita de n\u00fameros naturales: 0 1 1 2 3 58 21 34 55 89....
artemis.biblioteca.math.fibonacci.textb             = La sucesi\u00f3n comienza con los n\u00fameros 0 y 1, y a partir de estos, cada t\u00e9rmino es la suma de los dos anteriores.
artemis.biblioteca.math.fibonacci.textc             = Los n\u00fameros de esta sucesi\u00f3n pueden llegar a ser muy grandes y calcular su \u00faltimo digito se hace complicado en m\u00e1quinas.
artemis.biblioteca.math.permutaciones.texta         = Una permutaci\u00f3n es la variaci\u00f3n del orden o posici\u00f3n de los elementos de un conjunto ordenado o una tupla.
artemis.biblioteca.math.permutaciones.textb         = Si el orden no importa, es una combinaci\u00f3n.
artemis.biblioteca.math.permutaciones.textc         = Si el orden s\u00ed importa es una permutaci\u00f3n.
artemis.biblioteca.math.combinaciones.texta         = La Combinatoria es la parte de las Matem\u00e1ticas que estudia las diversas formas de realizar agrupaciones con los elementos de un conjunto, form\u00e1ndolas y calculando su n\u00famero.
artemis.biblioteca.math.combinaciones.textb         = Existen distintas formas de realizar estas agrupaciones, seg\u00fan se repitan los elementos o no, seg\u00fan se puedan tomar todos los elementos de que disponemos o no y si influye o no el orden de colocaci\u00f3n de los elementos.
artemis.biblioteca.math.allsubsets.texta            = Un conjunto es una colecci\u00f3n de elementos con caracter\u00edsticas similares considerada en s\u00ed misma como un objeto. Los elementos de un conjunto, pueden ser las siguientes: personas, n\u00fameros, colores, letras, figuras, etc.
artemis.biblioteca.math.allsubsets.textb            = Se dice que un elemento (o miembro) pertenece al conjunto si est\u00e1 definido como incluido de alg\u00fan modo dentro de \u00e9l.
artemis.biblioteca.math.hanoi.texta                 = Las Torres de Han\u00f3i es un rompecabezas o juego matem\u00e1tico inventado en 1883 por el matem\u00e1tico franc\u00e9s \u00c9douard Lucas. Este juego de mesa individual consiste en un n\u00famero de discos perforados de radio creciente que se apilan insert\u00e1ndose en uno de los tres postes fijados a un tablero. El objetivo del juego es trasladar la pila a otro de los postes siguiendo ciertas reglas, como que no se puede colocar un disco m\u00e1s grande encima de un disco m\u00e1s peque\u00f1o. El problema es muy conocido en la ciencia de la computaci\u00f3n y aparece en muchos libros de texto como introducci\u00f3n a la teor\u00eda de algoritmos.
artemis.biblioteca.math.hanoi.textb                 = La f\u00f3rmula para encontrar el n\u00famero de movimientos necesarios para transferir n discos desde un poste a otro es: 2n - 1
artemis.biblioteca.math.axbyn.texta                 = Dado a, b y n. Encuentre x y y  que satisfaga ax+by=n, imprima cualquiera de  las x y y que cumplan la ecuaci\u00f3n.
artemis.biblioteca.math.axbyn.textb                 = Podemos verificar si alguna soluci\u00f3n existe o no usando ecuaciones lineales de Diofanes, pero ah\u00ed necesitamos encontrar para esta ecuaci\u00f3n, entonces podemos simplemente iterar por todos los posibles valores de 0 a n sin exceder n para esta ecuaci\u00f3n. Entonces resolviendo esta ecuaci\u00f3n con l\u00e1piz y papel obtenemos y=(n-ax)/b y similarmente obtenemos el otro n\u00famero con x=(n-by)/a, si ninguno de los valores satisface la ecuaci\u00f3n, al final imprimimos \u201cSin soluci\u00f3n\u201d.
artemis.biblioteca.math.axb.texta                   = Dados dos n\u00fameros a y b, encontrar todos los x que permitan a%x=b.
artemis.biblioteca.math.axb.textb                   = Existen tres casos:
artemis.biblioteca.math.axb.textc                   = -	Si  a es menor que b entonces no habr\u00e1 respuesta.
artemis.biblioteca.math.axb.textd                   = -	Si a es igual que b entonces todos los n\u00fameros m\u00e1s grandes que a, habr\u00e1 infinitas soluciones.
artemis.biblioteca.math.axb.texte                   = -	Si a es mayor que b, supone que x es una respuesta a nuestra ecuaci\u00f3n. Entonces x divide (a-b) tambi\u00e9n desde a%x=b entonces b es menor que x
artemis.biblioteca.math.factorial.texta             = El factorial de un entero positivo n, el factorial de n o n factorial se define en principio como el producto de todos los n\u00fameros enteros positivos desde 1 (es decir, los n\u00fameros naturales) hasta n.
artemis.biblioteca.math.factorial.textb             = La operaci\u00f3n de factorial aparece en muchas \u00e1reas de las matem\u00e1ticas, particularmente en combinatoria y an\u00e1lisis matem\u00e1tico. De manera fundamental la factorial de n representa el n\u00famero de formas distintas de ordenar n objetos distintos (elementos sin repetici\u00f3n).
artemis.biblioteca.math.binomial.texta              = Los coeficientes binomiales, n\u00fameros combinatorios o combinaciones son n\u00fameros estudiados en combinatoria que corresponden al n\u00famero de formas en que se puede extraer subconjuntos a partir de un conjunto dado.
artemis.biblioteca.math.binomial.textb              = Se tiene un conjunto con seis objetos diferentes {A, B, C, D, E, F}, de los cuales se desea escoger dos (sin importar el orden de elecci\u00f3n). Existen 15 formas de efectuar tal elecci\u00f3n:
artemis.biblioteca.math.cassini.texta               = La identidad de Cassini y la identidad de Catalan son relaciones matem\u00e1ticas ligadas con los n\u00fameros de la sucesi\u00f3n de Fibonacci, afirma que para cada n\u00famero n-\u00e9simo de la sucesi\u00f3n de Fibonacci, se cumple que:
artemis.biblioteca.math.cassini.textb               = -	Fn-1 x Fn+1-F^2n=(-1)^n
artemis.biblioteca.math.epowx.texta                 =  El valor de la funci\u00f3n exponencial e^x puede ser expresado usando la siguiente serie de Taylor:
artemis.biblioteca.math.epowx.textb                 = -	e^x = 1 + x/1! + x^2/2! + x^3/3! + ...... 
artemis.biblioteca.math.epowx.textc                 =  \u00bfC\u00f3mo calcular eficientemente la suma de la serie de arriba? Puede ser escrita de la siguiente forma:
artemis.biblioteca.math.epowx.textd                 =  -	e^x = 1 + (x/1) (1 + (x/2) (1 + (x/3) (........)))
artemis.biblioteca.math.euclideuler.texta           = De acuerdo con el teorema de Euclides-Euler, un n\u00famero perfecto el cual es par, puede ser representado de la forma (2^n - 1)*(2^n / 2))) donde n es un n\u00famero primo y 2^n \u2013 1 es un n\u00famero primo de Mersenne. Este es un producto de la potencia de 2 con un primo Mersenne, este teorema establece una conexi\u00f3n entre un n\u00famero primo de Mersenne y un n\u00famero par primo perfecto. 
artemis.biblioteca.math.euclideuler.textb           = Algunos ejemplos de n\u00fameros perfectos los cuales satisfacen este teorema son:
artemis.biblioteca.math.euclideuler.textc           = -	6, 28, 496, 8128, 33550336, 8589869056, 137438691328
artemis.biblioteca.math.euclideuler.textd           = Explicaci\u00f3n:
artemis.biblioteca.math.euclideuler.texte           = -	 6 es un n\u00famero perfecto par.
artemis.biblioteca.math.euclideuler.textf           = Entonces puede ser escrito de la forma 
artemis.biblioteca.math.euclideuler.textg           = -	(22 - 1) * (2(2 - 1)) = 6
artemis.biblioteca.math.euclideuler.texth           = Donde n =2 es un n\u00famero primo y 2^n -1=3 es un n\u00famero primo de Mersenne
artemis.biblioteca.math.euclideuler.texti           = Toma cada n\u00famero primo y forma un primo de Mersenne con \u00e9l. El primo de Mersenne = 2^n \u2013 1 donde n es primo. Ahora formamos el n\u00famero (2^n \u2013 1)*(2^(n \u2013 1)) y verificamos si es par y perfecto.
artemis.biblioteca.math.euclidean.texta             = El MCD de dos n\u00fameros es el n\u00famero m\u00e1s grande que divide ambos. Una forma simple de encontrar este n\u00famero es factoriar ambos n\u00fameros y multiplicar los factores comunes.
artemis.biblioteca.math.euclidean.textb             = El algoritmo se basa en lo siguiente:
artemis.biblioteca.math.euclidean.textc             = -	Si restamos el n\u00famero m\u00e1s peque\u00f1o del m\u00e1s grande, MCD (GCD) no cambia, entonces si seguimos restando repetidamente el m\u00e1s grande dos, terminamos con MCD.
artemis.biblioteca.math.euclidean.textd             = -	Ahora en vez de restar, si dividimos el n\u00famero m\u00e1s peque\u00f1o, el algoritmo termina cuando encontramos residuo 0.
artemis.biblioteca.math.euclidean.texte             = La complejidad de tiempo es: O (Log min(a, b))
artemis.biblioteca.math.eulertotient.texta          = La funci\u00f3n totient de Euler para una entrada n es un conteo de n\u00fameros desde 1 hasta n que con primos relativos con n, por ejemplo, los n\u00fameros cuyo GCD (M\u00e1ximo com\u00fan divisor) con n es 1.
artemis.biblioteca.math.eulertotient.textb          = El criptosistema RSA es basado en este teorema.
artemis.biblioteca.math.numberdigits.texta          = Dado un entero n, encuentre el n\u00famero de d\u00edgitos que aparecen en este factorial, donde factorial es definido como, factorial(n) =1*2*3*4\u2026\u2026..*n y factorial (0) = 1\u2026\u2026\u2026\u2026
artemis.biblioteca.math.numberdigits.textb          = Una soluci\u00f3n ingenua puede ser calcular n! primero y luego calcular el n\u00famero de d\u00edgitos presentes en el, sin embargo el valor de n! poder ser muy largo. Se vuelve algo complicado de almacenar esta variable (A menos que est\u00e9s trabajando en Python).
artemis.biblioteca.math.numberdigits.textc          = Una mejor soluci\u00f3n puede ser usar las \u00fatiles propiedades de los logaritmos para calcular la respuesta.
artemis.biblioteca.math.numberdigits.textd          = Sabemos que:
artemis.biblioteca.math.numberdigits.texte          = -	log(a*b) = log(a) + log(b)
artemis.biblioteca.math.numberdigits.textf          = Por lo tanto:
artemis.biblioteca.math.numberdigits.textg          = -	log ( n!) = log (1*2*3....... * n)     = log (1) + log (2) +........ +log(n)
artemis.biblioteca.math.numberdigits.texth          = Ahora, observamos que el valor piso del logaritmo base 10 incrementado 1 de cualquier n\u00famero da el n\u00famero de d\u00edgitos presentes en ese n\u00famero.
artemis.biblioteca.math.numberdigits.texti          = Entonces la salida puede ser: floor (log(n!)) + 1.
artemis.biblioteca.math.numberdigitskame.texta      = Si la soluci\u00f3n anterior no es lo suficientemente r\u00e1pida, podemos usar la f\u00f3rmula de Kamenetsky para obtener la respuesta.
artemis.biblioteca.math.numberdigitskame.texta      = Se aproxima al n\u00famero de d\u00edgitos en una factorial con:
artemis.biblioteca.math.numberdigitskame.texta      = -	f(x) =    log10( ((n/e)^n) * sqrt(2*pi*n))
artemis.biblioteca.math.numberdigitskame.texta      = Adem\u00e1s podemos f\u00e1cilmente usar las propiedades de los logaritmos para obtener:
artemis.biblioteca.math.numberdigitskame.texta      = -	f(x) = n* log10(( n/ e)) + log10(2*pi*n)/2 
artemis.biblioteca.math.numberdigitskame.texta      = Esta soluci\u00f3n puede manejar n\u00famero muy grandes de entrada, que pueden caber en un entero de 32 bits, e incluso m\u00e1s que esto.
artemis.biblioteca.math.fermatlittle.texta          = El peque\u00f1o teorema de Fermat dice que si p es un n\u00famero primo, entonces para cualquier entero a, el n\u00famero de p-a es un entero m\u00faltiplo de p.
artemis.biblioteca.math.fermatlittle.textb          = Aqu\u00ed p es un n\u00famero primo:
artemis.biblioteca.math.fermatlittle.textc          = -	a^p \u2261 a (mod p).
artemis.biblioteca.math.fermatlittle.textd          = Caso especial: si a no es divisible por p, el peque\u00f1o teorema de Fermat es equivalente a la sentencia que un p-1-1 es un entero m\u00faltiplo de p.
artemis.biblioteca.math.fermatlittle.texte          = -	a^p-1 \u2261 1 (mod p)
artemis.biblioteca.math.fermatlittle.textf          = O
artemis.biblioteca.math.fermatlittle.textg          = -	a^p-1 % p = 1  Aqu\u00ed a no es divisible por p.
artemis.biblioteca.math.fermatlittle.texth          = Usos del peque\u00f1o teorema de Fermat
artemis.biblioteca.math.fermatlittle.texti          = Si sabemos que m es primo, entones podemos tambi\u00e9n usar el peque\u00f1o teorema de Fermat para buscar la inversa:
artemis.biblioteca.math.fermatlittle.textj          = -	a^m-1 \u2261 1 (mod m)
artemis.biblioteca.math.fermatlittle.textk          = Si nosotros multiplicamos ambos saldos con a-1, obtenemos:
artemis.biblioteca.math.fermatlittle.textl          = -	a^-1 \u2261 a m-2 (mod m)
artemis.biblioteca.math.goldenratio.texta           = Existen diferentes m\u00e9todos para encontrar el en\u00e9simo n\u00famero de Fibonacci, una simple manera de encontrarlo es usando el ratio dorado.
artemis.biblioteca.math.goldenratio.textb           = Golden ratio (Ratio dorado):
artemis.biblioteca.math.goldenratio.textc           = \u03c6=(1+\u221a5)/2=1.6180339887\u2026
artemis.biblioteca.math.goldenratio.texte           = Golden ratio nos puede dar una respuesta incorrecta.
artemis.biblioteca.math.goldenratio.textf           = Podemos obtener la respuesta correcta si redondeamos hacia arriba el resultado de cada punto.
artemis.biblioteca.math.goldenratio.textg           = Este m\u00e9todo puede calcular los primeros 34 n\u00fameros de Fibonacci correctamente, luego de esto puede haber diferencia con el valor correcto.
artemis.biblioteca.math.floatgcd.texta              = Una aproximaci\u00f3n simple para realizar GCD a n\u00fameros flotantes es:
artemis.biblioteca.math.floatgcd.textc              = -	a=1.20 
artemis.biblioteca.math.floatgcd.textb              = -	b=22.5
artemis.biblioteca.math.floatgcd.textd              = Expresando cada uno de los n\u00fameros sin decimales como el producto de los primos obtenemos:
artemis.biblioteca.math.floatgcd.texte              = -	120=2^3*3*5
artemis.biblioteca.math.floatgcd.textf              = -	2250=2*3^2*5^3
artemis.biblioteca.math.floatgcd.textg              = GCD de 120 y 2250 = 2*3*5=30
artemis.biblioteca.math.floatgcd.texth              = Por lo tanto, el GCD de 1.20 y 22.5=0.30 (Tomando 2 d\u00edgitos decimales).
artemis.biblioteca.math.floatgcd.texti              = Podemos hacer esto usando el algoritmo de Euclides, Este algoritmo indica si el n\u00famero m\u00e1s peque\u00f1o es restado del n\u00famero m\u00e1s largo, el GCD de dos n\u00fameros no cambia.
artemis.biblioteca.math.fractionsprod.texta         = Dados el numerador y el denominador de N fracciones, la tarea es encontrar el producto de N fracciones e imprimir la respuesta en forma reducida.
artemis.biblioteca.math.fractionsprod.textb         = La idea es encontrar el producto de numeradores en una variable, como new_num, ahora encontrar el producto de los denominadores en otra variable como new_den. 
artemis.biblioteca.math.fractionsprod.textc         = Ahora para encontrar la respuesta en forma reducida, encontr\u00e9 el GCD de new_num y new_den y dividir el new_num y new_den por el GCD calculado.
artemis.biblioteca.math.fractionsprod.textd         = La soluci\u00f3n causa desbordamiento para n\u00fameros grandes, podemos evadir esto si encontramos los factores primos de todos los numeradores y denominadores, una vez hayamos encontrado los factores, podemos cancelar los factores primos comunes.
artemis.biblioteca.math.fractionsprod.texte         = Cuando se solicita representar la respuesta de la forma {P \veces {Q} ^ {-1}} .Primero convierta el numerador  y el denominador en forma reducible de P/Q. luego busque el multiplicativo inverso de Q con respecto a un n\u00famero primo m (Generalmente 10^9 + 7) el cual es dado como pregunta, luego de encontrar el multiplicativo inverso de Q, multiplicarlo con P y tomar el modulo con el n\u00famero primo m,  el cual nos da nuestra salida requerida.
artemis.biblioteca.math.jhosephus.texta             = En las ciencias de la computaci\u00f3n y las matem\u00e1ticas, el problema Josephus ( O permutaci\u00f3n Josephus) es un problema teor\u00e9tico el cual su enunciado es el siguiente.
artemis.biblioteca.math.jhosephus.textb             = Hay n personas sentadas en c\u00edrculo, esperando a ser ejecutadas. El conteo empieza en el mismo punto en el c\u00edrculo y procede alrededor del c\u00edrculo en direcci\u00f3n horaria, en cada paso un cierto n\u00famero de personas son saltadas y la siguiente persona es ejecutada. La eliminaci\u00f3n se realiza alrededor del circulo (el comienza a ser m\u00e1s peque\u00f1o y peque\u00f1o mientras la gente es ejecutada y removida), hasta que solo quede una persona, a quien se le dar\u00e1 la libertad. Dado el total de personas n y un n\u00famero k que indica que k-1 personas ser\u00e1n saltadas y la kesima persona es asesinada en el c\u00edrculo, la tarea es escoger el lugar en el c\u00edrculo inicial de tal forma que sea la posici\u00f3n de la \u00faltima persona que sobreviva.
artemis.biblioteca.math.jhosephus.textc             = Por ejemplo, si n =5 y k = 2, entonces la posici\u00f3n segura es 3. Primeramente la persona en la posici\u00f3n 2 es asesinada, luego la persona en la posici\u00f3n 4 es asesinada, luego la persona en la posici\u00f3n 1 es asesinada, finalmente la persona en la posici\u00f3n 5 es asesinada dejando a la persona en la 4 posici\u00f3n viva y con capacidad de disfrutar su libertad.
artemis.biblioteca.math.jhosephus.textd             = Si n=7 y k=3, entonces la posici\u00f3n segura es 4, las personas en las posiciones 3,6,2,7,5,1 son asesinadas en ese orden y la 4 sobrevive.
artemis.biblioteca.math.cardinalordinal.texta       = Cuando usamos los n\u00fameros naturales para contar los elementos de un determinado conjunto los llamamos n\u00fameros cardinales.  Imagina que tienes un conjunto de galletas como el que se muestra en la imagen de abajo.  Si realizas el proceso de contar encontrar\u00e1s que hay ocho galletas en total.  Decimos entonces que el cardinal del conjunto es ocho, ya que este n\u00famero representa la cantidad de elementos que tiene el conjunto.
artemis.biblioteca.math.cardinalordinal.textb       = En muchas ocasiones es necesario dar un orden a las cosas: las posiciones finales de una carrera o los pisos de un edificio son algunos ejemplos.  Cuando usamos los n\u00fameros naturales para este ordenar los llamamos ordinales.
artemis.biblioteca.math.cardinalordinal.textc       = Para representar los n\u00fameros ordinales usamos los n\u00fameros naturales acompa\u00f1ados por una peque\u00f1a letra as\u00ed: 1\u00b0a, 2\u00b0o  etc.  Cuando acompa\u00f1amos el n\u00famero por la letra a es para femenino, y con la letra o es para masculino.  As\u00ed, si queremos decir que Anita es la n\u00famero uno de la clase decimos que es la primera: 1\u00b0a; y si queremos decir que Pablo ocup\u00f3 el lugar n\u00famero uno en la carrera decimos que fue el primero: 1\u00b0o
artemis.biblioteca.math.roman.texta                 = La numeraci\u00f3n romana es un sistema de numeraci\u00f3n que se desarroll\u00f3 en la Antigua Roma y se utiliz\u00f3 en todo el Imperio romano, manteni\u00e9ndose con posterioridad a su desaparici\u00f3n y todav\u00eda utilizado en algunos \u00e1mbitos.
artemis.biblioteca.math.roman.textb                 = Este sistema emplea algunas letras may\u00fasculas como s\u00edmbolos para representar ciertos valores. Los n\u00fameros se escriben como combinaciones de letras. Por ejemplo, el a\u00f1o 2019 se escribe como MMXIX, donde cada M representa 1000 unidades, la X representa 10 unidades m\u00e1s y IX representa 9 unidades m\u00e1s (al ser X, que representa el 10, precedido por I, que representa el 1).
artemis.biblioteca.math.multiplegcd.texta           = Dado un array de n\u00fameros, encontrar GCD del array de elementos.
artemis.biblioteca.math.multiplegcd.textb           = El GCD de tres o m\u00e1s n\u00fameros es igual que el producto de los factores primos comunes de todos los n\u00fameros, pero puede tambi\u00e9n ser calculado tomando repetidamente el GCD de los pares de n\u00fameros.
artemis.biblioteca.math.hardyramanujan.texta        = El teorema de Hardy Ramanujan propones que el n\u00famero de factores de n debe ser aproximadamente log(log(n)) para la mayor\u00eda de n\u00fameros naturales n.
artemis.biblioteca.math.hardyramanujan.textb        = -	5192 tiene 2 factores primos distintos y log(log(5192)) = 2.1615
artemis.biblioteca.math.hardyramanujan.textc        = -	51242183 tiene 3 factores primos distintos y log(log(51242183)) = 2.8765
artemis.biblioteca.math.hardyramanujan.textd        = Este teorema es principalmente usado en algoritmos de aproximaci\u00f3n y es prueba l\u00edder para conceptos m\u00e1s grandes de teor\u00eda de la probabilidad 
artemis.biblioteca.math.hoax.texta                  = Dado un n\u00famero n, verificar si es un n\u00famero falso o no.
artemis.biblioteca.math.hoax.textb                  = Un n\u00famero falso es definido como un n\u00famero compuesto, cuya suma de d\u00edgitos es igual a la suma de d\u00edgitos de sus distintos factores primos, 1 no es considerado un n\u00famero primo, entonces no es incluido en la suma de d\u00edgitos de los distintos factores primos.
artemis.biblioteca.math.hoax.textc                  = La definici\u00f3n de un n\u00famero falso est\u00e1 cerca de la de la definici\u00f3n de un n\u00famero de Smith, algunos de los n\u00fameros falsos son tambi\u00e9n n\u00fameros de Smith, es aparente que estos n\u00fameros falsos no tienen factores repetidos en su descomposici\u00f3n de primos.
artemis.biblioteca.math.hoax.textd                  = Implementaci\u00f3n
artemis.biblioteca.math.hoax.texte                  = 1)	Primero generamos todos los distintos factores primos del n\u00famero n.
artemis.biblioteca.math.hoax.textf                  = 2)	Si el n no es un n\u00famero primo, encuentre la suma de d\u00edgitos de los factores obtenidos en el paso 1
artemis.biblioteca.math.hoax.textg                  = 3)	Encuentre la suma de d\u00edgitos de n
artemis.biblioteca.math.hoax.texth                  = 4)	Verifique si la suma obtenida en  2 y 3 son iguales o no.
artemis.biblioteca.math.hoax.texti                  = 5)	Si las sumas son iguales, entonces n es un n\u00famero falso.
artemis.biblioteca.math.largestpow.texta            = Dados dos n\u00fameros, fact y n, encuentre la potencia m\u00e1s grande de n que divide fact! (Factorial de fact).
artemis.biblioteca.math.largestpow.textb            = La idea es basada en la f\u00f3rmula de Legendre la cual encuentra la potencia m\u00e1s grande de un n\u00famero primo que divide fact!. Encontramos todos los factores primos de n. para cada factor primo encontramos la potencia m\u00e1s grande que divide fact! Y finalmente retornamos el m\u00ednimo de todas las potencias encontradas.
artemis.biblioteca.math.largestpow.textc            = Si hay m\u00faltiples potencias de un factor primo presentes en n, entonces dividimos el conteo para obtener el valor de la m\u00e1xima potencia de este factor.
artemis.biblioteca.math.lcmarray.texta              = Dado un array de n n\u00fameros, encontrar el LCM de ellos. 
artemis.biblioteca.math.lcmarray.textb              = La idea es extender nuestra relaci\u00f3n de m\u00e1s de dos n\u00fameros, vamos a decir que tenemos un array arr[] que contiene n elementos de los cuales necesitamos calcular su LCM.
artemis.biblioteca.math.lcmarray.textc              = Los pasos principales del algoritmo son:
artemis.biblioteca.math.lcmarray.textd              = 1)	Inicializa ans = arr[0]
artemis.biblioteca.math.lcmarray.texte              = 2)	Iterar sobre todos los elementos del array, por ejemplo desde i=1 a i= n-1, en la iesima iteraci\u00f3n ans= LCM(arr[0],arr[1],\u2026\u2026., arr[i-1]). Esto puede ser f\u00e1cilmente hecho como LCM(arr[0], arr[1], \u2026., arr[i]) = LCM(ans, arr[i]). Entonces en la iesima iteraci\u00f3n tenemos que hacer ans = LCM(ans, arr[i]) = ans x arr[i] / gcd(ans, arr[i])
artemis.biblioteca.math.leonardo.texta              = Los n\u00fameros de Leonardo son una secuencia de n\u00fameros con la recurrencia:
artemis.biblioteca.math.leonardo.textb              = -	L(0)=0
artemis.biblioteca.math.leonardo.textc              = -	L(1)=1
artemis.biblioteca.math.leonardo.textd              = -	L(n)=L(n-1)+l(n-2)+1 si n>1
artemis.biblioteca.math.leonardo.texte              = Los primeros n\u00fameros de Leonardo son 1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, \u2022\u2022\u2022
artemis.biblioteca.math.leonardo.textf              = Complejidad de tiempo: Exponencial
artemis.biblioteca.math.modularexp.texta            = Dados tres n\u00fameros x, y y p, calcule (x^y) % p.
artemis.biblioteca.math.modularexp.textb            = Bajo esta propiedad fundamental modular  que es usada para computaci\u00f3n eficiente, calcular la potencia usando matem\u00e1tica modular.
artemis.biblioteca.math.modularexp.textc            = -	 (ab) mod p = ( (a mod p) (b mod p) ) mod p 
artemis.biblioteca.math.modularexp.textd            = Por ejemplo  a = 50,  b = 100, p = 13
artemis.biblioteca.math.modularexp.texte            = -	50  mod 13  = 11
artemis.biblioteca.math.modularexp.textf            = -	100 mod 13  = 9
artemis.biblioteca.math.modularexp.textg            = -	(50 * 100) mod 13 = ( (50 mod 13) * (100 mod 13) ) mod 13 
artemis.biblioteca.math.modularexp.texth            = -	or (5000) mod 13 = ( 11 * 9 ) mod 13
artemis.biblioteca.math.modularexp.texti            = -	or 8 = 8
artemis.biblioteca.math.modularexp.textj            = Complejidad de tiempo: O(Log y).
artemis.biblioteca.math.multipleeulertot.texta      = Funci\u00f3n Totient de Euler de una entrada n es el conteo de n\u00fameros  en {1,2,3,..., n} que sea primo relativo a n, por ejemplo, los n\u00fameros los cuales su GCD con n es 1. 
artemis.biblioteca.math.multipleeulertot.textb      = En problemas donde tenemos que llamar a la funci\u00f3n totient muchas veces como 10^5 veces, una soluci\u00f3n simple puede retornar un TLE (time limit exceded). La idea es usar la criba de Erat\u00f3stenes.
artemis.biblioteca.math.multipleeulertot.textc      = Encuentre todos los factores primos con limite en 10^5 usando la criba de Erat\u00f3stenes.
artemis.biblioteca.math.multipleeulertot.texte      = Para realizar este \u03a6(n), se hace lo siguiente.
artemis.biblioteca.math.multipleeulertot.textf      = 1)	Inicializa el resultado como n.
artemis.biblioteca.math.multipleeulertot.textg      = 2)	Itera a trav\u00e9s de todos los primos m\u00e1s peque\u00f1os o iguales que la ra\u00edz cuadrada de n. Dejamos que el actual n\u00famero primo sea p, revisamos si p divide n, si lo hace, removemos todas las ocurrencias de p de n dividi\u00e9ndolo repetidamente por n, tambi\u00e9n reducimos nuestro resultado por n/p.
artemis.biblioteca.math.multipleeulertot.texth      = 3)	Finalmente retornamos nuestro resultado.
artemis.biblioteca.math.naturalcoprime.texta        = Dado N y M, la tarea es encontrar cuales n\u00fameros de 1 a n pueden ser divididos en dos conjuntos los cuales su diferencia absoluta entre la suma de los dos sets es M y el GCD de la suma de los dos sets es 1.
artemis.biblioteca.math.naturalcoprime.textb        = Desde que tenemos 1 a N n\u00fameros, sabemos que la suma de todos los n\u00fameros es N*(N+1)/2. Dejamos S1 y S2 de esta manera:
artemis.biblioteca.math.naturalcoprime.textc        = 1)	sum(S1) + sum(S2) = N * (N + 1) / 2
artemis.biblioteca.math.naturalcoprime.textd        = 2)	sum(S1) \u2013 sum(S2) = M
artemis.biblioteca.math.naturalcoprime.texte        = Resolviendo estas dos ecuaciones podemos dar la suma de ambos conjuntos. Si sum(S1) y sum(S2)  son enteros  y ellos son coprimos (Su GCD es 1), entonces ah\u00ed existe una forma de separar el n\u00famero en dos sets. De otra forma no hay forma de separar esos n\u00fameros N.
artemis.biblioteca.math.naturalcoprime.textf        = Complejidad de tiempo: O(log(n))
artemis.biblioteca.math.zeckendorf.texta            = El teorema de Zeckendorf indica que cada posible entero puede ser escrito como la suma de distintos n\u00fameros de Fibonacci no vecinos. Dos n\u00fameros Fibonacci son vecinos si uno viene luego del otro en la secuencia (0, 1, 1, 2, 3, 5, ..). Por ejemplo 3 y 5 son vecinos pero 2 y 5 no lo son.
artemis.biblioteca.math.zeckendorf.textb            = Dado un n\u00famero, encontrar la representaci\u00f3n del n\u00famero como la suma de n\u00fameros de Fibonacci no consecutivos.
artemis.biblioteca.math.zeckendorf.textc            = 1)	Sea n el n\u00famero de entrada
artemis.biblioteca.math.zeckendorf.textd            = 2)	Mientras n >= 0
artemis.biblioteca.math.zeckendorf.texte            = a)	Encontrar el Fibonacci m\u00e1s grande que sea menor que n. Dejar que este n\u00famero sea \u2018f\u2019, e imprimir f.
artemis.biblioteca.math.zeckendorf.textf            = b)   n = n - f
artemis.biblioteca.math.rosser.texta                = El teorema de Rosser dicta que el nesimo n\u00famero es mayor que el producto de n y el logaritmo natural de n para todos los n mayores a 1.
artemis.biblioteca.math.rosser.textb                = Matem\u00e1ticamente: 
artemis.biblioteca.math.rosser.textc                = Para n >= 1, si pn es el nesimo n\u00famero primo, entonces then:
artemis.biblioteca.math.rosser.textd                = -	pn > n * (ln n)
artemis.biblioteca.math.rosser.texte                = Para n = 1, en\u00e9simo n\u00famero primo = 2
artemis.biblioteca.math.rosser.textf                = -	 2 > 1 * ln(1)
artemis.biblioteca.math.rosser.textg                = Para n = 2, en\u00e9simo n\u00famero primo = 3
artemis.biblioteca.math.rosser.texth                = -	3 > 2 * ln(2)
artemis.biblioteca.math.rosser.texti                = Para n = 3, en\u00e9simo n\u00famero primo = 5
artemis.biblioteca.math.rosser.textj                = -	 5 > 3 * ln(3)
artemis.biblioteca.math.rosser.textk                = Para n = 4, en\u00e9simo n\u00famero primo = 7
artemis.biblioteca.math.rosser.textl                = -	7 > 4 * ln(4)
artemis.biblioteca.math.rosser.textm                = Para n = 5, en\u00e9simo n\u00famero primo = 11
artemis.biblioteca.math.rosser.textn                = -	11 > 5 * ln(5)
artemis.biblioteca.math.rosser.texto                = Para n = 6, en\u00e9simo n\u00famero primo = 13
artemis.biblioteca.math.rosser.textp                = -	13 > 6 * ln(6)
artemis.biblioteca.math.sieveeraop.texta            = La cl\u00e1sica criba de Erat\u00f3stenes toma O(Nlog (logN))  para encontrar todos los n\u00fameros primos  menores a N, este c\u00f3digo es una versi\u00f3n modificada de esta criba que tiene una complejidad de tiempo de O(N).
artemis.biblioteca.math.smith.texta                 = Dado un n\u00famero n, la tarea encontrar si un n\u00famero es n\u00famero de Smith o no, un n\u00famero de Smith es un n\u00famero compuesto cuya suma de d\u00edgitos es igual a la suma de los d\u00edgitos en su factorizaci\u00f3n prima.
artemis.biblioteca.math.smith.textb                 = -	n = 4
artemis.biblioteca.math.smith.textc                 = -	Factorizaci\u00f3n prima = 2, 2  and 2 + 2 = 4
artemis.biblioteca.math.smith.textd                 = -	Por lo tanto, 4 es un n\u00famero de Smith
artemis.biblioteca.math.smith.texte                 = La idea es primero encontrar todos los factores primos por debajo de un l\u00edmite usando la criba de Sundaram. (Esto es \u00fatil para buscar y verificar varios n\u00fameros de Smith). Ahora por cada entrada que ser\u00e1 verificada como n\u00famero de Smith, atravesamos por todos los factores primos en \u00e9l, y encontramos la suma de los d\u00edgitos en cada factor primo. Tambi\u00e9n buscamos la suma de los d\u00edgitos en el n\u00famero dado. Finalmente comparamos las dos sumas, si son lo mismo, retornamos true.
artemis.biblioteca.math.sphenic.texta               = Un n\u00famero esc\u00e9nico es un entero positive el cual es el producto de exactamente tres primos distintos, los primeros n\u00fameros esf\u00e9nicos son 30, 42, 66, 70, 78, 102, 105, 110, 114,\u2026
artemis.biblioteca.math.sphenic.textb               = Dado un n\u00famero n, determine si es un n\u00famero esfenico o no.
artemis.biblioteca.math.sphenic.textc               = Un n\u00famero esfenico puede ser verificado generando los \u00faltimos factores primos de los n\u00fameros hasta n.
artemis.biblioteca.math.sphenic.textd               = Luego podemos simplemente dividir el n\u00famero por sus factores primos y luego ese n\u00famero por sus factores primos, y as\u00ed en Adelante, y luego verificar si el n\u00famero tiene exactamente 3 factores primos distintos.
artemis.biblioteca.math.sphenic.texte               = Complejidad de tiempo: O (nlog(n))
artemis.biblioteca.math.catalan.texta               = En combinatoria, los n\u00fameros de Catalan forman una secuencia de n\u00fameros naturales que aparece en varios problemas de conteo que habitualmente son recursivos. Obtienen su nombre del matem\u00e1tico belga Eug\u00e8ne Charles Catalan (1814\u20131894).
artemis.biblioteca.math.catalan.textb               = El n-\u00e9simo n\u00famero de Catalan se obtiene, aplicando coeficientes binomiales, a partir de la siguiente f\u00f3rmula:
artemis.biblioteca.math.catalan.textc               = Cn=  (2n)!/(n+1)!n!
artemis.biblioteca.math.charmichael.texta           = Un n\u00famero n es un n\u00famero de Carmichael si satisface la siguiente condici\u00f3n aritm\u00e9tica modular:
artemis.biblioteca.math.charmichael.textb           = -	pow(b, n-1) MOD n = 1, 
artemis.biblioteca.math.charmichael.textc           = Para todos los b en rango de 1 a n tal que b y n son relativos primos gcd(b, n) = 1 .
artemis.biblioteca.math.charmichael.textd           = Dado un entero positivo n, encontrar si es un n\u00famero de Carmichael, estos n\u00fameros tienen importancia en el m\u00e9todo de Fermat para el test de primalidad.
artemis.biblioteca.math.sternbrocot.texta           = La secuencia de Stern Brocot es similar la secuencia de Fibonacci, pero es diferente en la forma en que la secuencia es generada.
artemis.biblioteca.math.sternbrocot.textb           = 1)	Primero y segundo elemento de la secuencia es 1 y 1.
artemis.biblioteca.math.sternbrocot.textc           = 2)	Considere el segundo miembro de la secuencia, luego sume el miembro considerado de la secuencia y su predecesor, por ejemplo (1+1=2) ahora 2 es el siguiente elemento de nuestra serie, la secuencia ser\u00e1 [1,1,2].
artemis.biblioteca.math.sternbrocot.textd           = 3)	Despu\u00e9s de este elemento, nuestro siguiente elemento en la secuencia ser\u00e1 considerado el elemento en nuestro segundo paso, ahora la secuencia seria [1,1,2,1].
artemis.biblioteca.math.sternbrocot.texte           = 4)	De nuevo realizamos el paso 2, pero ahora consideramos el elemento 2 (Tercer elemento), entonces nuestro siguiente n\u00famero de la secuencia ser\u00e1 la suma de os n\u00fameros considerados, y su predecesor(2+1=3), la secuencia ahora ser\u00e1 [1,1,2,1,3]
artemis.biblioteca.math.sternbrocot.textf           = 5)	Como en el paso 3, el siguiente elemento ser\u00e1 considerado, por ejemplo 2, la secuencia ser\u00e1 [1,1,2,1,3,2]
artemis.biblioteca.math.sternbrocot.textg           = 6)	El proceso continua, nuestro elemento considerado ser\u00e1 1(Cuarto elemento).
artemis.biblioteca.math.sylvester.texta             = El en sistema num\u00e9rico, La secuencia de Sylvester es una secuencia de enteros la cual cada miembro es un producto de los n\u00fameros previos, m\u00e1s uno, dado un entero positivo N, imprima los primeros N miembros de la secuencia.
artemis.biblioteca.math.sylvester.textb             = Los n\u00fameros pueden ser muy largos, se usa %10^9 + 7.
artemis.biblioteca.math.sylvester.textc             = La idea es correr un ciclo y tomar dos variables, inicializarlos como 1 y 2, uno para almacenar el producto hasta ahora, y el otro para almacenar el n\u00famero actual el cual es el primer n\u00famero +1 y por cada paso, multiplicar ambos usando aritm\u00e9tica modular, por ejemplo (a + b)%N = (a%N + b%N)%N  donde N es un n\u00famero modular.
artemis.biblioteca.math.aliquot.texta               = Dado un n\u00famero n, la tarea es imprimir su secuencia de Aliquot. La secuencia de Aliquot de un n\u00famero empieza con el mismo, t\u00e9rminos restantes de la secuencia son la suma de los divisores propios del t\u00e9rmino inmediatamente anterior.
artemis.biblioteca.math.aliquot.textb               = Por ejemplo, la secuencia de Aliquot de 10, es 10,8,7,1,0. La secuencia puede repetir. Por ejemplo para 6, tenemos una secuencia infinita de todos los 6, En esos casos              imprimimos el n\u00famero repetido y paramos.
artemis.biblioteca.math.aliquot.textc               = -	N\u00fameros los cuales tienen una secuencia de Aliquot repetitiva de longitud 1 son llamados n\u00fameros perfectos. Por ejemplo 6, suma de sus divisores propios es 6.
artemis.biblioteca.math.aliquot.textd               = -	N\u00fameros  que tienen una secuencia de Aliquot repetitiva de tama\u00f1o 2 son llamados n\u00fameros de Amicable. Por ejemplo 220 es un n\u00famero de Amicable.
artemis.biblioteca.math.aliquot.texte               = -	N\u00fameros que tienen secuencia de Aliquot repetitiva de tama\u00f1o 3 son llamados n\u00fameros sociales
artemis.biblioteca.math.aliquot.textf               = Podemos generar la secuencia primero imprimiendo el n\u00famero n y luego calculando los siguientes t\u00e9rminos usando la suma de los divisores propios. Cuando computemos el siguiente termino, verificamos si nosotros ya hab\u00edamos visto ese t\u00e9rmino o no, si el t\u00e9rmino aparece de nuevo tenemos una secuencia repetida, imprimimos el mismo y rompemos el ciclo. 
artemis.biblioteca.math.juggler.texta               = La secuencia de Juggles es una serie de n\u00fameros enteros la cual su primer t\u00e9rmino comienza con un entero positivo y los t\u00e9rminos restantes son generados de los anteriores inmediatos n\u00fameros.
artemis.biblioteca.math.juggler.textb               = La secuencia Juggler comenzando con el n\u00famero 3: 5, 11, 36, 6, 2, 1
artemis.biblioteca.math.juggler.textc               = La secuencia Juggler comenzando desde el n\u00famero 9:  9, 27, 140, 11, 36, 6, 2, 1
artemis.biblioteca.math.juggler.textd               = Dado un n\u00famero n tenemos que imprimir la secuencia Juggler de este n\u00famero como el primer n\u00famero de la secuencia
artemis.biblioteca.math.juggler.texte               = -	Los t\u00e9rminos en la secuencia de Juggler primero crecen hasta un valor pico, y luego empiezan a decrecer.
artemis.biblioteca.math.juggler.textf               = -	El \u00faltimo t\u00e9rmino de la secuencia de Juggler es siempre 1.
artemis.biblioteca.math.mosserdebrujin.texta        = Dado un entero n, imprima los primeros n t\u00e9rminos de la secuencia de Moser de Brujin.
artemis.biblioteca.math.mosserdebrujin.textb        = La secuencia de Moser de Brujin es una secuencia obtenida adicionando las distintas potencias del n\u00famero 4, por ejemplo 1,4,16,6..
artemis.biblioteca.math.mosserdebrujin.textc        = Debe notarse aqu\u00ed que cualquier n\u00famero el cual es la suma de potencias de 4 no distintas no son parte de la secuencia, por ejemplo 8 no es parte de la secuencia debido a que es formado de la suma de no distintas potencias de 4, que son 4 y 4.
artemis.biblioteca.math.mosserdebrujin.textd        = Por lo tanto cualquier n\u00famero el cual no sea una potencia de 4 y est\u00e1 presente en la secuencia debe ser la suma de distintas potencias de 4.
artemis.biblioteca.math.mosserdebrujin.texte        = Por ejemplo, 21 es parte de la secuencia, incluso a trav\u00e9s de que no es una potencia de 4 porque es la suma de distintas potencias de 4, que son 1,4 y 16.
artemis.biblioteca.math.newmanconway.texta          = La secuencia de  Newman-Conway es aquella que genera la siguiente secuencia de enteros:
artemis.biblioteca.math.newmanconway.texta          = 1 1 2 2 3 4 4 4 5 6 7 7\u2026
artemis.biblioteca.math.newmanconway.texta          = En t\u00e9rminos matem\u00e1ticos, la secuencia P(n) de Newman-Conway es definida por la siguiente relaci\u00f3n de recurrencia:
artemis.biblioteca.math.newmanconway.texta          = -	P(n) = P(P(n - 1)) + P(n - P(n - 1)) with seed values P(1) = 1 and P(2) = 1
artemis.biblioteca.math.newmanconway.texta          = Dado un n\u00famero n, imprima el en\u00e9simo n\u00famero de la secuencia Newman-Conway
artemis.biblioteca.math.newmanconway.texta          = Complejidad de tiempo: O(n)
artemis.biblioteca.math.padovan.texta               = La secuencia de Padovan es similar a la secuencia de Fibonacci, con una secuencia recursiva similar cuya f\u00f3rmula es: 
artemis.biblioteca.math.padovan.textb               = -	P(n) = P(n-2) + P(n-3)
artemis.biblioteca.math.padovan.textc               = -	P(0) = P(1) = P(2) = 1 
artemis.biblioteca.math.padovan.textd               = Secuencia Fibonacci: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55\u2026\u2026
artemis.biblioteca.math.padovan.texte               = Espiral de cuadrados con largo de lados los cuales siguen la secuencia de Fibonacci,
artemis.biblioteca.math.padovan.textf               = Secuencia de Padovan: 1, 1, 1, 2, 2, 3, 4, 5, 7, 9, 12, 16, 21, 28, 37,\u2026..
artemis.biblioteca.math.padovan.textg               = Espiral de tri\u00e1ngulos equil\u00e1teros con largos de lado que siguen la secuencia de Padovan.
artemis.biblioteca.math.recaman.texta               = Dado un entero n, imprima los primeros n elementos de la secuencia de Recaman
artemis.biblioteca.math.recaman.textb               = Es b\u00e1sicamente una funci\u00f3n con dominio y co dominio como n\u00fameros naturales y 0, su recursividad se define de la siguiente manera.
artemis.biblioteca.math.recaman.textc               = Espec\u00edficamente, dejamos a(n) denotar el (n+1)simo termino (0 ya est\u00e1 ah\u00ed).
artemis.biblioteca.math.recaman.textd               = La regla dice:
artemis.biblioteca.math.recaman.texte               = -	a(0) = 0,
artemis.biblioteca.math.recaman.textf               = -	Si n > 0 y el n\u00famero no est\u00e1 incluido en la secuencia 
artemis.biblioteca.math.recaman.textg               = -	a(n) = a(n - 1) - n 
artemis.biblioteca.math.recaman.texth               = -	si no
artemis.biblioteca.math.recaman.texti               = -	a(n) = a(n-1) + n. 
artemis.biblioteca.math.recaman.textj               = Complejidad de tiempo: O(n^2)

#Biblioteca - geometria

artemis.biblioteca.geom.arclength.texta                 = Un \u00e1ngulo es una figura geom\u00e9trica cuando dos ratos se encuentran en un punto en un plano, esos rayos forman  los lados del \u00e1ngulo, y el punto de encuentro es referido como el v\u00e9rtice del \u00e1ngulo. Hay que tener en cuenta que el plano que forma un \u00e1ngulo no tiene que ser un plano Euclidiano, ahora en un c\u00edrculo el largo de un arco es una porci\u00f3n de la circunferencia.
artemis.biblioteca.geom.arclength.textb                 = Dado un \u00e1ngulo y el di\u00e1metro de un c\u00edrculo, podemos calcular el largo de un arco usando la f\u00f3rmula:
artemis.biblioteca.geom.arclength.textc                 = -	ArcLength = ( 2 * pi * radio ) * ( \u00e1ngulo / 360 )
artemis.biblioteca.geom.arclength.textd                 = -	Donde  pi = 22/7,
artemis.biblioteca.geom.arclength.texte                 = -	Di\u00e1metro = 2 * radio,
artemis.biblioteca.geom.arclength.textf                 = -	El \u00e1ngulo est\u00e1 en grados.
artemis.biblioteca.geom.arclength.textg                 = Si el \u00e1ngulo es mayor o igual a 360 grados, entonces el largo del arco no puede ser calculado desde que ning\u00fan \u00e1ngulo es posible.
artemis.biblioteca.geom.circularsector.texta            = Un sector circular o un sector c\u00edrculo, es la porci\u00f3n de un disco encerrado por dos radios y un arco, donde el \u00e1rea m\u00e1s peque\u00f1a es conocida como el sector menos y el grande como el sector mayor.
artemis.biblioteca.geom.circularsector.textb            = -	Sector =(pi*r^2)*(Angulo/360)
artemis.biblioteca.geom.circularsector.textc            = El \u00e1rea de un sector es similar al c\u00e1lculo del \u00e1rea de un c\u00edrculo, solo se le multiplica el \u00e1rea de un c\u00edrculo con el \u00e1ngulo del sector.
artemis.biblioteca.geom.arrangedcoin.texta              = Tenemos N monedas las cuales necesitamos ordenar en forma de tri\u00e1ngulo, por ejemplo la primera fila podr\u00e1 tener una moneda, la segunda fila dos monedas y as\u00ed en adelante, necesitamos saber la m\u00e1xima altura que podemos obtener usando esas N monedas.
artemis.biblioteca.geom.arrangedcoin.textb              = Este problema puede ser resuelto encontrando la relaci\u00f3n entre la altura del tri\u00e1ngulo y el n\u00famero de monedas, dejamos como la altura m\u00e1xima como H, luego la suma total de monedas debe ser menos de N.
artemis.biblioteca.geom.circlearea.texta                = El \u00e1rea del c\u00edrculo es igual a pi por el radio al cuadrado.
artemis.biblioteca.geom.circlearea.textb                = A=pi*r^2
artemis.biblioteca.geom.circumscribedcircle.texta       = Dado el largo de los lados de un tri\u00e1ngulo equil\u00e1tero, necesitamos encontrar el \u00e1rea de un circuncirculo del tri\u00e1ngulo dado. Todos los lados del tri\u00e1ngulo equil\u00e1tero son de igual largo, y todos los \u00e1ngulos interiores son de 60 grados.
artemis.biblioteca.geom.circumscribedcircle.textb       = Las propiedades de un circuncirculo son las siguientes:
artemis.biblioteca.geom.circumscribedcircle.textc       = -	El centro del circuncirculo es el punto donde las medianas del tri\u00e1ngulo equil\u00e1tero se intersectan.
artemis.biblioteca.geom.circumscribedcircle.textd       = -	El circulo circuncirculo es un tri\u00e1ngulo equil\u00e1tero es hecho a trav\u00e9s de los tres v\u00e9rtices de un tri\u00e1ngulo equil\u00e1tero.
artemis.biblioteca.geom.circumscribedcircle.texte       = -	El radio de un circuncirculo de in tri\u00e1ngulo equil\u00e1tero es igual a (a/\u221a3), donde \u2018a\u2019 es el largo de los lados del tri\u00e1ngulo equil\u00e1tero
artemis.biblioteca.geom.circumscribedcircle.textf       = La f\u00f3rmula usada para calcular el \u00e1rea de un c\u00edrculo circuncirculo es:
artemis.biblioteca.geom.circumscribedcircle.textg       = (\u03c0*a2)/3
artemis.biblioteca.geom.circumscribedcircle.texth       = Donde a es el largo del lado del tri\u00e1ngulo dado.
artemis.biblioteca.geom.circumscribedcircle.texti       = Sabemos que el \u00e1rea de un circulo es \u03c0*r2, donde r es el radio del circulo dado. 
artemis.biblioteca.geom.circumscribedcircle.textj       = Tambi\u00e9n sabemos que el radio de un circuncirculo de un tri\u00e1ngulo equil\u00e1tero = (Lado del tri\u00e1ngulo/\u221a3. 
artemis.biblioteca.geom.circumscribedcircle.textk       = Por lo tanto, \u00e1rea = \u03c0*r2 = \u03c0*a2/3.
artemis.biblioteca.geom.convexhull.texta                = Se define como la envolvente convexa, envoltura convexa o c\u00e1psula convexa de un conjunto de puntos X de dimensi\u00f3n n como la intersecci\u00f3n de todos los conjuntos convexos que contienen a X.
artemis.biblioteca.geom.convexhull.textb                = En el caso particular de puntos en un plano, si no todos los puntos est\u00e1n alineados, entonces su envolvente convexa corresponde a un pol\u00edgono convexo cuyos v\u00e9rtices son algunos de los puntos del conjunto inicial de puntos.
artemis.biblioteca.geom.convexhull.textc                = Una forma intuitiva de ver la envolvente convexa de un conjunto de puntos en el plano, es imaginar una banda el\u00e1stica estirada que los encierra a todos. Cuando se libere la banda el\u00e1stica tomar\u00e1 la forma de la envolvente convexa.
artemis.biblioteca.geom.cutssumatory.texta              = Dado el n\u00famero de cortes, encuentre el m\u00e1ximo n\u00famero de posibles piezas.
artemis.biblioteca.geom.cutssumatory.textb              = Este problema no es m\u00e1s que el problema del cartero flojo, y tiene la siguiente formula.
artemis.biblioteca.geom.cutssumatory.textc              = M\u00e1ximo n\u00famero de piezas  = 1 + n*(n+1)/2
artemis.biblioteca.geom.heron.texta                     = En geometr\u00eda plana elemental la f\u00f3rmula de Her\u00f3n, cuya invenci\u00f3n se atribuye al matem\u00e1tico griego Her\u00f3n de Alejandr\u00eda, da el \u00e1rea de un tri\u00e1ngulo conociendo las longitudes de sus tres lados a, b y c:
artemis.biblioteca.geom.heron.textb                     = Area=\u221a(s(s-a)(s-b)(s-c))
artemis.biblioteca.geom.angledtriangle.texta            = Se llama tri\u00e1ngulo o tr\u00edgono, en geometr\u00eda plana, al pol\u00edgono de tres lados. Los puntos comunes a cada par de lados se denominan v\u00e9rtices del tri\u00e1ngulo.
artemis.biblioteca.geom.angledtriangle.textb            = Un tri\u00e1ngulo tiene tres \u00e1ngulos interiores, tres pares congruentes de \u00e1ngulos exteriores, tres lados y tres v\u00e9rtices entre otros elementos.
artemis.biblioteca.geom.hexagonarea.texta               = Un hex\u00e1gono es una figura geom\u00e9trica de 6 lados, en dos dimensiones, el total de la suma de los \u00e1ngulos internos de cualquier hex\u00e1gono es 720\u00b0. Un hex\u00e1gono regular tiene 6 simetr\u00edas rotacionales, y 6 simetr\u00edas reflectivas, todos los \u00e1ngulos internos son de 120 grados.
artemis.biblioteca.geom.hexagonarea.textb               = Ah\u00ed hay principalmente 6 tri\u00e1ngulos equil\u00e1teros de lado n y el \u00e1rea de un tri\u00e1ngulo equil\u00e1tero es sqrt (3)/4*n*n. Desde el hex\u00e1gono, hay en total 6 tri\u00e1ngulos equil\u00e1teros con lado n, el \u00e1rea del hex\u00e1gono se convierte en (3*sqrt (3)/2) * n * n)
artemis.biblioteca.geom.polygonarea.texta               = Dadas ordenadamente las coordenadas de un pol\u00edgono, con n v\u00e9rtices, encontrar el \u00e1rea del pol\u00edgono. Aqu\u00ed ordenado significa que las coordenadas son dadas en sentido horario o anti horario, desde el primer v\u00e9rtice hasta el \u00faltimo.
artemis.biblioteca.geom.polygonarea.textb               = Podemos dividir un pol\u00edgono en tri\u00e1ngulos, la f\u00f3rmula del \u00e1rea es derivada de tomar cada camino AB, y calcular el \u00e1rea del tri\u00e1ngulo ABO, con un v\u00e9rtice de origen O, tomando el producto cruz (El cual da el \u00e1rea de un paralelogramo) y dividiendo por 2. Mientras pasemos alrededor del pol\u00edgono, estos tri\u00e1ngulos con \u00e1rea positiva o negativa se sobreponen, y las ares en medio del origen y el pol\u00edgono pueden ser canceladas y sumadas a 0, mientras solo haya \u00e1rea interna, el tri\u00e1ngulo de referencia de mantiene.
artemis.biblioteca.geom.lineintersection.texta          = Dados puntos A y B, correspondientes a la l\u00ednea AB y los puntos P y Q, correspondientes a la l\u00ednea PQ, encuentre el punto de intersecci\u00f3n de estas l\u00edneas. Los puntos est\u00e1n dados en un plano 2D con sus coordenadas X y Y.
artemis.biblioteca.geom.lineintersection.textb          = Primero que todo, asumimos que tenemos dos puntos (x1,y1,) y (x2,y2). Ahora encontramos la ecuaci\u00f3n de la l\u00ednea formada por esos puntos.
artemis.biblioteca.geom.lineintersection.textc          = Dejaremos que las l\u00edneas dadas sean:
artemis.biblioteca.geom.lineintersection.textd          = -	a1x + b1y = c1
artemis.biblioteca.geom.lineintersection.texte          = -	a2x + b2y = c2
artemis.biblioteca.geom.lineintersection.textf          = Tenemos que ahora resolver estas dos ecuaciones para encontrar el punto de intersecci\u00f3n, para resolver esto, multiplicamos a1 por b2 y a2 por b1, esto nos da:
artemis.biblioteca.geom.lineintersection.textg          = -	a1b2x + b1b2y = c1b2
artemis.biblioteca.geom.lineintersection.texth          = -	a2b1x + b2b1y = c2b1
artemis.biblioteca.geom.lineintersection.texti          = Restando esto obtenemos: 
artemis.biblioteca.geom.lineintersection.textj          = -	(a1b2 \u2013 a2b1) x = c1b2 \u2013 c2b1
artemis.biblioteca.geom.lineintersection.textk          = Esto nos da el valor de x. similarmente podemos encontrar el valor de y, (x,y) nos da el punto de intersecci\u00f3n.
artemis.biblioteca.geom.lineintersection.textl          = Esto nos da el punto de intersecci\u00f3n de dos l\u00edneas, pero si nos dan segmentos de l\u00ednea en vez de l\u00edneas, tenemos que revisar el punto que computado yace en ambos segmentos de l\u00edneas,
artemis.biblioteca.geom.lineintersection.textm          = Si el segmento de l\u00ednea es especificado por los puntos (x1,y2) y (x2,y2), entonces debemos verificar si (x,y) est\u00e1 en el segmento que tenemos de la siguiente manera:
artemis.biblioteca.geom.lineintersection.textn          = -	min (x1, x2) <= x <= max (x1, x2)
artemis.biblioteca.geom.lineintersection.texto          = -	min (y1, y2) <= y <= max (y1, y2) 
artemis.biblioteca.geom.linemidpoint.texta              = Dado dos coordenadas de una l\u00ednea iniciando en (x1,y2) y terminando en (x2,y2) encontrar el punto medio de una l\u00ednea.
artemis.biblioteca.geom.linemidpoint.textb              = El punto medio de dos puntos (x1,y2) y (x2,y2) es el punto M encontrado con la siguiente f\u00f3rmula:
artemis.biblioteca.geom.linemidpoint.textc              = -	M = ((x1+x2)/2 , (y1+y2)/2)
artemis.biblioteca.geom.linetwopoints.texta             = Dados dos puntos P(x1,y1) y Q(x2,y2), encuentre la ecuaci\u00f3n de la l\u00ednea formado por esos dos puntos.
artemis.biblioteca.geom.linetwopoints.textb             = Cualquier l\u00ednea puede ser representada como:
artemis.biblioteca.geom.linetwopoints.textc             = -	ax + by = c
artemis.biblioteca.geom.linetwopoints.textd             = Dejamos dos puntos que satisfagan la l\u00ednea dada, entonces tenemos:
artemis.biblioteca.geom.linetwopoints.texte             = -	 ax1 + by1 = c
artemis.biblioteca.geom.linetwopoints.textf             = -	ax2 + by2 = c
artemis.biblioteca.geom.linetwopoints.textg             = Podemos cambiar los siguientes valores para que la ecuaci\u00f3n de mantenga verdadera:
artemis.biblioteca.geom.linetwopoints.texth             = -	a = y2 - y1
artemis.biblioteca.geom.linetwopoints.texti             = -	b = x1 - x2
artemis.biblioteca.geom.linetwopoints.textj             = -	c = ax1 + by1
artemis.biblioteca.geom.minimumheigth.texta             = Dados dos n\u00fameros a y b, encontrar la altura m\u00e1s peque\u00f1a de un tri\u00e1ngulo de \u00e1rea \u2018a\u2019 y base \u2018b\u2019.
artemis.biblioteca.geom.minimumheigth.textb             = La altura m\u00ednima de un tri\u00e1ngulo con base \u2018b\u2019 y \u00e1rea \u2018a\u2019 puede ser evaluada teniendo el conocimiento de relaci\u00f3n entre las tres.
artemis.biblioteca.geom.minimumheigth.textc             = La relaci\u00f3n entre el \u00e1rea, la base y la altura es:
artemis.biblioteca.geom.minimumheigth.textf             = -	\u00e1rea = (1/2) * base * altura
artemis.biblioteca.geom.minimumheigth.texte             = Entonces la altura puede ser calculada como:
artemis.biblioteca.geom.minimumheigth.textf             = -	height = (2 * \u00e1rea)/ base
artemis.biblioteca.geom.minimumheigth.textg             = La altura m\u00ednima es el techo de la altura obtenida usando la f\u00f3rmula de arriba.
artemis.biblioteca.geom.perimeterblocks.texta           = Tenemos n bloques de tama\u00f1o 1x1, necesitamos encontrar el m\u00ednimo per\u00edmetro de una matriz hecha de estos bloques.Tenemos n bloques de tama\u00f1o 1x1, necesitamos encontrar el m\u00ednimo per\u00edmetro de una matriz hecha de estos bloques.
artemis.biblioteca.geom.perimeterblocks.textb           = Tomemos un ejemplo para ver el patr\u00f3n, tenemos 4 bloques, las siguientes son las diferentes posibilidades:
artemis.biblioteca.geom.perimeterblocks.textc           = Si hacemos algunos ejemplos usando l\u00e1piz y papel, podemos notar que el per\u00edmetro se vuelve m\u00ednimo cuando la figura formada es m\u00e1s cercana a un cuadrado. La raz\u00f3n de esto es, que queremos el m\u00e1ximo de lados de bloques que miren dentro de la figura, entonces el per\u00edmetro de la figura se vuelve m\u00ednimo.
artemis.biblioteca.geom.perimeterblocks.textd           = Si el n\u00famero de bloques es un cuadrado perfecto, entonces el per\u00edmetro puede ser simplemente 4*sqrt(n).
artemis.biblioteca.geom.perimeterblocks.texte           = Pero si el n\u00famero de bloques no es una ra\u00edz cuadrada perfecta, entonces nosotros calculamos el n\u00famero de filas y columnas cercanas a la ra\u00edz cuadrada, luego de arreglar los bloques en un rect\u00e1ngulo, y tenemos bloques restantes, simplemente podemos agregar 2 al per\u00edmetro porque solo 2 lados extra faltar\u00edan.
artemis.biblioteca.geom.pointinsidetriangle.texta       = Dados tres puntos esquina de un tri\u00e1ngulo, y un punto m\u00e1s P, verifique si P yace dentro del tri\u00e1ngulo o no.
artemis.biblioteca.geom.pointinsidetriangle.textb       = Dejaremos las coordenadas de las tres esquinas ser (x1, y1), (x2, y2) y (x3, y3), y las coordenadas de P ser (x, y). 
artemis.biblioteca.geom.pointinsidetriangle.textc       = 1)	Calcular \u00e1rea del tri\u00e1ngulo dado, por ejemplo el \u00e1rea del tri\u00e1ngulo ACB:  Area A = [ x1(y2 \u2013 y3) + x2(y3 \u2013 y1) + x3(y1-y2)]/2
artemis.biblioteca.geom.pointinsidetriangle.textd       = 2)	Calcular el \u00e1rea del tri\u00e1ngulo PAB. Podemos usar la misma f\u00f3rmula para esto, dejamos esta \u00e1rea ser A1.
artemis.biblioteca.geom.pointinsidetriangle.texte       = 3)	Calculamos el \u00e1rea del tri\u00e1ngulo PBC, dejamos esta \u00e1rea ser A2.
artemis.biblioteca.geom.pointinsidetriangle.textf       = 4)	Calcular el \u00e1rea del tri\u00e1ngulo PAC, dejaremos esta \u00e1rea ser A3.
artemis.biblioteca.geom.pointinsidetriangle.textg       = 5)	Si P yace dentro del tri\u00e1ngulo, entonces A1+A2+A3 debe ser igual a A.
artemis.biblioteca.geom.ratiodivideline.texta           = Dadas dos coordenadas (x1, y1) y (x2, y2), y m y n, encuentre las coordenadas que dividen la l\u00ednea juntando (x1, y1) y (x2,y2) en el ratio m:n.
artemis.biblioteca.geom.ratiodivideline.textb           = La f\u00f3rmula de la secci\u00f3n nos dice las coordenadas del punto que divide una l\u00ednea segmento dada en dos partes las cuales tendr\u00e1n la longitud del ratio m:n.
artemis.biblioteca.geom.ratiodivideline.textc           = - ((mx2+nx1/m+n),(my2+ny1/m+n))
artemis.biblioteca.geom.rectanglesnxm.texta             = Tenemos una matriz N*M, imprima el n\u00famero de rect\u00e1ngulos en \u00e9l.
artemis.biblioteca.geom.rectanglesnxm.textb             = -	Si la matriz es 1x1, entonces habr\u00e1 1 rect\u00e1ngulo.
artemis.biblioteca.geom.rectanglesnxm.textc             = -	Si la matriz es 2x1, entonces habr\u00e1  2 +1 = 3 rect\u00e1ngulos
artemis.biblioteca.geom.rectanglesnxm.textd             = -	Si la matriz es 3x1, entonces habr\u00e1 3+2+1=6 rect\u00e1ngulo.
artemis.biblioteca.geom.rectanglesnxm.texte             = Podemos decir que para N*1 ah\u00ed habr\u00e1 N+(N+1)+(N-2)\u2026 +1=(N)(N+1)/2 rect\u00e1ngulos.
artemis.biblioteca.geom.rectanglesnxm.textf             = Si nosotros a\u00f1adimos una columna m\u00e1s a Nx1, primero tendr\u00edamos tantos rect\u00e1ngulos en la segunda columna como en la primera, y luego tendr\u00edamos el mismo n\u00famero de 2xM rect\u00e1ngulos, entonces Nx2=3 (N)(N+1)/2, luego de deducir esto podemos decir que:
artemis.biblioteca.geom.rectanglesnxm.textg             = -	Para N*M nosotros tendr\u00edamos (M)(M+1)/2 (N)(N+1)/2 = M(M+1)(N)(N+1)/4
artemis.biblioteca.geom.rectanglesnxm.texth             = Entonces la f\u00f3rmula para el total de rect\u00e1ngulos es:
artemis.biblioteca.geom.rectanglesnxm.texti             = -	M(M+1)(N)(N+1)/4
artemis.biblioteca.geom.squarestriangle.texta           = Cu\u00e1l es el m\u00e1ximo n\u00famero de cuadrados de tama\u00f1o 2x2 unidades que pueden caber en un tri\u00e1ngulo is\u00f3sceles de \u00e1ngulos correctos dada la base en unidades.
artemis.biblioteca.geom.squarestriangle.textb           = Un lado del cuadrado debe ser paralelo a la base del tri\u00e1ngulo.
artemis.biblioteca.geom.squarestriangle.textc           = Desde que el tri\u00e1ngulo es is\u00f3sceles, la base dada ser\u00e1 tambi\u00e9n igual a la altura. Ahora en la parte diagonal, podr\u00edamos siempre necesitar un largo extra de dos unidades en la altura y la base del tri\u00e1ngulo para acomodar un tri\u00e1ngulo. En la longitud restante de la base, podemos construir largo/2 cuadrados. Desde que cada cuadrado es de dos unidades, lo mismo puede hacerse en el caso de la altura, ah\u00ed no hay necesidad de calcular  eso de nuevo.
artemis.biblioteca.geom.squarestriangle.textd           = Entonces, para cada nivel de la longitud dada, podemos construir \u201c(largo-2)/2\u201d cuadrados. Esto nos da una base de \u201c(largo-2)\u201d encima de \u00e9l. Continuando con el proceso de obtener el n\u00famero de cuadrados para toda la disponible \u201clargo/2\u201d altura, podemos calcular los cuadrados.
artemis.biblioteca.geom.squarestriangle.texte           = Para una forma m\u00e1s eficiente, podemos usar la f\u00f3rmula de la suma de AP n*(n+1)/2, donde n= largo-2.
artemis.biblioteca.geom.manhattansum.texta              = Dados n coordenadas enteras, encuentre la suma de la distancia de Manhattan entre todos los pares de coordenadas.
artemis.biblioteca.geom.manhattansum.textb              = La distancia de Manhattan entre dos puntos (x1,y1) y (x2,y2) es:
artemis.biblioteca.geom.manhattansum.textc              = -	|x1 \u2013 x2| + |y1 \u2013 y2|
artemis.biblioteca.geom.manhattansum.textd              = La idea es recorrer dos ciclos anidados, por ejemplo cada punto, encontrar la distancia de todos los otros puntos con este.
artemis.biblioteca.geom.manhattansum.texte              = Complejidad de tiempo: O(n2)
artemis.biblioteca.geom.threepointscolli.texta          = Dados tres puntos, verificar si estos puntos yacen en recta (colineales) o no.
artemis.biblioteca.geom.threepointscolli.textb          = Ejemplo: (1, 1), (1, 4), (1, 5)
artemis.biblioteca.geom.threepointscolli.textc          = Los tres puntos yacen en una l\u00ednea recta.
artemis.biblioteca.geom.threepointscolli.textd          = Tres puntos yacen en una l\u00ednea recta si el \u00e1rea formada por un tri\u00e1ngulo de estos tres puntos es cero.
artemis.biblioteca.geom.triangleangles.texta            = Dadas las coordenadas de tres v\u00e9rtices de un tri\u00e1ngulo en un plano 2D, encuentre sus tres \u00e1ngulos.
artemis.biblioteca.geom.triangleangles.textb            = -	c^2 = a^2 + b^2 - 2(a)(b)(cos beta)
artemis.biblioteca.geom.triangleangles.textc            = Luego del despeje:
artemis.biblioteca.geom.triangleangles.textd            = -	beta = acos( ( a^2 + b^2 - c^2 ) / (2ab) )
artemis.biblioteca.geom.triangleangles.texte            = En trigonometr\u00eda la ley del coseno cuenta que los largos de los lados de un tri\u00e1ngulo con el coseno de uno de sus \u00e1ngulos luego de un despeje nos da el \u00e1ngulo.
artemis.biblioteca.geom.triangleangles.textf            = Primero calculamos el largo de todos los lados, luego aplicamos la f\u00f3rmula de arriba para obtener  todos los \u00e1ngulos en radianes, luego convertimos de radianes a grados. 

#Biblioteca - bitwise
artemis.biblioteca.bitwise.addone.texta = Sume uno a un n\u00famero dado, el uso de los operadores como \u2018+\u2019, \u2018-\u2018,\u2019*\u2019,\u2019/\u2019,\u2019++\u2019,\u2019\u2014\u2018\u2026. Entre otros no est\u00e1 permitido.
artemis.biblioteca.bitwise.addone.textb = La respuesta se consigue con algo de magia de bits.
artemis.biblioteca.bitwise.addone.textc = Para agregar 1 a un n\u00famero x(como 0011000111), voltee todos los bits luego del cero de m\u00e1s a la derecha (bit 0) (obtenemos 0011000000) finalmente, voltee el cero de m\u00e1s a la derecha tambi\u00e9n (obtenemos 0011001000) para obtener la respuesta.
artemis.biblioteca.bitwise.binpalindrome.texta = Encuentre el n\u00famero cuya representaci\u00f3n binaria es un pal\u00edndromo. No se consideran los ceros iniciales, Mientras se considera la representaci\u00f3n binaria, considere el primer n\u00famero cuya representaci\u00f3n binaria es pal\u00edndroma como 1, en vez de 0.
artemis.biblioteca.bitwise.binpalindrome.textb = Una aproximaci\u00f3n ingenua puede ser atravesar a trav\u00e9s de todos los enteros desde 1 hasta 2^31-1 e incrementar el conteo pal\u00edndromo, si el n\u00famero es pal\u00edndromo, cuando el conteo pal\u00edndromo alcanza el n requerido, rompe el ciclo y retorna el actual entero.
artemis.biblioteca.bitwise.binpalindrome.textc = La complejidad de tiempo de esta soluci\u00f3n es O(x) donde x es el n\u00famero resultado. Note que el valor de x es generalmente m\u00e1s grande que n.
artemis.biblioteca.bitwise.booth.texta = El algoritmo de Booth es un algoritmo de multiplicaci\u00f3n que multiplica dos n\u00fameros binarios con signo en su notaci\u00f3n de complemento a 2.
artemis.biblioteca.bitwise.booth.textb = Se pone el multiplicando en BR y el multiplicador en QR y luego el algoritmo funciona con las siguientes condiciones:
artemis.biblioteca.bitwise.booth.textc = 1)	Si Qn y Qn+1 son lo mismo, por ejemplo 00 y 11 se realiza movimiento aritm\u00e9tico de un bit.
artemis.biblioteca.bitwise.booth.textd = 2)	Si Qn y Qn+1=10 se realiza A=A+BR y se realiza movimiento aritm\u00e9tico de un bit.
artemis.biblioteca.bitwise.booth.texte = 3)	Si Qn y Qn+1 = 01 se realiza A=A-BR y se realiza movimiento aritm\u00e9tico de un bit
artemis.biblioteca.bitwise.closestnumber.texta = Dado un entero positive n, imprimir el siguiente m\u00e1s peque\u00f1o y el previo m\u00e1s largo que tiene el mismo n\u00famero de bits 1 en su representaci\u00f3n binaria.
artemis.biblioteca.bitwise.closestnumber.textb = Aproximaci\u00f3n por fuerza bruta:
artemis.biblioteca.bitwise.closestnumber.textc = Una simple aproximaci\u00f3n es contar el n\u00famero de 1 en n, y luego incrementar o decrementar hasta que encontremos un n\u00famero con el mismo n\u00famero de 1.
artemis.biblioteca.bitwise.closestnumber.textd = Aproximaci\u00f3n optimizada:
artemis.biblioteca.bitwise.closestnumber.texte = Vamos a inicial con el c\u00f3digo de getNext, y luego nos movemos a getPrev.
artemis.biblioteca.bitwise.closestnumber.textf = Aproximaci\u00f3n de manipulaci\u00f3n de bits para obtenci\u00f3n del siguiente n\u00famero:
artemis.biblioteca.bitwise.closestnumber.textg = Si pensamos acerca cual ser\u00e1 el siguiente n\u00famero, podemos observar lo siguiente, dado el n\u00famero 13948, su representaci\u00f3n binaria es:
artemis.biblioteca.bitwise.closestnumber.texth = 1   1   0   1   1  0  0  1  1  1  1  1  0  0
artemis.biblioteca.bitwise.closestnumber.texti = 13  12  11  10  9  8  7  6  5  4  3  2  1  0
artemis.biblioteca.bitwise.closestnumber.textj = Buscamos hacer este n\u00famero m\u00e1s grande, pero no muy grande, tambi\u00e9n necesitamos mantener el mismo n\u00famero de unos.
artemis.biblioteca.bitwise.closestnumber.textk = Nota: Dado un n\u00famero N y dos localizaciones de bits i y j, suponga que volteamos bit i desde 1 a 0, y bit j desde 0 a 1, si i>j, entonces n podr\u00e1 decrementarse, si i<j entonces n podr\u00e1 incrementarse.
artemis.biblioteca.bitwise.closestnumber.textl = Sabemos lo siguiente:
artemis.biblioteca.bitwise.closestnumber.textm = -	Si volteamos un cero a un uno, debemos voltear un uno a un ero.
artemis.biblioteca.bitwise.closestnumber.textn = -	El n\u00famero (Luego de dos volteretas) podr\u00eda ser m\u00e1s grande si y solo si el bit cero a uno fue el izquierdo del bit uno a cero.
artemis.biblioteca.bitwise.closestnumber.texto = Nosotros queremos hacer el n\u00famero m\u00e1s grande, pero no necesariamente m\u00e1s grande, por lo tanto necesitamos voltear el cero de m\u00e1s a la derecha el cual tiene unos en el derecho de \u00e9l.
artemis.biblioteca.bitwise.closestnumber.textp = Para pone resto en una forma diferente, nosotros estamos volteando el cero no final de m\u00e1s a la derecho, esto es usando el ejemplo de abajo, los ceros finales son en la primera y cero posici\u00f3n. El cero no final de m\u00e1s a la derecha es un bit 7, vamos a llamar esta posici\u00f3n p.
artemis.biblioteca.bitwise.closestnumber.textq = -	p -> posici\u00f3n de m\u00e1s a la derecha que no sea cero final.
artemis.biblioteca.bitwise.closestnumber.textr = Paso 1: volteamos el cero m\u00e1s a la derecha no final.
artemis.biblioteca.bitwise.closestnumber.texts = -	1    1   0   1  1  0  1  1  1  1  1  1  0  0
artemis.biblioteca.bitwise.closestnumber.textt = -	13  12  11  10  9  8  7  6  5  4  3  2  1  0
artemis.biblioteca.bitwise.closestnumber.textu = Con este cambio, hemos incrementado el n\u00famero de unos en n, podemos encojer el n\u00famero reordenando todos los bits de la derecha del bit p tales que los ceros est\u00e1n en la izquierda y los unos est\u00e1n a la derecha, cuando se hace esto, se busca reemplazar uno  de los unos con cero.
artemis.biblioteca.bitwise.closestnumber.textv = Una forma relativamente f\u00e1cil de hacer esto es contando cuantos unos est\u00e1n a la derecha de p, despejar todos los bits desde 0 hasta p, y luego agregar de nuevo en c1-1 unos. Dejar c1 ser el n\u00famero de unos de la derecha de p y c0 el n\u00famero de ceros de la derecha de p.
artemis.biblioteca.bitwise.closestnumber.textw = Vamos a verificar esto con un ejemplo:
artemis.biblioteca.bitwise.closestnumber.textx = -	c1-> N\u00famero de unos de la derecho de p
artemis.biblioteca.bitwise.closestnumber.texty = -	c0-> N\u00famero de ceros de la derecho de p
artemis.biblioteca.bitwise.closestnumber.textz = -	p = c0 + c1
artemis.biblioteca.bitwise.closestnumber.textaa = Paso 2: despejar los bits de la derecha de p, como antes c0 = 2. c1 = 5. p = 7.
artemis.biblioteca.bitwise.closestnumber.textab = -	1    1   0   1  1  0  1  0  0  0  0  0  0  0
artemis.biblioteca.bitwise.closestnumber.textac = -	13  12  11  10  9  8  7  6  5  4  3  2  1  0
artemis.biblioteca.bitwise.closestnumber.textad = Para despejar estos bits, necesitamos crear una m\u00e1scara que sea una secuencia de unos, seguido por p ceros, podemos hacer esto de la siguiente forma:
artemis.biblioteca.bitwise.closestnumber.textae = // Todos los ceros excepto por un 1 en la posici\u00f3n p.
artemis.biblioteca.bitwise.closestnumber.textaf = -	a = 1 << p; 
artemis.biblioteca.bitwise.closestnumber.textag = // Todos los ceros, seguidos por p unos. 
artemis.biblioteca.bitwise.closestnumber.textah = -	b = a - 1;                       
artemis.biblioteca.bitwise.closestnumber.textai = // Todos los unos, seguidos por p ceros.
artemis.biblioteca.bitwise.closestnumber.textaj = -	mask = ~b;                       
artemis.biblioteca.bitwise.closestnumber.textak = // Despeja los p bits de m\u00e1s a la derecha.
artemis.biblioteca.bitwise.closestnumber.textal = -	n = n & mask;                
artemis.biblioteca.bitwise.closestnumber.textam = O m\u00e1s concisamente, hacemos:
artemis.biblioteca.bitwise.closestnumber.textan = -	n &= ~ ((1 << p) - 1).
artemis.biblioteca.bitwise.closestnumber.textao = Paso 3: Agrega un c1=1 unos.
artemis.biblioteca.bitwise.closestnumber.textap = -	1   1   0   1   1  0  1  0  0  0  1  1  1  1
artemis.biblioteca.bitwise.closestnumber.textaq = -	13  12  11  10  9  8  7  6  5  4  3  2  1  0
artemis.biblioteca.bitwise.closestnumber.textar = Para insertar c1-1 unos a la derecha, se realiza:
artemis.biblioteca.bitwise.closestnumber.textas = // Ceros con un uno en la posici\u00f3n c1\u2013 1
artemis.biblioteca.bitwise.closestnumber.textat = -	a = 1 << (c1 - 1);    
artemis.biblioteca.bitwise.closestnumber.textau = // Ceros con unos en posiciones cero a trav\u00e9s de c1-1
artemis.biblioteca.bitwise.closestnumber.textav = -	b = a - 1;                
artemis.biblioteca.bitwise.closestnumber.textaw = // Inserta unos en las posiciones 0 a trav\u00e9s de c1-1
artemis.biblioteca.bitwise.closestnumber.textax = -	n = n | b;                
artemis.biblioteca.bitwise.closestnumber.textay = O m\u00e1s concisamente:
artemis.biblioteca.bitwise.closestnumber.textaz = -	n | = (1 << (c1 - 1)) - 1;  
artemis.biblioteca.bitwise.closestnumber.texta = N\u00fameros binarios es la forma por defecto para almacenar n\u00fameros, pero en muchas aplicaciones los n\u00fameros binarios son dif\u00edciles de usar y una variaci\u00f3n de los n\u00fameros binarios es necesaria, aqu\u00ed es cuando los c\u00f3digos de Gray son muy \u00fatiles.
artemis.biblioteca.bitwise.closestnumber.textb = El c\u00f3digo de gray tiene una propiedad, dos n\u00fameros sucesivos difieren en un solo bit porque esta propiedad permite tener ciclo a trav\u00e9s de varios estados con un esfuerzo m\u00ednimo y son usados en mapas k, tambi\u00e9n permiten correcci\u00f3n de errores, comunicaci\u00f3n entre  muchas cosas m\u00e1s.
artemis.biblioteca.bitwise.closestnumber.textc = \u00bfC\u00f3mo generar c\u00f3digos de Gray de n bits?
artemis.biblioteca.bitwise.closestnumber.textd = La siguiente es la secuencia de dos bits (n=2)
artemis.biblioteca.bitwise.closestnumber.texte = -	  00 01 11 10
artemis.biblioteca.bitwise.closestnumber.textf = La siguiente es la secuencia de 3 bits (n = 3)
artemis.biblioteca.bitwise.closestnumber.textg = -	000 001 011 010 110 111 101 100
artemis.biblioteca.bitwise.closestnumber.texth = Y la siguiente es la secuencia de 4 bits (n = 4)
artemis.biblioteca.bitwise.closestnumber.texti = -	0000 0001 0011 0010 0110 0111 0101 0100 1100 1101 1111 1110 1010 1011 1001 1000
artemis.biblioteca.bitwise.closestnumber.textj = Los c\u00f3digos de Gray de n bits pueden ser generados de la lista de (n-1) c\u00f3digos de Gray con los siguientes pasos.
artemis.biblioteca.bitwise.closestnumber.textk = -	Dejar la lista de (n-1)bits ser L1, crear otra lista L2 la cual es la reversa de L1
artemis.biblioteca.bitwise.closestnumber.textl = -	Modificar la lista L1 usando prefijo \u20180\u2019 en todos los c\u00f3digos de L1
artemis.biblioteca.bitwise.closestnumber.textm = -	Concatene L1 y L2. La lista concatenada es la lista requerida de los c\u00f3digos de Gray de n bits
artemis.biblioteca.bitwise.closestnumber.textn = En ciencias de la computaci\u00f3n muchas veces necesitamos convertir de c\u00f3digo binario a c\u00f3digo de Gray y viceversa, esta conversion puede ser realizada bajo las siguientes reglas:
artemis.biblioteca.bitwise.closestnumber.texto = Conversi\u00f3n de binario a Gray:
artemis.biblioteca.bitwise.closestnumber.textp = El bit m\u00e1s significante (MSB most significant bit) del c\u00f3digo de gray es siempre igual a el MSB del c\u00f3digo binario dado.
artemis.biblioteca.bitwise.closestnumber.textq = Otros bits de la salida del c\u00f3digo de gray pueden ser obtenidos realizando XOR al bit del c\u00f3digo binario en ese \u00edndice y en el \u00edndice anterior.
artemis.biblioteca.bitwise.closestnumber.textr = Conversi\u00f3n de Gray a binario: 
artemis.biblioteca.bitwise.closestnumber.texts = El MSB del c\u00f3digo binario es siempre igual al MSB del c\u00f3digo de Gray.
artemis.biblioteca.bitwise.closestnumber.textt = Los otros bits de la salida del c\u00f3digo binario pueden ser obtenidos verificando el bit del c\u00f3digo Gray en ese incide, si el bit actual es 0, entonces copia el anterior bit del c\u00f3digo binario, si no copia el inverso del anterior bit del c\u00f3digo binario.
artemis.biblioteca.bitwise.countatob.texta = Dados dos n\u00fameros \u2018a\u2019 y \u2018b\u2019, contar el n\u00famero de bits necesarios a voltear para convertir \u2018a\u2019 en \u2018b\u2019.
artemis.biblioteca.bitwise.countatob.textb = 1)	Calcular el XOR de A y B:  a_xor_b = A ^ B
artemis.biblioteca.bitwise.countatob.textc = 2)	Contar los sets de bits de lo de arriba
artemis.biblioteca.bitwise.countatob.textd = Resultado del XOR calculado:
artemis.biblioteca.bitwise.countatob.texte = countSetBits(a_xor_b)
artemis.biblioteca.bitwise.countatob.textf = XOR de dos n\u00fameros tendr\u00e1 set de bits solo en esos lugares donde A difiera de B
artemis.biblioteca.bitwise.countsets.texta = Dado un entero positivo n, cuente el n\u00famero total de sets de bits en representaci\u00f3n binaria de todos los n\u00fameros de 1 a n.
artemis.biblioteca.bitwise.countsets.textb = Una soluci\u00f3n simple es correr un ciclo desde 1 hasta n y sumar el conteo de sets de bits de todos los n\u00fameros de 1 a n.
artemis.biblioteca.bitwise.euclidnomod.texta = El algoritmo de Euclides es usado para encontrar el GCD de dos n\u00fameros.
artemis.biblioteca.bitwise.euclidnomod.textb = La idea es usar operaciones de BitWise, podemos encontrar x/2 usando x>>1. Podemos verificar si x es par o impar usando x&1.
artemis.biblioteca.bitwise.euclidnomod.textc = -	gcd(a, b) = 2*gcd(a/2, b/2) si ambos a y b son pares.
artemis.biblioteca.bitwise.euclidnomod.textd = -	gcd(a, b) = gcd(a/2, b)  si a es par y b es impar.
artemis.biblioteca.bitwise.euclidnomod.texte = -	gcd(a, b) = gcd(a, b/2) si a es impar y b es par.
artemis.biblioteca.bitwise.findduplicates.texta = Se tiene un arreglo de N n\u00fameros, donde n es al menos 32000, el array puede tener entradas duplicadas y no se sabe que N es.
artemis.biblioteca.bitwise.findduplicates.textb = Con solo 4 kilobytes de memoria disponible, \u00bfc\u00f3mo podr\u00eda imprimir todos los elementos duplicados en el array?
artemis.biblioteca.bitwise.findduplicates.textc = Tenemos 4 kilobytes de memoria lo cual significa que podemos direccionar hasta 8*4*210 bits, note que 32*210 es m\u00e1s grande que 32000, podemos crear un bit con 32000 bits, donde cada bit representa un entero.
artemis.biblioteca.bitwise.findduplicates.textd = Si se necesita crear un bit con m\u00e1s de 32000 bits entonces se puede crear f\u00e1cilmente m\u00e1s y m\u00e1s de 32000.
artemis.biblioteca.bitwise.findduplicates.texte = Usando este vector de bits, podemos entonces iterar a trav\u00e9s del arreglo, marcando cada elemento v poniendo el bit v en 1, cuando pasemos por un elemento duplicado, los imprimimos.
artemis.biblioteca.bitwise.graycodes.texta = Dado un n\u00famero n, generar los patrones de bits de 0 a 2^n-1 de los cuales cada patr\u00f3n sucesivo difiera en uno solo bit.
artemis.biblioteca.bitwise.graycodes.textb = Los c\u00f3digos de Gray de n bits pueden ser generados de la lista de (n-1) c\u00f3digos de Gray con los siguientes pasos.
artemis.biblioteca.bitwise.graycodes.textc = -	Dejar la lista de (n-1)bits ser L1, crear otra lista L2 la cual es la reversa de L1
artemis.biblioteca.bitwise.graycodes.textd = -	Modificar la lista L1 usando prefijo \u20180\u2019 en todos los c\u00f3digos de L1
artemis.biblioteca.bitwise.graycodes.texte = -	Concatene L1 y L2. La lista concatenada es la lista requerida de los c\u00f3digos de Gray de n bits
artemis.biblioteca.bitwise.graycodes.textf = Por ejemplo, los siguientes son los pasos para generar el c\u00f3digo de Gray de 3 bits desde la lista de c\u00f3digos de Gray de 2 bits.
artemis.biblioteca.bitwise.graycodes.textg = -	L1 = {00, 01, 11, 10} (Lista de Gray de dos bits)
artemis.biblioteca.bitwise.graycodes.texth = -	L2 = {10, 11, 01, 00} (Reversa de  L1)
artemis.biblioteca.bitwise.graycodes.texti = -	Agrega prefijo a todas las entradas de L1 con \u20180\u2019, L1 se convierte en {000, 001, 011, 010}
artemis.biblioteca.bitwise.graycodes.textj = -	Agrega prefijo a todas las entradas de L2 con \u20181\u2019, L2 se convierte en {110, 111, 101, 100}
artemis.biblioteca.bitwise.graycodes.textk = -	Concatena L1 y L2, obtenemos {000, 001, 011, 010, 110, 111, 101, 100}
artemis.biblioteca.bitwise.graycodes.textl = Para generar los c\u00f3digos de Gray de n bits, empezamos desde la lista de Grays de un solo bit, la cual es {0,1}, repetimos los pasos de arriba para general la lista de 2 bits a partir de la de 1 solo bit, luego generamos la de 3 bits a partir de la de 2 bits, y as\u00ed hasta que el n\u00famero de bits sea igual a n.
artemis.biblioteca.bitwise.karatsuba.texta = Dados dos strings binarios (A bigIntegers) que representan el valor de dos enteros, encuentre el producto de los dos strings, por ejemplo, si el primer string de bits es \u201c1100\u201d y el segundo string de bits es \u201c1010\u201d la salida debe ser 120.
artemis.biblioteca.bitwise.karatsuba.textb = Por simplicidad, dejaremos la longitud de ambos strings ser igual y ser n.
artemis.biblioteca.bitwise.karatsuba.textc = -	x=5678 y=1234 
artemis.biblioteca.bitwise.karatsuba.textd = -	a=56,b=78
artemis.biblioteca.bitwise.karatsuba.texte = -	c=12,d=34
artemis.biblioteca.bitwise.karatsuba.textf = Paso 0 = m = n/2 + n%2
artemis.biblioteca.bitwise.karatsuba.textg = Paso 1 = a*c
artemis.biblioteca.bitwise.karatsuba.texth = Paso 2 = b*d
artemis.biblioteca.bitwise.karatsuba.texti = Paso 3 = (a + b)*(c + d)
artemis.biblioteca.bitwise.karatsuba.textj = Paso 4 = 3) - 2) - 1)
artemis.biblioteca.bitwise.karatsuba.textk = Paso 5 = 1)*pow(10, m*2) + 2) + 4)*pow(10, m)
artemis.biblioteca.bitwise.maxconsecutiveone.texta = Dado un entero n, podemos voltear exactamente un bit, encuentre la longitud de la secuencia m\u00e1s larga de 1 que se pueda crear.
artemis.biblioteca.bitwise.maxconsecutiveone.textb = Una soluci\u00f3n eficiente es andar a trav\u00e9s de los bits en representaci\u00f3n binaria del n\u00famero dado, mantenemos rastreo de la longitud de la secuencia actual de unos, de la longitud de la secuencia de unos previa, cuando veamos un cero, actualizamos la longitud anterior:
artemis.biblioteca.bitwise.maxconsecutiveone.textc = -	Si el siguiente bit es un 1, longitud anterior deber\u00e1 ser ahora la longitud actual.
artemis.biblioteca.bitwise.maxconsecutiveone.textd = -	Si el siguiente bit es un 0, entonces no podemos unir esas secuencias juntas, entonces la longitud previa es 0.
artemis.biblioteca.bitwise.maxconsecutiveone.texte = Actualizamos la longitud m\u00e1xima comparando las dos siguientes cosas:
artemis.biblioteca.bitwise.maxconsecutiveone.textf = -	Valor actual de max_lenght
artemis.biblioteca.bitwise.maxconsecutiveone.textg = -	Current-lenght+previos-length
artemis.biblioteca.bitwise.maxconsecutiveone.texth = Entonces
artemis.biblioteca.bitwise.maxconsecutiveone.texti = -	result = return max-length+1 (// Agrega 1 para el Contador de bits volteados )
artemis.biblioteca.bitwise.maxsubarrayxor.texta = Dado un array de enteros, encontrar el valor m\u00e1ximo del Subarray XOR en el array dado. Una soluci\u00f3n simple es usar dos ciclos para encontrar el XOR de todos los subarrays y retornar el m\u00e1ximo.
artemis.biblioteca.bitwise.maxsubarrayxor.textb = La complejidad de tiempo de esta soluci\u00f3n es O(n2).
artemis.biblioteca.bitwise.multiplybyseven.texta = Podemos multiplicar un n\u00famero por 7 usando operadores BitWise, primero hacemos corrimiento izquierdo del n\u00famero de 3 bits (Se obtendr\u00e1 8n) luego se resta la forma original del n\u00famero corrido y se retorna la diferencia (8n-n).
artemis.biblioteca.bitwise.multiplybyseven.textb = Complejidad de tiempo: O(1).
artemis.biblioteca.bitwise.multiplybyseven.textc = Funciona solo para enteros positivos.
artemis.biblioteca.bitwise.multiplybyseven.textd = El mismo concepto puede ser usado para  multiplicaci\u00f3n r\u00e1pida por 9 u otros n\u00fameros.
artemis.biblioteca.bitwise.magicnumber.texta = Un n\u00famero m\u00e1gico es definido como un n\u00famero el cual puede ser expresado como una potencia de 5 o la suma de potencias \u00fanicas de 5, algunos n\u00fameros m\u00e1gicos son 5, 25, 30(5 + 25), 125, 130(125 + 5), \u2026.
artemis.biblioteca.bitwise.magicnumber.textb = Si revisamos cuidadosamente los n\u00fameros m\u00e1gicos, pueden ser representados como 001, 010, 011, 100, 101, 110, entre otros, donde 001 es 0*pow(5,3)+0*pow(5,2)+1*pow(5,1), entonces b\u00e1sicamente necesitamos agregar potencias de 5 por cada bit dado en el entero dado n.
artemis.biblioteca.bitwise.nsquare.texta = Dado un entero n, calcular el cuadrado de un n\u00famero sin usar *,/ y pow().
artemis.biblioteca.bitwise.nsquare.textb = Podemos hacerlo en tiempo O(Logn) usando operadores de BitWise, la idea est\u00e1 basada en el siguiente hecho:
artemis.biblioteca.bitwise.nsquare.textc = -	square(n) = 0 if n == 0
artemis.biblioteca.bitwise.nsquare.textd = Si n es par 
artemis.biblioteca.bitwise.nsquare.texte = square(n) = 4*square(n/2) 
artemis.biblioteca.bitwise.nsquare.textf = Si n es impar
artemis.biblioteca.bitwise.nsquare.textg = -	   square(n) = 4*square(floor(n/2)) + 4*floor(n/2) + 1 
artemis.biblioteca.bitwise.nsquare.texth = Por ejemplo:
artemis.biblioteca.bitwise.nsquare.texti = -	square(6) = 4*square(3)
artemis.biblioteca.bitwise.nsquare.textj = -	square(3) = 4*(square(1)) + 4*1 + 1 = 9
artemis.biblioteca.bitwise.nsquare.textk = -	square(7) = 4*square(3) + 4*3 + 1 = 4*9 + 4*3 + 1 = 49
artemis.biblioteca.bitwise.nsquare.textl = Si n es par, puede ser escrito como:
artemis.biblioteca.bitwise.nsquare.textm = -	  n = 2*x 
artemis.biblioteca.bitwise.nsquare.textn = -	  n2 = (2*x)2 = 4*x2
artemis.biblioteca.bitwise.nsquare.texto = Si n es impar, puede ser escrito como: 
artemis.biblioteca.bitwise.nsquare.textq = -	n = 2*x + 1
artemis.biblioteca.bitwise.nsquare.textr = -	 n2 = (2*x + 1)2 = 4*x2 + 4*x + 1
artemis.biblioteca.bitwise.nsquare.texts = floor(n/2)  puede ser calculado usando el operados de BitWise corrimiento derecho.
artemis.biblioteca.bitwise.oddevenswap.texta = Dado un entero sin signo, intercambia todos los bits pares con impares, por ejemplo si el n\u00famero dado es 23 (00010111), puede ser convertido en 43 (00101011). Cada posici\u00f3n de bit par es intercambiada con el bit adyacente del lado de derecho, y cada posici\u00f3n impar es cambiada con el adyacente del lado izquierdo. 
artemis.biblioteca.bitwise.oddevenswap.textb = Si realizamos una revisamos en el ejemplo, podemos observar que b\u00e1sicamente necesitamos el corrimiento derecho (>>) de todos los bits pares por 1, entonces se convierten en bits impares, y corrimiento izquierdo (<<)  todos los bits impares por 1 entonces se convierten en pares, la siguiente soluci\u00f3n est\u00e1 basada en estas ideas, se asume que el n\u00famero de entrada est\u00e1 almacenado usando 32 bits.
artemis.biblioteca.bitwise.oddevenswap.textc = Dejemos la entrada ser x.
artemis.biblioteca.bitwise.oddevenswap.textd = 1)	Obtener todos los bits pares de x realizando BitWise, y or de x con 0xAAAAAAAA, el n\u00famero 0xAAAAAAAA es un entero de 32 bit con todos los bits pares ubicados en 1, y todos los impares en 0.
artemis.biblioteca.bitwise.oddevenswap.texte = 2)	Obtener todos los bits impares usando BitWise, y or de x con 0x55555555, el n\u00famero 0x55555555 es un n\u00famero entero de 32 bits con todos los bits impares en 1 y los pares en 0.
artemis.biblioteca.bitwise.oddevenswap.textf = 3)	Corrimiento derecho de todos los bits pares
artemis.biblioteca.bitwise.oddevenswap.textg = 4)	Corrimiento izquierdo de todos los bits impares
artemis.biblioteca.bitwise.oddevenswap.texth = 5)	Combina los nuevos pares e impares y retorna
artemis.biblioteca.bitwise.oddocurrence.texta = Dado un array de enteros positivos, todos los n\u00fameros  ocurren n\u00famero par de veces excepto un n\u00famero el cual ocurre impar veces, encuentre el n\u00famero en O(n) tiempo y espacio constante.
artemis.biblioteca.bitwise.oddocurrence.textb = Una soluci\u00f3n simple es correr dos ciclos anidados, el ciclo externo toma todos los elementos uno por uno y el ciclo interno cuenta el n\u00famero de las ocurrencias del elemento tomado en el ciclo externo, la complejidad de tiempo de esta soluci\u00f3n es O(n^2).
artemis.biblioteca.bitwise.oppositesigns.texta = Dado dos enteros con signo, retorne true si los signos de los enteros dados son diferentes, de otra forma retorne falso, por ejemplo la funci\u00f3n debe retornar true en -1 y +100, y debe retornar falso para -200 y -100. La funci\u00f3n no debe usar ning\u00fan operados aritm\u00e9tico.
artemis.biblioteca.bitwise.oppositesigns.textb = Dejaremos los enteros dados ser x y y, el bit de signo es 1 en n\u00fameros negativos, y 0 en n\u00fameros positivos, El XOR de x y y puede tener el bit de signo en 1 si ellos tiene signos opuestos, en otras palabras, XOR de x y y ser\u00e1 un n\u00famero negativo si x y y tienen signos opuestos.
artemis.biblioteca.bitwise.pandigital.texta = Un par de string cuando son concatenados puede ser una concatenaci\u00f3n Pandigital si su concatenaci\u00f3n consiste en todos los d\u00edgitos de 0 a 9 en orden al menos una vez, la tarea es dado n strings, computar el n\u00famero de pares que resultan en una concatenaci\u00f3n Pandigital.
artemis.biblioteca.bitwise.pandigital.textb = Una posible soluci\u00f3n por fuerza bruta es forma todas las posibles concatenaciones formando todos los pares en O(n^2) y usando un array de frecuencia para los d\u00edgitos 0 a 9, verificamos cada digito si existe al menos una vez en cada concatenaci\u00f3n formado por cada par.
artemis.biblioteca.bitwise.poweroffour.texta = Dado un entero n, encontrar si es potencia de 4 o no.
artemis.biblioteca.bitwise.poweroffour.textb = 1)	Un m\u00e9todo simple es tomar logaritmo del n\u00famero dado en base 4, y si obtenemos un n\u00famero entero entonces el n\u00famero es potencia de 4.
artemis.biblioteca.bitwise.poweroffour.textc = 2)	Otra soluci\u00f3n es mantenerse dividiendo el n\u00famero por 4, por ejemplo haremos n=n/4 iterativamente, si n %4 se convierte en un no cero y n no es 1, entonces no es potencia de 4, de otra forma si lo es
artemis.biblioteca.bitwise.russianpeasant.texta = Dados dos enteros, multiplicador sin usar el operador de multiplicaci\u00f3n.
artemis.biblioteca.bitwise.russianpeasant.textb = Una forma interesante es usar el algoritmo de la campesina rusa, la idea es duplicar el primer n\u00famero y dividir en dos el segundo n\u00famero repetidamente mientras el segundo n\u00famero no se convierta en 1, en el proceso cuando el segundo n\u00famero se vuelta impar, a\u00f1adimos el primer n\u00famero al resultado, el cual esta inicializado en 0.
artemis.biblioteca.bitwise.russianpeasant.textc = El valor de a*b es el mismo que (a*2)*(b/2), si b es par, de otra forma el valor es el mismo de ((a*2)*(b/2) + a), en el ciclo while, seguimos multiplicando \u2018a\u2019 con dos y seguimos dividiendo \u2018b\u2019 por 2, si \u2018b\u2019 se convierte en impar en el ciclo, agregamos \u2018a\u2019 a \u2018res\u2019 cuando el calor de \u2018b\u2019 se convierta en 1, el valor de \u2018res\u2019 + \u2018a\u2019 nos da el resultado.
artemis.biblioteca.bitwise.russianpeasant.textd = Note que cuando \u2018b\u2019 es una potencia de 2, el \u2018res\u2019 puede mantenerse en 0 y \u2018a\u2019 puede ser la multiplicaci\u00f3n.

#Biblioteca - grafos
artemis.biblioteca.grafos.matrix.texta              = La matriz de adyacencia es una matriz cuadrada que se utiliza como una forma de representar relaciones binarias, Se crea una matriz cero, cuyas columnas y filas representan los nodos del grafo. 
artemis.biblioteca.grafos.matrix.textb              = 1)	Por cada arista que une a dos nodos, se suma 1 al valor que hay actualmente en la ubicaci\u00f3n correspondiente de la matriz.
artemis.biblioteca.grafos.matrix.textc              = 2)	Si tal arista es un bucle y el grafo es no dirigido, entonces se suma 2 en vez de 1.
artemis.biblioteca.grafos.matrix.textd              = 3)	Finalmente, se obtiene una matriz que representa el n\u00famero de aristas (relaciones) entre cada par de nodos (elementos).
artemis.biblioteca.grafos.matrix.texte              = Existe una matriz de adyacencia \u00fanica para cada grafo (sin considerar las permutaciones de filas o columnas), y viceversa.
artemis.biblioteca.grafos.matrix.textf              = -	Para un grafo no dirigido la matriz de adyacencia es sim\u00e9trica.
artemis.biblioteca.grafos.matrix.textg              = -	El n\u00famero de caminos Ci,j(k), atravesando k aristas desde el nodo i al nodo j, viene dado por un elemento de la potencia k-\u00e9sima de la matriz de adyacencia: -
artemis.biblioteca.grafos.matrix.texth              = -	Ci,j(k)=[A^K]ij
artemis.biblioteca.grafos.matrix.texti              = Existen otras formas de representar relaciones binarias, como por ejemplo los pares ordenados o los grafos
artemis.biblioteca.grafos.listaadyacencia.texta     = En teor\u00eda de grafos, una lista de adyacencia es una representaci\u00f3n de todas las aristas o arcos de un grafo mediante una lista.
artemis.biblioteca.grafos.listaadyacencia.textb     = Si el grafo es no dirigido, cada entrada es un conjunto o multiconjunto de dos v\u00e9rtices conteniendo los dos extremos de la arista correspondiente. Si el grafo es dirigido, cada entrada es una tupla de dos nodos, uno denotando el nodo fuente y el otro denotando el nodo destino del arco correspondiente.
artemis.biblioteca.grafos.listaadyacencia.textc     = T\u00edpicamente, las listas de adyacentes no son ordenadas.
artemis.biblioteca.grafos.bfs.texta                 = B\u00fasqueda en anchura (en ingl\u00e9s BFS - Breadth First Search) es un algoritmo de b\u00fasqueda no informada utilizado para recorrer o buscar elementos en un grafo (usado frecuentemente sobre \u00e1rboles). Intuitivamente, se comienza en la ra\u00edz (eligiendo alg\u00fan nodo como elemento ra\u00edz en el caso de un grafo) y se exploran todos los vecinos de este nodo. A continuaci\u00f3n para cada uno de los vecinos se exploran sus respectivos vecinos adyacentes, y as\u00ed hasta que se recorra todo el \u00e1rbol.
artemis.biblioteca.grafos.bfs.textb                 = Formalmente, BFS es un algoritmo de b\u00fasqueda sin informaci\u00f3n, que expande y examina todos los nodos de un \u00e1rbol sistem\u00e1ticamente para buscar una soluci\u00f3n. El algoritmo no usa ninguna estrategia heur\u00edstica.
artemis.biblioteca.grafos.bfs.textc                 = -	Dado un v\u00e9rtice fuente s, Breadth-first search sistem\u00e1ticamente explora los v\u00e9rtices de G para \u201cdescubrir\u201d todos los v\u00e9rtices alcanzables desde s.
artemis.biblioteca.grafos.bfs.textd                 = -	Calcula la distancia (menor n\u00famero de v\u00e9rtices) desde s a todos los v\u00e9rtices alcanzables.
artemis.biblioteca.grafos.bfs.texte                 = -	Despu\u00e9s produce un \u00e1rbol BF con ra\u00edz en s y que contiene a todos los v\u00e9rtices alcanzables.
artemis.biblioteca.grafos.bfs.textf                 = -	El camino desde dt a cada v\u00e9rtice en este recorrido contiene el m\u00ednimo n\u00famero de v\u00e9rtices. Es el camino m\u00e1s corto medido en n\u00famero de v\u00e9rtices.
artemis.biblioteca.grafos.bfs.textg                 = -	Su nombre se debe a que expande uniformemente la frontera entre lo descubierto y lo no descubierto. Llega a los nodos de distancia k, s\u00f3lo tras haber llegado a todos los nodos a distancia k-1.
artemis.biblioteca.grafos.bfs.texth                 = La complejidad computacional del algoritmo se puede expresar como  O(|V|+|E|) O(|V|+|E|), donde  |V|  |V| es el n\u00famero de v\u00e9rtices y |E| es el n\u00famero de aristas. El razonamiento es porque en el peor caso, cada v\u00e9rtice y cada arista ser\u00e1n visitados por el algoritmo.
artemis.biblioteca.grafos.binarygraphsp.texta       = Dado un grafo donde cada camino tiene un peso de 0 o 1, un v\u00e9rtice inicial tambi\u00e9n es dado, encuentre el camino m\u00e1s corto desde el origen hasta cualquier otro v\u00e9rtice.
artemis.biblioteca.grafos.binarygraphsp.textb       = En el BFS normal de un grafo, todos los caminos son de igual peso, pero en BFS 0-1 ALGUNOS caminos pueden tener peso 0 y algunos 1, en este no podemos usar un array de booleanos para marcar los nodos visitados pero en cada paso podemos verificar la condici\u00f3n de distancia optima, usamos una cola de doble fin para almacenar el nodo, mientras realizamos BFS si un camino es encontrado con peso 0 el nodo es empujado al frente de la doble cola y si el camino tiene peso 1 es empujado atr\u00e1s en la doble cola.
artemis.biblioteca.grafos.binarygraphsp.textc       = Esta aproximaci\u00f3n es similar a Dijkstra en que si la distancia m\u00e1s corta a un nodo es relajada por el nodo anterior entonces solo ser\u00e1 empujada en la cola.
artemis.biblioteca.grafos.binarygraphsp.textd       = La idea de arriba trabaja en todos los casos, cuando sacamos un v\u00e9rtice, es el v\u00e9rtice de m\u00ednimo peso de todos los v\u00e9rtices restantes, si hay un v\u00e9rtice de peso 0 adyacente a el entonces este adyacente tiene la misma distancia, si hay un adyacente de peso 1, entonces este adyacente tiene la m\u00e1xima distancia de todos los v\u00e9rtices en la cola doble, (Porque todos los otros v\u00e9rtices son adyacentes de actual eliminado v\u00e9rtice o adyacente de los anteriores eliminados).
artemis.biblioteca.grafos.binarygraphsp.texte       = Este problema puede ser resuelto con Dijkstra pero el tiempo de complejidad seria de O(E + V Log V) donde por BFS puede ser de O(V+E).
artemis.biblioteca.grafos.countallpaths.texta       = Cuente el n\u00famero total de caminos o v\u00edas que existen entre dos v\u00e9rtices en un grafo dirigido, estos caminos no contienen un ciclo, la simple raz\u00f3n de esto es que un ciclo contiene infinito n\u00famero de caminos y esto crea problema.
artemis.biblioteca.grafos.countallpaths.textb       = El problema puede ser resuelto usando backtracking, esto es si tomamos un camino y empezamos a andar por \u00e9l, si nos lleva al v\u00e9rtice de destino entonces contamos el camino y nos devolvemos a tomar otro camino, si el camino no nos lleva al v\u00e9rtice destino, descartamos este camino.
artemis.biblioteca.grafos.cycledirected.texta       = Dado un grafo dirigido, verificar si el grafo contiene un ciclo o no, la funci\u00f3n debe retornar true si el grafo dado contiene al menos un ciclo, de lo contrario retorne false, por ejemplo el siguiente grafo tiene tres ciclos, 0->2->0, 0->1->2->0 y 3->3, entonces la funci\u00f3n debe retornar true.
artemis.biblioteca.grafos.cycledirected.textb       = DFS puede ser usado para detectar un ciclo en un grafo, DFS para un grafo conectado produce un \u00e1rbol, hay un ciclo en un grafo solo si hay un camino de regreso presente en el grafo. Un camino de regreso es un camino de un nodo a s\u00ed mismo, o uno de sus antecesores en el \u00e1rbol producido por el DFS.
artemis.biblioteca.grafos.cycledirected.textc       = Para un grado desconexo, tenemos el bosque DFS como salida, para detectar un ciclo, podemos verificar los arboles individuales en b\u00fasqueda de caminos de regreso.
artemis.biblioteca.grafos.cycledirected.textd       = Para detectar un camino de regreso, podemos rastrear los v\u00e9rtices actuales en una pila de recursi\u00f3n de la funci\u00f3n de DFS transverso, si llegamos a un v\u00e9rtice que ya est\u00e1 en la pila de recursi\u00f3n entonces hay un ciclo en el \u00e1rbol, el camino que conecta el v\u00e9rtice actual a un v\u00e9rtice en la pila recursi\u00f3n es el camino de regreso, Usamos recStack[] para mantener rastreado los v\u00e9rtices de la pila de recursi\u00f3n.
artemis.biblioteca.grafos.cycledirected.texte       = La complejidad de tiempo de este m\u00e9todo es la misma complejidad de tiempo de un DFS transverso la cual es  O(V+E) siendo V la cantidad de v\u00e9rtices y E la cantidad de caminos.
artemis.biblioteca.grafos.dfs.texta                 = Una B\u00fasqueda en profundidad (en ingl\u00e9s DFS o Depth First Search) es un algoritmo de b\u00fasqueda no informada utilizado para recorrer todos los nodos de un grafo o \u00e1rbol (teor\u00eda de grafos) de manera ordenada, pero no uniforme. Su funcionamiento consiste en ir expandiendo todos y cada uno de los nodos que va localizando, de forma recurrente, en un camino concreto. Cuando ya no quedan m\u00e1s nodos que visitar en dicho camino, regresa (Backtracking), de modo que repite el mismo proceso con cada uno de los hermanos del nodo ya procesado.
artemis.biblioteca.grafos.dfs.textb                 = Completitud: DFS es completo si y solo si usamos b\u00fasqueda basada en grafos en espacios de estado finitos, pues todos los nodos ser\u00e1n expandidos.
artemis.biblioteca.grafos.dfs.textc                 = Optimalidad: DFS en ning\u00fan caso asegura la optimalidad, pues puede encontrar una soluci\u00f3n m\u00e1s profunda que otra en una rama que todav\u00eda no ha sido expandida.
artemis.biblioteca.grafos.dfs.textd                 = Complejidad temporal: en el peor caso, O(b^m) siendo b el factor de ramificaci\u00f3n (n\u00famero promedio de ramificaciones por nodo) y m la m\u00e1xima profundidad del espacio de estados.
artemis.biblioteca.grafos.dfs.texte                 = Complejidad espacial: O(b^d) siendo b el factor de ramificaci\u00f3n y d la profundidad de la soluci\u00f3n menos costosa, pues cada nodo generado permanece en memoria, almacen\u00e1ndose la mayor cantidad de nodos en el nivel meta.
artemis.biblioteca.grafos.dfs.textf                 = El tiempo de ejecuci\u00f3n es O(|V|+|E|)
artemis.biblioteca.grafos.dfstransitive.texta       = Dado un grafo dirigido, encontrar si un v\u00e9rtice v es alcanzable desde otro v\u00e9rtice u para todos los pares de v\u00e9rtices (u,v) en el grafo dado, aqu\u00ed alcanzable significa que existe un camino desde el v\u00e9rtice u a v, la matriz de habilidad de alcance es llamada cerramiento transitivo de un grafo.
artemis.biblioteca.grafos.dfstransitive.textb       = La soluci\u00f3n est\u00e1 basada en el algoritmo de Floyd Warshall, 
artemis.biblioteca.grafos.dfstransitive.textc       = Los pasos abstractos de este algoritmo son:
artemis.biblioteca.grafos.dfstransitive.textd       = -	Crear una matriz tc[V][V] que pueda tener finalmente el cerramiento transitivo de un grafo dado, inicializar todas sus entradas como 0.
artemis.biblioteca.grafos.dfstransitive.texte       = -	Llamar DFS por cada nodo del grado para marcar v\u00e9rtices alcanzables en tc[][]. En llamadas recursivas de DFS no podemos llamar DFS para un v\u00e9rtice adyacente si este ya fue marcado como alcanzable en tc[].
artemis.biblioteca.grafos.dfstransitive.textf       = El c\u00f3digo usa listas de adyacencia para el grafo de entrada y construye una matriz tc[V][V] tal que tc[u][v] ser\u00e1 true si v es alcanzable desde u.
artemis.biblioteca.grafos.disconnectedbfs.texta     = Por ejemplo asumamos que todos los v\u00e9rtices son alcanzables desde un v\u00e9rtice inicial, pero en el caso de un grafo desconexo o que cualquier v\u00e9rtice es inalcanzable desde todos os v\u00e9rtices, un BFS normal no nos da la salida deseada, por lo que se utiliza esta modificaci\u00f3n del BFS.
artemis.biblioteca.grafos.eulercycle.texta          = Un camino de Euler es un camino en un grafo que visita cada camino exactamente una vez, el circuito de Euler es un camino de Euler que empieza y termina en el mismo v\u00e9rtice.
artemis.biblioteca.grafos.eulercycle.textb          = Un grafo es euleriano si tiene un ciclo de Euler.
artemis.biblioteca.grafos.eulercycle.textc          = Un grafo dirigido tiene un ciclo de Euler si las siguientes condiciones son verdad:
artemis.biblioteca.grafos.eulercycle.textd          = 1)	Todos los v\u00e9rtices con grado no cero pertenecen a una sola componente fuertemente conectada.
artemis.biblioteca.grafos.eulercycle.texte          = 2)	En los grados, el grado de entrada es igual al grado de salida
artemis.biblioteca.grafos.eulercycle.textf          = Podemos detectar componentes fuertemente conectadas usando el DFS de Kosaraju.
artemis.biblioteca.grafos.eulercycle.textg          = Para comparar los grados de entrada y salida, necesitamos almacenar los grados de entrada y salida de cada v\u00e9rtice, el grado de salida puede ser obtenido por el tama\u00f1o de la lista de adyacencia, en grado de entrada puede ser almacenado creando un array de igual tama\u00f1o al n\u00famero de v\u00e9rtices.
artemis.biblioteca.grafos.eulercycle.texth          = La complejidad de tiempo de esta implementaci\u00f3n es de O(V+E), luego de correr el algoritmo de Kosaraju, atravesamos todos los v\u00e9rtices y comparamos los grados de salida y entrada, esto toma O(V) tiempo.
artemis.biblioteca.grafos.eulerianpthundirected.texta   =  \u00bfEs possible dibujar un grafo dado sin levantar el l\u00e1piz del papel y sin pasar por los caminos m\u00e1s de una vez?
artemis.biblioteca.grafos.eulerianpthundirected.textb   =  Un grafo es llamado euleriano si tiene un ciclo de Euler y es llamado semi-euleriano si tiene un camino de Euler, el problema es similar al camino Hamiltoniano, podemos verificar si un grafo es euleriano o no en tiempo polin\u00f3mico, de O(V+E).
artemis.biblioteca.grafos.eulerianpthundirected.textc   =  Las siguientes son propiedades interesantes de los grafos no dirigidos con un camino euleriano y ciclo, podemos usar esta propiedades para encontrar si un grafo es euleriano o no.
artemis.biblioteca.grafos.eulerianpthundirected.textd   =  Ciclo euleriano
artemis.biblioteca.grafos.eulerianpthundirected.texte   =  Un grafo no dirigido tiene un ciclo de Euler si las siguientes dos condiciones son ciertas:
artemis.biblioteca.grafos.eulerianpthundirected.textf   =  -	Todos los v\u00e9rtices con grado no cero estan conectados, no nos importa los v\u00e9rtices con grado cero porque no pertenecen a el ciclo de Euler o el camino, solo estamos considerando los caminos.
artemis.biblioteca.grafos.eulerianpthundirected.textg   =  -	Todos los v\u00e9rtices tienen grado par.
artemis.biblioteca.grafos.eulerianpthundirected.texth   =  Camino euleriano
artemis.biblioteca.grafos.eulerianpthundirected.texti   =  Un grafo no dirigido tiene un camino euleriano si las dos siguientes condiciones se cumplen:
artemis.biblioteca.grafos.eulerianpthundirected.textj   =  -	La misma primera condici\u00f3n de un ciclo de Euler
artemis.biblioteca.grafos.eulerianpthundirected.textk   =  -	Si dos v\u00e9rtices tienen grado impar y todos los dem\u00e1s v\u00e9rtices tienen grado par, note que solo un v\u00e9rtice con grado impar no es posible en un grafo no dirigido, la suma de todos los grados es siempre par en un grafo no dirigido.
artemis.biblioteca.grafos.eulerianpthundirected.textl   =  Note que un grafo sin caminos se considera euleriano porque no hay caminos que atravesar.
artemis.biblioteca.grafos.eulerianpthundirected.textm   =  En el camino euleriano, cada vez que visitamos un v\u00e9rtice v, nosotros caminamos a trav\u00e9s de dos caminos no visitados, con un punto de fin como v, por lo tanto todos los v\u00e9rtices medios en el camino euleriano deben tener grado par, para el ciclo euleriano cualquier v\u00e9rtice puede ser v\u00e9rtice medio, sin embargo todos los v\u00e9rtices deben tener grado par.
artemis.biblioteca.grafos.eulerianpthundirected.textn   =  La complejidad de tiempo es: O(V+E)
artemis.biblioteca.grafos.floydwarshall.texta           = El algoritmo de Floyd Warshall se usa para la resoluci\u00f3n de todos los caminos m\u00e1s cortos de todos los pares, el problema es encontrar las distancias m\u00e1s peque\u00f1as entre cada par de v\u00e9rtices dado un grafo de caminos con pesos.
artemis.biblioteca.grafos.floydwarshall.textb           = Inicializamos la matriz de la soluci\u00f3n igual que la matriz de entrada del grafo en el primer paso, luego actualizamos la matriz de soluci\u00f3n considerando todos los v\u00e9rtices en un v\u00e9rtice intermedio, la idea es uno por uno tomar todos los v\u00e9rtices y actualizar todos los caminos m\u00e1s cortos los cuales incluyen el v\u00e9rtice seleccionado como el v\u00e9rtice intermedio en el camino m\u00e1s corto. Cuando tomamos el v\u00e9rtice de n\u00famero k como un v\u00e9rtice intermedio ya estamos considerando v\u00e9rtices {0,1,2\u2026k-1} como intermedios, para cada par (i,j) del origen al destino respetivamente existen dos posibles casos.
artemis.biblioteca.grafos.floydwarshall.textc           = 1)	k no es un v\u00e9rtice intermedio en el camino m\u00e1s corto de i a j, mantenemos el valor de dist[i][j] como esta.
artemis.biblioteca.grafos.floydwarshall.textd           = 2)	K es un v\u00e9rtice intermedio en el camino m\u00e1s corto de i a j, actualizamos el valor de dist[i][j] como dist[i][k] + dist[k][j] if dist[i][j] > dist[i][k] + dist[k][j]
artemis.biblioteca.grafos.floydwarshall.texte           = La complejidad de tiempo es: O(V^3) o O(N^3).
artemis.biblioteca.grafos.floydwarshall.textf           = El programa solo imprime las distancias m\u00e1s cortas, podemos modificar la soluci\u00f3n para imprimir el camino m\u00e1s corto ordenando la informaci\u00f3n del predecesor en una matriz separada.
artemis.biblioteca.grafos.floydwarshall.textg           = El valor de INF puede ser tomado de INT_MAX o Integer.MAX_VALUE, lo que nos permite manejar el los valores m\u00e1ximos posibles.
artemis.biblioteca.grafos.hamilton.texta                = El camino Hamiltoniano de un grafo no dirigido es un camino que visita cada v\u00e9rtice exactamente una vez, un ciclo Hamiltoniano es un camino Hamiltoniano que tiene un camino desde el \u00faltimo v\u00e9rtice al primer v\u00e9rtice del camino Hamiltoniano, debemos determinar si un grafo tiene ciclo Hamiltoniano o no, si lo contiene imprimir el camino.
artemis.biblioteca.grafos.hamilton.textb                = Nuestra entrada ser\u00e1 un array graph[v][v] donde v es el n\u00famero de v\u00e9rtices en el grafo y graph[][] es la matriz de adyacencia representando el grafo, un valor graph[i][j] es 1 si existe un camino directo de I a j, de lo contrario ser\u00e1 0
artemis.biblioteca.grafos.hamilton.textc                = Nuestra salida ser\u00e1 un array path[v] que deber\u00e1 contener el camino Hamiltoniano, path[i] puede representar el iesimo v\u00e9rtice en el camino Hamiltoniano. El c\u00f3digo debe tambi\u00e9n retornar si no existe ciclo Hamiltoniano en el grafo.
artemis.biblioteca.grafos.hamilton.textd                = Se crea un array de camino vac\u00edo y se le agrega el v\u00e9rtice 0 a \u00e9l, se agregan los otros v\u00e9rtices iniciando desde el v\u00e9rtice 1, antes de a\u00f1adir un v\u00e9rtice, se verifica por cual es el adyacente del anterior a\u00f1adido y si no se ha a\u00f1adido ya, si encontramos tal v\u00e9rtice, a\u00f1adimos el v\u00e9rtice como parte de la soluci\u00f3n, si no lo encontramos retornamos false.
artemis.biblioteca.grafos.hamilton.texte                = Note que el c\u00f3digo siempre imprime el ciclo iniciando de 0, el punto de inicio no importa ya que el ciclo puede empezar de cualquier punto, si se quiere cambiar el punto de inicio, se deben hacer dos cambios al c\u00f3digo de abajo.
artemis.biblioteca.grafos.hamilton.textf                = Cambie  \u201cpath[0] = 0;\u201d por \u201cpath[0] = s;\u201d donde s es el nuevo punto de inicio, tambi\u00e9n cambie el ciclo \u201cfor (int v = 1; v < V; v++)" en hamCycleUtil() por "for (int v = 0; v < V; v++)".
artemis.biblioteca.grafos.kahn.texta                    = Ordenamiento topol\u00f3gico para un grafo dirigido aciclico (DAG) es un ordenamiento lineal de v\u00e9rtices el cual por cada camino dirigido UV, el v\u00e9rtice U viene antes de V en el ordenamiento, el ordenamiento topol\u00f3gico no es posible si el grafo no es un DAG.
artemis.biblioteca.grafos.kahn.textb                    = Los pasos de este algoritmo son los siguientes:
artemis.biblioteca.grafos.kahn.textc                    = 1)	Calcule los grados de entrada de cada v\u00e9rtice en el DAG presente e inicialice el conteo de los nodos visitados como 0.
artemis.biblioteca.grafos.kahn.textd                    = 2)	Tome todos los v\u00e9rtices con grado de entrada como o y agr\u00e9guelos en una cola
artemis.biblioteca.grafos.kahn.texte                    = 3)	Remueva un v\u00e9rtice de la cola y entonces incremente el conteo de nodos visitados por 1
artemis.biblioteca.grafos.kahn.textf                    = 4)	Decremente el grado de entrada en 1 en todos los nodos vecinos, si el grado de entrada de los nodos vecinos es cero, agr\u00e9guelos a la cola.
artemis.biblioteca.grafos.kahn.textg                    = 5)	Repita el paso 3 hasta que la cola este vac\u00eda.
artemis.biblioteca.grafos.kahn.texth                    = 6)	Si el conteo de nodos visitados no es igual al n\u00famero de notos en el grado entonces el ordenamiento topol\u00f3gico no es posible en este grafo.
artemis.biblioteca.grafos.kahn.texti                    = \u00bfC\u00f3mo encontrar el grado de entrada en cada nodo?
artemis.biblioteca.grafos.kahn.textj                    = Existen dos v\u00edas  para encontrar el grado de entrada de  cada nodo.
artemis.biblioteca.grafos.kahn.textk                    = Tomaremos un array de grado de entrada para mantener rastreo de estos.
artemis.biblioteca.grafos.kahn.textl                    = 1) Atraviese el array de nodos y simplemente incremente el conteo del nodo de destino en 1-
artemis.biblioteca.grafos.kahn.textm                    = for each node in Nodes
artemis.biblioteca.grafos.kahn.textn                    =     indegree[node] = 0;
artemis.biblioteca.grafos.kahn.texto                    = for each edge(src,dest) in Edges
artemis.biblioteca.grafos.kahn.textp                    =     indegree[dest]++
artemis.biblioteca.grafos.kahn.textq                    = 2) Atraviese la lista de cada nodo e incremente el grado de entrada de todos los nodos conectados con \u00e9l en 1
artemis.biblioteca.grafos.kahn.textr                    = for each node in Nodes
artemis.biblioteca.grafos.kahn.texts                    =         If (list[node].size()!=0) then
artemis.biblioteca.grafos.kahn.textt                    =        for each dest in list
artemis.biblioteca.grafos.kahn.textu                    =          indegree[dest]++;
artemis.biblioteca.grafos.kahn.textv                    = La complejidad de tiempo se da por: el ciclo externo ser\u00e1 ejecutado V n\u00famero de veces y el interno ser\u00e1 ejecutado E n\u00famero de veces, la complejidad resultante ser\u00e1 de O(V+E).
artemis.biblioteca.grafos.knighttour.texta              = El backtracking es un paradigma algor\u00edtmico que intenta diferentes soluciones hasta que encuentra una soluci\u00f3n que \u201cFunciona\u201d. Problemas los cuales son t\u00edpicamente resueltos con t\u00e9cnicas de backtracking tienen una propiedad en com\u00fan, estos problemas puede solo ser resueltos intentando cada posible configuraci\u00f3n y cada configuraci\u00f3n es intentada una sola vez, una soluci\u00f3n ingenua para estos problemas es intentar todas las configuraciones e imprimir una configuraci\u00f3n que siga las restricciones dadas por el problema. Backtracking funciona en forma incremental y es una optimizaci\u00f3n sobre las soluciones ingenuas donde todas las posibles configuraciones son generadas e intentadas.
artemis.biblioteca.grafos.knighttour.textb              = Backtracking funciona de forma incremental para atacar problemas, t\u00edpicamente iniciamos desde un vector de soluci\u00f3n vac\u00edo, y uno por uno vamos agregando \u00edtems, cuando agregamos un \u00edtem podemos verificar si agregando el siguiente \u00edtem violamos alguna de las restricciones del problema, si lo hace eliminamos ese elemento e intentamos otras alternativas. Si ninguna de las alternativas funciona entonces volvemos a la fase previa y removemos el \u00edtem anterior dado en la fase anterior. Si alcanzamos la fase inicial entonces decimos que no existe soluci\u00f3n, si agregamos un valor que no viola alguna restricci\u00f3n entonces recursivamente agregamos \u00edtems uno por uno, si el vector de soluci\u00f3n se completa imprimimos la soluci\u00f3n.
artemis.biblioteca.grafos.knighttour.textc              = El siguiente es el backtracking del problema del tour del caballo en el tablero de ajedrez.
artemis.biblioteca.grafos.knighttour.textd              = -	Si todos los cuadrados son visitados imprima la soluci\u00f3n
artemis.biblioteca.grafos.knighttour.texte              = - Si no 
artemis.biblioteca.grafos.knighttour.textf              = a)	Agregue uno de los siguientes movimientos posibles al vector de soluci\u00f3n y recursivamente verifique si este movimiento lleva a una soluci\u00f3n (Un caballo puede hacer m\u00e1ximo 8 movimientos, aqu\u00ed escogemos alguno de esos 8 movimientos).
artemis.biblioteca.grafos.knighttour.textg              = b)	Si el movimiento escogido arriba no lleva a una soluci\u00f3n entonces removemos este movimiento del vector de soluci\u00f3n e intentamos otros movimientos alternativos.
artemis.biblioteca.grafos.knighttour.texth              = c)	Si ninguna de las alternativas funciona, retornamos falso (Retornando falso podemos remover el anterior \u00edtem agregado en recursi\u00f3n y si el falso es retornado a la recursi\u00f3n inicial entonces no existe soluci\u00f3n.
artemis.biblioteca.grafos.kosarajudfs.texta             = Dado un grafo dirigido, encontrar si el grafo se encuentra fuertemente conectado o no, un grado es fuertemente conectado si hay un camino entre cualquier par de v\u00e9rtices.
artemis.biblioteca.grafos.kosarajudfs.textb             = Esto es f\u00e1cil para un grafo no dirigido, solo tenemos que hacer BFS y DFS comenzando desde cualquier v\u00e9rtice, si BFS o DFS visita todos los v\u00e9rtices, entonces el grado no dirigido dado est\u00e1 conectado, esta aproximaci\u00f3n no funciona con un grafo dirigido.
artemis.biblioteca.grafos.kosarajudfs.textc             = Una simple idea es usar un algoritmo de todos los caminos m\u00e1s cortos entre todos los pares como Floyd Warshall o encontrar el cerramiento transitivo del grafo, la complejidad de tiempo de este m\u00e9todo es de O (v^3).
artemis.biblioteca.grafos.kosarajudfs.textd             = Podemos tambi\u00e9n hacer DFS V veces iniciando desde cada v\u00e9rtice, si alguno de los DFS no visita todos los v\u00e9rtices entonces el grafo no es fuertemente conectado. Este algoritmo toma O (V*(V+E)) en complejidad de tiempo, el cual puede ser el mismo del cerramiento transitivo para un grafo denso.
artemis.biblioteca.grafos.kosarajudfs.texte             = Una mayor idea puede ser el algoritmo de componentes fuertemente conectadas (SCC), podemos encontrar todos los SCC en O (V+E) tiempo, si el n\u00famero de SCC es 1, entonces el grafo es fuertemente conectado, el algoritmo de SCC hace trabajo extra cuando busca todos los SCC.
artemis.biblioteca.grafos.kosarajudfs.textf             = El siguiente es un algoritmo simple basado en el DFS de Kosaraju el cual realiza dos DFS transversos en el grafo.
artemis.biblioteca.grafos.kosarajudfs.textg             = 1)	Inicializa todos los v\u00e9rtices como no visitados.
artemis.biblioteca.grafos.kosarajudfs.texth             = 2)	Hace un DFS transverso del grado iniciando desde cualquier v\u00e9rtice v, si este DFS transverso no visita todos los v\u00e9rtices, entonces retorna falso
artemis.biblioteca.grafos.kosarajudfs.texti             = 3)	Reversa todos los arcos (O encuentra transpuesta o reversa de grafo)
artemis.biblioteca.grafos.kosarajudfs.textj             = 4)	Marque todos los v\u00e9rtices como no visitados en el grafo reverso
artemis.biblioteca.grafos.kosarajudfs.textk             = 5)	Hacer un DFS transverso del grafo reversado iniciando desde el mismo v\u00e9rtice v, si el DFS transverso no visita todos los v\u00e9rtices entonces retorna falso, de otro modo retorna true.
artemis.biblioteca.grafos.kosarajudfs.textl             = La idea es, si cada nodo puede ser alcanzado de un v\u00e9rtice v, y cada nodo puede alcanzar v, entonces el grafo es fuertemente conectado. En el paso dos podemos verificar si todos los v\u00e9rtices son alcanzables desde v, en el paso 4 verificamos si todos los v\u00e9rtices puede alcanzar v (En el grafo reverso, si todos los v\u00e9rtices son alcanzables desde v entonces todos los v\u00e9rtices pueden alcanzar v en el grafo original).
artemis.biblioteca.grafos.kosarajudfs.textm             = La complejidad de tiempo de esta implementaciones es la misma de DFS, el cual es O (V+E) si el grafo est\u00e1 representado usando listas de adyacencia.
artemis.biblioteca.grafos.kruskal.texta                 = Dado un grafo conexo y no dirigido, un \u00e1rbol de expansi\u00f3n del grado es el subgrafo que es el \u00e1rbol que conecta todos los v\u00e9rtices juntos, un solo grafo puede tener muchos \u00e1rboles de expansi\u00f3n diferentes, un \u00e1rbol de expansi\u00f3n m\u00ednima (MST) o \u00e1rbol de expansi\u00f3n de peso m\u00ednimo para un grafo ponderado, conexo y no dirigido es el \u00e1rbol de expansi\u00f3n con el peso menos o igual a cualquier otro \u00e1rbol de expansi\u00f3n. El peso de un \u00e1rbol de expansi\u00f3n es la suma de los pesos dados en cada camino del \u00e1rbol de expansi\u00f3n.
artemis.biblioteca.grafos.kruskal.textb                 = \u00bfCuantos caminos tiene un \u00e1rbol de expansi\u00f3n m\u00ednima?
artemis.biblioteca.grafos.kruskal.textc                 = Un MST tiene (V-1) caminos donde V es el n\u00famero de v\u00e9rtices en el grafo dado.
artemis.biblioteca.grafos.kruskal.textd                 = Los siguientes son los pasos para encontrar el MST con el algoritmo de Kruskal.
artemis.biblioteca.grafos.kruskal.texte                 = 1)	ordene todos los caminos en orden incremental dado su peso.
artemis.biblioteca.grafos.kruskal.textf                 = 2)	Tome el camino m\u00e1s peque\u00f1o, verifique si forma un ciclo con el \u00e1rbol formado hasta ahora, si el ciclo no es formado, incluya este camino, si no desc\u00e1rtelo
artemis.biblioteca.grafos.kruskal.textg                 = 3)	Repita el paso 2 hasta que haya (V-1) caminos en el \u00e1rbol de expansi\u00f3n.
artemis.biblioteca.grafos.kruskal.texth                 = El algoritmo es un algoritmo voraz, la voracidad escogida es tomar el camino de tama\u00f1o m\u00e1s peque\u00f1o lo que no causa un ciclo en el MST construido hasta ese punto
artemis.biblioteca.grafos.kruskal.texti                 = La complejidad de tiempo de este algoritmo es de O(ElogE) or O(ElogV). Ordenar los caminos toma O(ELogE) tiempo, luego de ordenar iteramos a trav\u00e9s de todos los caminos y aplicamos el algoritmo Union-Find, Las operaciones de unir y encontrar puede tomar al menos O(LogV) tiempo, entonces la complejidad completa es O(ELogE + ELogV) tiempo. El valor de W puede ser al menos O (V^2) entonces O (LogV) son O (LogE) iguales. 
artemis.biblioteca.grafos.minmovesknight.texta          = Dado una mesa de ajedrez cuadrada de tama\u00f1o NxN, la posici\u00f3n de un caballo y la posici\u00f3n objetivo, necesitamos encontrar la m\u00ednima cantidad de pasos que un caballo toma para llegar a la posici\u00f3n objetivo.
artemis.biblioteca.grafos.minmovesknight.textb          = Este problema puede verse como el camino m\u00e1s corto en un grafo sin pesos, sin embargo usamos BFS \u00b4para resolver este problema, intentamos todos las 8 posibles posiciones donde un caballo puede llegar desde su posici\u00f3n, si la posici\u00f3n alcanzable no ha sido visitada ya y est\u00e1 dentro del tablero, agregamos este estado dentro de la cola con una distancia de 1 m\u00e1s que su estado padre, finalmente retornamos la distancia de la posici\u00f3n objetivo cuando sale de la cola.
artemis.biblioteca.grafos.minmovesknight.textc          = El siguiente c\u00f3digo implementa BFS para la b\u00fasqueda a trav\u00e9s de las celdas, donde cada celda contiene sus coordenadas y distancias desde el nodo inicial, en el peor de los casos el c\u00f3digo visita todas las celdas del tablero, haciendo que el la complejidad del peor de los casos sea O(n^2).
artemis.biblioteca.grafos.nqueen.texta                  = El problema de las N reinas es aquel en donde se colocan N reinas en un tablero de NxN de tal manera que dos reinas no puedan atacarse una con otra.
artemis.biblioteca.grafos.nqueen.textb                  = La idea es colocar reinas una por una en diferentes columnas, iniciando desde la columna de m\u00e1s a la izquierda, cuando colocamos una reina en una columna, verificamos por colisiones con las reinas ya colocadas, en la columna actual, si encontramos una fila en la cual no hay colisi\u00f3n marcamos esta columna y fila como parte de la soluci\u00f3n, si nosotros no encontramos tal fila en donde haya colisi\u00f3n entonces se retrocede y se retorna falso.
artemis.biblioteca.grafos.nqueen.textc                  = 1)	Iniciar desde la columna de m\u00e1s a la izquierda.
artemis.biblioteca.grafos.nqueen.textd                  = 2)	Si todas las reinas han sido colocadas, retornar true
artemis.biblioteca.grafos.nqueen.texte                  = 3)	Intentar todas las filas de la la columna actual
artemis.biblioteca.grafos.nqueen.textf                  = Realizar lo siguiente para cada columna intentada
artemis.biblioteca.grafos.nqueen.textg                  = a)	si la reina puede ser colocada seguramente en esta fila entonces marcar esta [fila, columna] como parte de la soluci\u00f3n y recursivamente verificar si colocando una reina aqu\u00ed se llega a la soluci\u00f3n.
artemis.biblioteca.grafos.nqueen.texth                  = b)	Si colocando una reina en [fila,columa] se llega a una soluci\u00f3n, entonces retorne true.
artemis.biblioteca.grafos.nqueen.texti                  = c)	Si colocando una reina no se llega a la soluci\u00f3n entonces desmarque esta fila y columna (Paso atr\u00e1s) y vaya al paso A para intentar otras filas.
artemis.biblioteca.grafos.nqueen.textj                  = 4)	Si todas las filas han sido probadas y ninguna funciona retorne falso para activar el backtracking.
artemis.biblioteca.grafos.primmst.texta                 = El algoritmo de Prim es tambi\u00e9n un algoritmo voraz, comienza con un \u00e1rbol de expansi\u00f3n vac\u00edo, la idea es mantener dos conjuntos de v\u00e9rtices, el primero contiene los v\u00e9rtices ya incluidos en el MST, la otra contiene los v\u00e9rtices que no han sido incluidos aun, en cada paso, se considera todos los caminos que conectan dos sets, y toma el camino con m\u00ednimo peso de esos caminos, luego de tomar el camino, se mueve el otro punto final del camino al set conteniendo el MST.
artemis.biblioteca.grafos.primmst.textb                 = Un grupo de caminos que conectan dos sets de v\u00e9rtices en un grafo es llamado corte en la teor\u00eda de grafos, entonces en cada paso del algoritmo de Prim, nosotros buscamos un corte (de dos conjuntos, uno contiene los v\u00e9rtices ya en el MST y el otro el resto de v\u00e9rtices), tome el camino de m\u00ednimo peso del corte e incluye este v\u00e9rtice al conjunto MST. 
artemis.biblioteca.grafos.primmst.textc                 = \u00bfC\u00f3mo funciona el algoritmo de Prim? La idea detr\u00e1s del algoritmo de Prim es simple, un \u00e1rbol de expansi\u00f3n significa que todos los v\u00e9rtices deben estar conectados, entonces los dos conjuntos disjuntos de v\u00e9rtices deben estar conectados para hacer un \u00e1rbol de expansi\u00f3n. Y ellos deben estar conectados con el camino de peso m\u00ednimo para realizar un \u00e1rbol de expansi\u00f3n m\u00ednima.
artemis.biblioteca.grafos.primmst.textd                 = 1)	Crear un set mstSet que mantenga rastro de los v\u00e9rtices ya incluidos en el MST.
artemis.biblioteca.grafos.primmst.texte                 = 2)	Asignar un valor key a todos los v\u00e9rtices en el grafo de entrada, inicializar los valores key como INFINITO, asignar el valor key como 0 para el primer v\u00e9rtice entonces este es tomado primero.
artemis.biblioteca.grafos.primmst.textf                 = 3)	Mientras mstSet no incluya todos los v\u00e9rtices.
artemis.biblioteca.grafos.primmst.textg                 = a)	Tomar un v\u00e9rtice u el cual no est\u00e9 en el mstSet y tenga el valor key m\u00ednimo
artemis.biblioteca.grafos.primmst.texth                 = b)	Incluir u al mstSet
artemis.biblioteca.grafos.primmst.texti                 = c)	Actualizar el valor key de todos los v\u00e9rtices adyacentes de u, para actualizar los valores key, se itera a trav\u00e9s de todos los v\u00e9rtices adyacentes v, si el peso del camino u-v es menos que el valor key anterior de v, actualice el valor key como peso de u-v.
artemis.biblioteca.grafos.primmst.textj                 = La idea de usar valores key es tomar el camino de m\u00ednimo peso como el corte, los valores key son usados \u00fanicamente por los v\u00e9rtices que no han sido incluidos en el MST, el valor key de estos v\u00e9rtices indican los caminos de peso m\u00ednimo conect\u00e1ndolos con el set de v\u00e9rtices incluidos en el MST.
artemis.biblioteca.grafos.primmst.textk                 = -	El set mstSet esta inicialmente vac\u00edo y los keys asignados a los v\u00e9rtices son {0, INF, INF, INF, INF, INF, INF, INF} donde INF indica infinito, ahora tomamos el v\u00e9rtices con el valor key menor el v\u00e9rtice 0 es tomado, se incluye en el mstSetm entonces mstSet se convierte en {0}, luego de incluir al mstSet, se actualizan los valores key de los v\u00e9rtices adyacentes, los v\u00e9rtices adyacentes  de 0 son 1 y 7, los valores key de 1 y 7 son actualizados como 4 y 8.
artemis.biblioteca.grafos.primmst.textl                 = -	Se toma el v\u00e9rtice con el menor valor key y no incluido ya en el MST, (no en mstSet), el v\u00e9rtice 1 es tomado y a\u00f1adido al mstSet por lo que se convierte en {0,1}, se actualiza los valores key de los v\u00e9rtices adyacentes de 1, el valor key del v\u00e9rtice 2 se convierte en 8.
artemis.biblioteca.grafos.primmst.textm                 = -	Se toma el v\u00e9rtice con el valor key m\u00ednimo y no incluido en MST, podemos tomar el v\u00e9rtice 7 o 2, tomaremos el 7, entonces el mstSet es {0,1,7}, actualizamos los valores key de los v\u00e9rtices adyacentes de 7, el valor key del v\u00e9rtice 6 y 8 se convierten en finitos, en 1 y 7.
artemis.biblioteca.grafos.primmst.textn                 = -	Tome el v\u00e9rtice con el valor key m\u00ednimo, y no incluido ya en MST, el v\u00e9rtice 6 es tomado entonces el mstSet se convierte en {0,1,7,6}, se actualizan los valores key y los v\u00e9rtices adyacentes de 6m el valor de 5 y 8 es actualizado.
artemis.biblioteca.grafos.primmst.texto                 = -     Repetimos los pasos de arriba hasta que mstSet incluya todos los v\u00e9rtices del grafo dado.
artemis.biblioteca.grafos.topologicalsort.texta         = Ordenamiento topol\u00f3gico de un grafo dirigido aciclico (DAG) es un ordenamiento lineal de v\u00e9rtices tales que por cada camino dirigido uv, el v\u00e9rtice u venga antes de v en el orden, si el grafo no es DAG no es posible el ordenamiento topol\u00f3gico.
artemis.biblioteca.grafos.topologicalsort.textb         = En DFS imprimimos un v\u00e9rtice y luego recursivamente llamamos DFS para los v\u00e9rtices adyacentes, en el ordenamiento topol\u00f3gico necesitamos imprimir un v\u00e9rtice antes de sus v\u00e9rtices adyacentes.
artemis.biblioteca.grafos.unionfind.texta               = Una estructura de datos para conjuntos disjuntos, es una estructura de datos que mantiene un conjunto de elementos particionados en un n\u00famero de conjuntos disjuntos no se solapan los conjuntos).Un algoritmo Uni\u00f3n-Buscar es un algoritmo que realiza dos importantes operaciones en esta estructura de datos:
artemis.biblioteca.grafos.unionfind.textb               = Buscar: Determina a cual subconjunto pertenece un elemento. Esta operaci\u00f3n puede usarse para verificar si dos elementos est\u00e1n en el mismo conjunto.
artemis.biblioteca.grafos.unionfind.textc               = Union: Une dos subconjuntos en uno solo.
artemis.biblioteca.grafos.unionfind.textd               = La otra operaci\u00f3n importante CrearConjunto es generalmente trivial, esta crea un conjunto con un elemento dado. Con estas tres operaciones, muchos problemas pr\u00e1cticos de particionamiento pueden ser resueltos.
artemis.biblioteca.grafos.unionfind.texte               = Con el fin de definir estas operaciones m\u00e1s precisamente, es necesario representar los conjuntos de alguna manera. Una aproximaci\u00f3n com\u00fan es seleccionar un elemento fijo de cada conjunto, llamado el representativo, para representar el conjunto como un todo. 
artemis.biblioteca.grafos.unionfind.textf               = Entonces Buscar(x) retorna el elemento representativo del conjunto al cual x pertenece, y Uni\u00f3n toma como argumento dos elementos representativos de dos conjuntos respectivamente.
artemis.biblioteca.grafos.dominodfs.texta               = El efecto domin\u00f3 o reacci\u00f3n en cadena es el efecto acumulativo producido cuando un acontecimiento origina una cadena de otros acontecimientos similares.
artemis.biblioteca.grafos.dominodfs.textb               = Se produce cuando un peque\u00f1o cambio origina un cambio similar a su lado, que a su vez causa otro similar, y as\u00ed sucesivamente en una secuencia lineal. Recibe este nombre, por analog\u00eda con la ca\u00edda de una hilera de fichas de domin\u00f3 colocadas en posici\u00f3n vertical. El efecto domin\u00f3 tambi\u00e9n puede hacer referencia a una cadena de acontecimientos no materiales.
artemis.biblioteca.grafos.dominodfs.textc               = El t\u00e9rmino, en sus distintos usos, se ha hecho popular por su analog\u00eda al efecto mec\u00e1nico, una fila de fichas de domin\u00f3 al caer una ficha detr\u00e1s de otra, aunque t\u00edpicamente se refiere a una secuencia enlazada de acontecimientos donde el tiempo entre acontecimientos sucesivos es relativamente peque\u00f1o. Puede ser utilizado literalmente (una serie observada de colisiones reales) o de forma metaf\u00f3rica (conexiones causales dentro de sistemas como la pol\u00edtica o las finanzas globales).
artemis.biblioteca.grafos.maze.texta                    = Un laberinto es un pasatiempo gr\u00e1fico consistente en trazar una l\u00ednea desde un punto de origen situado en el exterior de un laberinto a uno de destino situado generalmente en el centro o bien en el lado opuesto. La dificultad consiste en encontrar un camino directo hasta el lugar deseado. El laberinto, por su propia configuraci\u00f3n, contiene diferentes v\u00edas sin salida (de mayor o menor longitud) y solo un recorrido correcto.
artemis.biblioteca.grafos.bellmanfordsp.texta           = Dado un grafo y un v\u00e9rtice de origen src en el grafo, encontrar los caminos m\u00e1s cortos desde src a todos los v\u00e9rtices en el grafo dado, el grafo puede contener caminos con pesos negativos. Si hay un ciclo de peso negativo, entonces las distancias m\u00e1s cortas no son calculadas, se reporta el ciclo negativo.
artemis.biblioteca.grafos.bellmanfordsp.textb           = 1)	Este paso inicializa las distancias desde el origen de todos los v\u00e9rtices como infinito y la distancia al origen en si como 0, crea un array dist[] de tama\u00f1o V con todos los valores como infinito excepto dist[src] donde src es el v\u00e9rtice origen.
artemis.biblioteca.grafos.bellmanfordsp.textc           = 2)	Este paso calcula las distancias m\u00e1s cortas, esto se realiza V-1 veces.
artemis.biblioteca.grafos.bellmanfordsp.textd           = 3)	si dist[v] > dist[u] + peso del camino uv, entonces actualice dist[] en dist[v] = dist[u] + weight of edge uv
artemis.biblioteca.grafos.bellmanfordsp.texte           = 4)	Este paso verifica si hay un ciclo negativo en el grafo, se realiza lo siguiente:
artemis.biblioteca.grafos.bellmanfordsp.textf           = 5)	si dist[v] > dist[u] + peso del camino uv, entonces \u201cEl grafo contiene un ciclo negativo\u201d
artemis.biblioteca.grafos.bellmanfordsp.textg           = La idea del paso 3 es, el paso 2 garantiza las distancias m\u00e1s cortas si el grafo no contiene un ciclo de peso negativo, si iteramos a trav\u00e9s de todos los caminos una vez m\u00e1s y obtenemos un camino m\u00e1s corto para cualquier v\u00e9rtice, entonces  ah\u00ed hay un ciclo negativo.
artemis.biblioteca.grafos.bellmanfordsp.texth           = \u00bfC\u00f3mo funciona esto? Como en otros problemas de programaci\u00f3n din\u00e1mica, el algoritmo calcula los caminos m\u00e1s cortos de manera del atr\u00e1s hacia adelante, primero calcula las distancias m\u00e1s cortas las cuales tienen  al menos una arista en el camino, luego calcula los caminos m\u00e1s cortos con al menos dos aristas, y as\u00ed en adelante, luego de la iesima iteraci\u00f3n del ciclo exterior, los caminos m\u00e1s cortos con al menos i aristas son calculados, ah\u00ed puede haber un m\u00e1ximo de V-1 aristas en un camino simple, por eso el ciclo externo se corre V-1 veces, la idea es, asumiendo que ah\u00ed no hay ciclo negativo, si calculamos los caminos los caminos m\u00e1s cortos con al menos i aristas, entonces una interacci\u00f3n sobre todos las aristas garantiza darnos el camino m\u00e1s corto con al menos i+1 artistas.
artemis.biblioteca.grafos.bellmanfordsp.texti           = Ejemplo:
artemis.biblioteca.grafos.bellmanfordsp.textj           = Dado el v\u00e9rtice origen 0, inicializamos todas las distancias como infinito, excepto la distancia al origen mismo, el n\u00famero total de v\u00e9rtices en el grafo es 5 y todos los caminos deben ser procesados 4 veces.
artemis.biblioteca.grafos.bellmanfordsp.textk           = Todos las aristas son procesadas en el siguiente orden, (B, E), (D, B), (B, D), (A, B), (A, C), (D, C), (B, C), (E, D). Tenemos las siguientes distancias cuando todos las aristas son procesadas por primera vez, la primera fila 
artemis.biblioteca.grafos.bellmanfordsp.textl           = La primera iteraci\u00f3n garantiza darnos todos los caminos m\u00e1s cortos los cuales tienen un largo de una arista, obtenemos las distancias siguientes cuando todos las aristas son procesadas por segunda vez.
artemis.biblioteca.grafos.bellmanfordsp.textm           = La segunda iteraci\u00f3n garantiza darnos todos los caminos m\u00e1s cortos que sean de 2 aristas m\u00e1s larga, el algoritmo procesa los caminos 2 veces m\u00e1s, las distancias son minimizadas luego de la segunda iteraci\u00f3n, y la tercera y cuarta no actualiza distancias...
artemis.biblioteca.grafos.bellmanfordsp.textn           = 1)	Pesos negativos son encontrados en varias aplicaciones de grafos, por ejemplo en vez de pagar el costo por un camino, podemos obtener ventaja si seguimos el camino.
artemis.biblioteca.grafos.bellmanfordsp.texto           = 2)	Bellman-Ford trabaja mejor que Dijkstra para sistemas distribuidos, a diferencia de Dijkstra en donde necesitamos encontrar el valor menor de todos los v\u00e9rtices, en Bellman-Ford necesitamos considerar uno por uno.
artemis.biblioteca.grafos.dijkstrasp.texta              = Dado un grafo y un v\u00e9rtice origen en el grafo, encuentre los caminos m\u00e1s cortos del origen a todos los v\u00e9rtices en el grafo dado.
artemis.biblioteca.grafos.dijkstrasp.textb              = La complejidad de tiempo de esta implementaci\u00f3n es de O (V*E) si el grafo de entrada est\u00e1 representado usando una lista de adyacencia. Tener en cuenta que Dijkstra no procesa pesos negativos y no detecta ciclos negativos.
artemis.biblioteca.grafos.bipartite.texta               = Un grafo bipartito es un grafo cuyos v\u00e9rtices pueden ser divididos en dos sets independientes, U y V en donde cada arista (u, v) conecta un v\u00e9rtice de U a V o un v\u00e9rtice de V a U. En otras palabras para cada arista (u,v) u pertenece a U y v pertenece a V, o viceversa, tambi\u00e9n podemos decir que no hay aristas que conecte v\u00e9rtices del mismo set.
artemis.biblioteca.grafos.bipartite.textb               = Un grafo bipartito es posible si el coloramiento del grafo es posible usando dos colores los cuales los v\u00e9rtices de un set son coloreados del mismo color.
artemis.biblioteca.grafos.bipartite.textc               = Una aproximaci\u00f3n para verificar si un grafo es bipartito es verificar si el grafo es coloreable o no usando backtracking.
artemis.biblioteca.grafos.bipartite.textd               = El siguiente es un algoritmo simple de verificaci\u00f3n de bipartito usando  BFS.
artemis.biblioteca.grafos.bipartite.texte               = 1)	Asigna el color ROJO al v\u00e9rtice origen (Poni\u00e9ndolo en el set U)
artemis.biblioteca.grafos.bipartite.textf               = 2)	Colorea todos los vecinos con color AZUL (poni\u00e9ndolos en el set V)
artemis.biblioteca.grafos.bipartite.textg               = 3)	Colorear todos los vecinos del vecino anterior de color ROJO (Poni\u00e9ndolos en U)
artemis.biblioteca.grafos.bipartite.texth               = 4)	De esta forma se asigna color a todos los v\u00e9rtices los cuales satisfacen todas las restricciones del coloramiento.
artemis.biblioteca.grafos.bipartite.texti               = 5)	Mientras asignamos colores, si encontramos un vecino que esta coloreado del mismo color del actual v\u00e9rtice entonces el grafo no puede ser coloreado, es decir no es bipartito.
artemis.biblioteca.grafos.bipartite.textj               = El algoritmo solo funciona si el grafo es fuertemente conectado, en el c\u00f3digo siempre empezamos desde el origen 0 y asumimos que los v\u00e9rtices son visitados desde el, una observaci\u00f3n importante es un  grafo sin aristas es tambi\u00e9n bipartito, 
artemis.biblioteca.grafos.bipartite.textk               = La complejidad de tiempo de esta aproximaci\u00f3n es la misma del BFS, O(V^2) si el grafo es representado con listas de adyacencia, se convierte en O(V+E). 

#Biblioteca - otros
artemis.biblioteca.otros.knapsack.texta = Dados pesos y valores de n \u00edtems, ponga esos \u00edtems en una mochila de capacidad W, para obtener el m\u00e1ximo valor total en la mochila, en otras palabras dados dos arrays de enteros val[0..n-1] y wt[0\u2026-1] los cuales representan los valores y pesos asociados a los n \u00edtems respectivamente. Tambi\u00e9n dado un entero W el cual representa la capacidad de la mochila, encuentre el m\u00e1ximo valor subset de val[] tal que esa suma de los pesos de este subset es menor o igual a w, no se puede romper un \u00edtem, se tiene que tomar o no tomar, (propiedad 0-1).
artemis.biblioteca.otros.knapsack.textb = Una simple soluci\u00f3n es considerar todos los subsets de \u00edtems y calcular el peso total y valor de todos los subsets, considere solo los subsets los cuales el peso total es menor a W, de todos los subsets tome el que tenga el m\u00e1ximo valor de peso.
artemis.biblioteca.otros.knapsack.textc = Considere todos los subsets de \u00edtems, puede haber dos casos para cada \u00edtem:
artemis.biblioteca.otros.knapsack.texte = 1)	El \u00edtem est\u00e1 incluido en el subset optimo
artemis.biblioteca.otros.knapsack.textf = 2)	El \u00edtem no est\u00e1 incluido en el subset optimo
artemis.biblioteca.otros.knapsack.textg = Con esto, el m\u00e1ximo valor puede ser obtenido de n \u00edtems es m\u00e1ximo siguiendo los dos siguientes valores,
artemis.biblioteca.otros.knapsack.texth = 1)	El m\u00e1ximo valor obtenido por n-1 \u00edtems y peso W (Excluyendo el en\u00e9simo \u00edtem)
artemis.biblioteca.otros.knapsack.texti = 2)	Valor del en\u00e9simo \u00edtem m\u00e1s el m\u00e1ximo valor obtenido por n-1 \u00edtems y W menos el peso del en\u00e9simo \u00edtem (Incluyendo el en\u00e9simo \u00edtem).
artemis.biblioteca.otros.knapsack.textj = SI el peso del en\u00e9simo \u00edtem es mayor que W, entonces el en\u00e9simo \u00edtem no puede ser incluido y el caso 1 es la \u00fanica posibilidad.
artemis.biblioteca.otros.knapsack.textk = Desde que los subproblemas son evaluados de nuevo, este problema tiene la propiedad de sobreponer subproblemas. Entonces el problema de  la mochila 0-1 tiene ambas propiedades de un problema de programaci\u00f3n din\u00e1mica, como otros problemas de programaci\u00f3n din\u00e1mica, recomputaciones de subproblemas iguales pueden ser evadidos construyendo una matriz temporal desde el fondo, el c\u00f3digo usa esta metodolog\u00eda.
artemis.biblioteca.otros.knapsack.textl = La complejidad de tiempo de este algoritmo es de O(nW) donde n es el n\u00famero de \u00edtems y W el peso de la mochila.
artemis.biblioteca.otros.coin.texta = Dado un valor N, si queremos hacer el cambio de N centavos y tenemos suministros infinitos de cada uno de las S = {S1, S2,.., Sm} monedas con valor, \u00bfde cuantas formas podemos hacer el cambio? El orden de las monedas no importa
artemis.biblioteca.otros.coin.textb = Dado un valor N, queremos hacer el cambio por N centavos, y tenemos suministros de cada una, por  ejemplo, para N=4, y S={1,2,3}, existen 4 soluciones {1,1,1,1},{1,1,2},{2,2},{1,3}. 
artemis.biblioteca.otros.coin.textc = Entonces la salida debe ser 4, para N=10, y S={2,5,3,6} existen 6 soluciones {2,2,2,2,2}, {2,2,3,3}, {2,2,6}, {2,3,5} y {5,5}. Entonces la salida debe ser 5.
artemis.biblioteca.otros.coin.textd = Para contar el total el n\u00fameros de soluciones podemos dividir todos los sets soluci\u00f3n en dos sets.
artemis.biblioteca.otros.coin.texte = 1)	Soluciones que no contienen emesima moneda o Sm.
artemis.biblioteca.otros.coin.textf = 2)	Soluciones que al menos contienen una Sm.
artemis.biblioteca.otros.coin.textg = Dejaremos ser count(S[],m,n) la funci\u00f3n de conteo del n\u00famero de soluciones, luego estas pueden ser escritas como suma de count(S[], m-1, n) y count(S[], m, n-Sm).
artemis.biblioteca.otros.coin.texth = Por lo tanto, el problema tiene una propiedad se subestructura optima haciendo que el problema pueda ser resuelto usando soluciones a subproblemas.
artemis.biblioteca.otros.coin.texti = Complejidad de tiempo: O(mn)
artemis.biblioteca.otros.lis.texta = El problema de la  secuencia incremental m\u00e1s larga (LIS), es encontrar la longitud de la subsecuencia m\u00e1s larga dada una secuencia la cual todos los elementos de la subsecuencia est\u00e1n ordenados en orden ascendente, por ejemplo la longitud de a LIS para {10, 22, 9, 33, 21, 50, 41, 60, 80} es 6 y LIS es {10, 22, 33, 50, 60, 80}.
artemis.biblioteca.otros.lis.textb = Dejaremos arr [0...n-1] ser el array de entrada y L(i) ser la longitud de la LIS finalizando en el \u00edndice I tal que arr[i] es el \u00faltimo elemento de la LIS.
artemis.biblioteca.otros.lis.textc = Entonces L(i) puede ser recursivamente escrito como:
artemis.biblioteca.otros.lis.textd = L(i) = 1 + max( L(j) ) donde 0 < j < i y arr[j] < arr[i]; 
artemis.biblioteca.otros.lis.texte = o
artemis.biblioteca.otros.lis.textf = L(i) = 1, Si no existe tal j.
artemis.biblioteca.otros.lis.textg = Para encontrar la LIS de un array dado, necesitamos retornar max(L(i)) donde 0 < i < n.
artemis.biblioteca.otros.lis.texth = Por lo tanto vemos que el problema LIS satisface la propiedad de la subestructura \u00f3ptima como el problema principal puede ser resuelto usando soluciones a subproblemas.
artemis.biblioteca.otros.lis.texti = Note que la complejidad de tiempo de esta programaci\u00f3n din\u00e1mica es O(nLogn).
artemis.biblioteca.otros.lcs.texta = Dados dos strings X y Y encuentre el substring com\u00fan m\u00e1s largo. Dejaremos que M y N sean las longitudes del primer y segundo string respectivamente.
artemis.biblioteca.otros.lcs.textb = Una simple soluci\u00f3n es uno por uno considerar todos los substrings del primer string y por cada substring verificar su es un substring en el segundo substring, mantenemos rastro del string de longitud m\u00e1xima, ah\u00ed pueden haber O(m^2) substrings y podemos encontrar si un string es substring de otro string en tiempo O(n), entonces el tiempo general de este m\u00e9todo ser\u00e1 O(n * m2)
artemis.biblioteca.otros.lcs.textc = Programaci\u00f3n din\u00e1mica puede ser usada para encontrar el string com\u00fan m\u00e1s largo en O(n*m) tiempo, la idea es encontrar el sufijo com\u00fan m\u00e1s largo para todos los substrings de ambos strings y almacena estas longitudes en la tabla.
artemis.biblioteca.otros.lcs.textd = El sufijo com\u00fan m\u00e1s largo tiene propiedad de subestructura propia.
artemis.biblioteca.otros.lcs.texte = Si el \u00faltimo car\u00e1cter coincide, entonces reducimos ambas longitudes en 1.
artemis.biblioteca.otros.lcs.textf = -	LCSuff(X, Y, m, n) = LCSuff(X, Y, m-1, n-1) + 1 if X[m-1] = Y[n-1]
artemis.biblioteca.otros.lcs.textg = Si el \u00faltimo car\u00e1cter no coincide, entonces el resultado es 0, por ejemplo:
artemis.biblioteca.otros.lcs.texth = -	LCSuff(X, Y, m, n) = 0 if (X[m-1] != Y[n-1])
artemis.biblioteca.otros.lcs.texti = Ahora consideramos sufijos de diferentes substrings terminando en diferentes \u00edndices, el sufijo com\u00fan m\u00e1s largo, su longitud es el substring com\u00fan m\u00e1s largo.
artemis.biblioteca.otros.lcs.textj = -	LCSubStr(X, Y, m, n) = Max(LCSuff(X, Y, i, j)) donde 1 <= i <= m y 1 <= j <= n
artemis.biblioteca.otros.lcs.textk = Complejidad de tiempo: O(m*n)
artemis.biblioteca.otros.pascal.texta = El tri\u00e1ngulo de Pascal es un tri\u00e1ngulo de n\u00fameros enteros, infinito y sim\u00e9trico Se empieza con un 1 en la primera fila, y en las filas siguientes se van colocando n\u00fameros de forma que cada uno de ellos sea la suma de los dos n\u00fameros que tiene encima. Se supone que los lugares fuera del tri\u00e1ngulo contienen ceros, de forma que los bordes del tri\u00e1ngulo est\u00e1n formados por unos.
artemis.biblioteca.otros.pascal.texta = -	Los n\u00fameros del tri\u00e1ngulo de Pascal coinciden con los n\u00fameros combinatorios.
artemis.biblioteca.otros.pascal.texta = -	El n\u00famero combinatorio Cm n (n sobre m) se encuentra en el tri\u00e1ngulo en la fila n+1, en el lugar m+1. 
artemis.biblioteca.otros.pascal.texta = -	El n\u00famero combinatorio Cm n (n sobre m) que representa el n\u00famero de grupos de m elementos que pueden hacerse de entre un conjunto de n (por ejemplo, (4 sobre 2) nos da el n\u00famero de parejas distintas que podr\u00edan hacerse en un grupo de cuatro personas), se encuentra en el tri\u00e1ngulo en la fila n+1, en el lugar m+1. 
artemis.biblioteca.otros.pascal.texta = -	Podemos saber que el n\u00famero de parejas posibles que dec\u00edamos antes es 6 si miramos el tercer n\u00famero de la quinta fila. 
artemis.biblioteca.otros.pascal.texta = Esto hace que el tri\u00e1ngulo sea \u00fatil como representaci\u00f3n de estos n\u00fameros, y proporciona una buena forma de intuir sus propiedades.
artemis.biblioteca.otros.pascal.texta = -	La f\u00f3rmula general del llamado Binomio de Newton (a + b)n est\u00e1 formada por unos coeficientes que coinciden con la l\u00ednea n\u00famero n+1 del tri\u00e1ngulo de Pascal (la que empieza por 1 y n).
artemis.biblioteca.otros.pascal.texta = -	Si el primer elemento de una fila es un n\u00famero primo, todos los n\u00fameros de esa fila ser\u00e1n divisibles por \u00e9l (menos el 1, claro). As\u00ed, en la fila 7: (1 7 21 35 35 21 7 1), los n\u00fameros 7,21 y 35 son divisibles por 7.
artemis.biblioteca.otros.pascal.texta = -	La suma de los elementos de cualquier fila es el resultado de elevar 2 al n\u00famero que define a esa fila. 
artemis.biblioteca.otros.pascal.texta = -	La serie de Fibonacci puede ser encontrada tambi\u00e9n en el tri\u00e1ngulo de Pascal. Dividiendo al mismo seg\u00fan las l\u00edneas que mostramos en el diagrama, los n\u00fameros atrapados entre ellas suman cada uno de los elementos de esta sucesi\u00f3n.



























