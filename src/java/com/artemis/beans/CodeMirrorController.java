package com.artemis.beans;

import java.io.Serializable;
import javax.faces.bean.ManagedBean;
import javax.faces.bean.ViewScoped;

@ManagedBean(name = "codemirror")
@ViewScoped
public class CodeMirrorController implements Serializable {

    private String ciclosjava = "import java.io.BufferedReader;\n"
            + "import java.io.IOException;\n"
            + "import java.io.InputStreamReader;\n"
            + "import java.util.Scanner;\n"
            + "\n"
            + "public class LecturaEscritura {\n"
            + "//Variables Globales\n"
            + "    static int númeroentero;\n"
            + "    static long númeroenterolargo;\n"
            + "    static float númerodecimal;\n"
            + "    static double númerodecimallargo;\n"
            + "    static char caracter;\n"
            + "    static String cadena;\n"
            + "    static byte bits;\n"
            + "\n"
            + "    public static void main(String[] args) throws IOException {\n"
            + "System.out.println(\"Lectura\\n\");\n"
            + "        lecturaLenta();\n"
            + "        lecturaRapida();\n"
            + "        System.out.println(\"\");\n"
            + "        System.out.println(\"Impresión \\n\");\n"
            + "        impresionNormal();\n"
            + "        impresionConFormato();\n"
            + "}\n"
            + "\n"
            + "    static void lecturaLenta() {\n"
            + "//Objeto lector\n"
            + "        Scanner sc = new Scanner(System.in);\n"
            + "//Lectura con tipo especificado\n"
            + "        númeroentero = sc.nextInt();\n"
            + "númeroenterolargo = sc.nextLong();\n"
            + "        númerodecimal = sc.nextFloat();\n"
            + "        númerodecimallargo = sc.nextDouble();\n"
            + "        caracter = sc.next().charAt(0);\n"
            + "        cadena = sc.next();\n"
            + "        bits = sc.nextByte();\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    static void lecturaRapida() throws IOException {\n"
            + "//Objeto lector\n"
            + "        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n"
            + "//Lectura como cadena y conversión a tipo\n"
            + "        númeroentero = Integer.parseInt(br.readLine());\n"
            + "        númeroenterolargo = Long.parseLong(br.readLine());\n"
            + "        númerodecimal = Float.parseFloat(br.readLine());\n"
            + "númerodecimallargo = Double.parseDouble(br.readLine());\n"
            + "        caracter = br.readLine().charAt(0);\n"
            + "        cadena = br.readLine();\n"
            + "        bits = Byte.parseByte(br.readLine());\n"
            + "    }\n"
            + "\n"
            + "    static void impresionNormal() {\n"
            + "        System.out.println(númeroentero);\n"
            + "        System.out.println(númeroenterolargo);\n"
            + "        System.out.println(númerodecimal);\n"
            + "        System.out.println(númerodecimallargo);\n"
            + "        System.out.println(caracter);\n"
            + "        System.out.println(cadena);\n"
            + "        System.out.println(bits);\n"
            + "}\n"
            + "\n"
            + "    static void impresionConFormato() {\n"
            + "//Se especifica el tipo de dato o la forma en que se imprimira\n"
            + "        System.out.printf(\"%d \\n\",númeroentero);\n"
            + "        System.out.printf(\"%d \\n\",númeroenterolargo);\n"
            + "        System.out.printf(\"%f \\n\",númerodecimal);\n"
            + "        System.out.printf(\"%e \\n\",númerodecimal);\n"
            + "        System.out.printf(\"%f \\n\",númerodecimallargo);\n"
            + "        System.out.printf(\"%e \\n\",númerodecimallargo);\n"
            + "System.out.printf(\"%s \\n\",caracter);\n"
            + "        System.out.printf(\"%s \\n\",cadena);\n"
            + "        System.out.printf(\"%s \\n\",bits);\n"
            + "}\n"
            + "}";
    private String lecturajava = "import java.io.BufferedReader;\n"
            + "import java.io.IOException;\n"
            + "import java.io.InputStreamReader;\n"
            + "import java.util.Scanner;\n"
            + "\n"
            + "public class LecturaEscritura {\n"
            + "//Variables Globales\n"
            + "    static int númeroentero;\n"
            + "    static long númeroenterolargo;\n"
            + "    static float númerodecimal;\n"
            + "    static double númerodecimallargo;\n"
            + "    static char caracter;\n"
            + "    static String cadena;\n"
            + "    static byte bits;\n"
            + "\n"
            + "    public static void main(String[] args) throws IOException {\n"
            + "System.out.println(\"Lectura\\n\");\n"
            + "        lecturaLenta();\n"
            + "        lecturaRapida();\n"
            + "        System.out.println(\"\");\n"
            + "        System.out.println(\"Impresión \\n\");\n"
            + "        impresionNormal();\n"
            + "        impresionConFormato();\n"
            + "}\n"
            + "\n"
            + "    static void lecturaLenta() {\n"
            + "//Objeto lector\n"
            + "        Scanner sc = new Scanner(System.in);\n"
            + "//Lectura con tipo especificado\n"
            + "        númeroentero = sc.nextInt();\n"
            + "númeroenterolargo = sc.nextLong();\n"
            + "        númerodecimal = sc.nextFloat();\n"
            + "        númerodecimallargo = sc.nextDouble();\n"
            + "        caracter = sc.next().charAt(0);\n"
            + "        cadena = sc.next();\n"
            + "        bits = sc.nextByte();\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    static void lecturaRapida() throws IOException {\n"
            + "//Objeto lector\n"
            + "        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n"
            + "//Lectura como cadena y conversión a tipo\n"
            + "        númeroentero = Integer.parseInt(br.readLine());\n"
            + "        númeroenterolargo = Long.parseLong(br.readLine());\n"
            + "        númerodecimal = Float.parseFloat(br.readLine());\n"
            + "númerodecimallargo = Double.parseDouble(br.readLine());\n"
            + "        caracter = br.readLine().charAt(0);\n"
            + "        cadena = br.readLine();\n"
            + "        bits = Byte.parseByte(br.readLine());\n"
            + "    }\n"
            + "\n"
            + "    static void impresionNormal() {\n"
            + "        System.out.println(númeroentero);\n"
            + "        System.out.println(númeroenterolargo);\n"
            + "        System.out.println(númerodecimal);\n"
            + "        System.out.println(númerodecimallargo);\n"
            + "        System.out.println(caracter);\n"
            + "        System.out.println(cadena);\n"
            + "        System.out.println(bits);\n"
            + "}\n"
            + "\n"
            + "    static void impresionConFormato() {\n"
            + "//Se especifica el tipo de dato o la forma en que se imprimira\n"
            + "        System.out.printf(\"%d \\n\",númeroentero);\n"
            + "        System.out.printf(\"%d \\n\",númeroenterolargo);\n"
            + "        System.out.printf(\"%f \\n\",númerodecimal);\n"
            + "        System.out.printf(\"%e \\n\",númerodecimal);\n"
            + "        System.out.printf(\"%f \\n\",númerodecimallargo);\n"
            + "        System.out.printf(\"%e \\n\",númerodecimallargo);\n"
            + "System.out.printf(\"%s \\n\",caracter);\n"
            + "        System.out.printf(\"%s \\n\",cadena);\n"
            + "        System.out.printf(\"%s \\n\",bits);\n"
            + "}\n"
            + "}", lecturacpp = "//Unicas 2 librerias que se usan en c++ (Contienen todas)\n"
            + "#include<bits/stdc++.h>\n"
            + "#include<cstdlib>\n"
            + "using namespace std;\n"
            + "//variables globales\n"
            + "int númeroentero;\n"
            + "long númeroenterolargo;\n"
            + "float númerodecimal;\n"
            + "double númerodecimallargo;\n"
            + "char caracter;\n"
            + "string cadena;\n"
            + "\n"
            + "void lecturaLenta() {\n"
            + "	//Lectura con tipo especificado\n"
            + "	cin>>númeroentero;\n"
            + "	cin>>númeroenterolargo;\n"
            + "	cin>>númerodecimal;\n"
            + "	cin>>númerodecimallargo;\n"
            + "	cin>>caracter;\n"
            + "	cin>>cadena;\n"
            + "}\n"
            + "void lecturaRapida() {\n"
            + "	//Lectura como cadena y conversión a tipo (En c++ & es necesario)\n"
            + "	scanf(\"%d\",&númeroentero);\n"
            + "	scanf(\"%lld\",&númeroenterolargo);\n"
            + "	scanf(\"%f\",&númerodecimal);\n"
            + "	scanf(\"%lf\",&númerodecimallargo);\n"
            + "	scanf(\"%s\",&caracter);\n"
            + "	scanf(\"%s\",cadena.c_str());\n"
            + "}\n"
            + "void impresionNormal() {\n"
            + "	cout<<númeroentero<<endl;\n"
            + "	cout<<númeroenterolargo<<endl;\n"
            + "	cout<<númerodecimal<<endl;\n"
            + "	cout<<númerodecimallargo<<endl;\n"
            + "	cout<<caracter<<endl;\n"
            + "	cout<<cadena<<endl;\n"
            + "}\n"
            + " void impresionConFormato() {\n"
            + "	//Se especifica el tipo de dato o la forma en que se imprimira\n"
            + "	printf(\"%d \\n\",númeroentero);\n"
            + "	printf(\"%lld \\n\",númeroenterolargo);\n"
            + "	printf(\"%f \\n\",númerodecimal);\n"
            + "	printf(\"%e \\n\",númerodecimal);\n"
            + "	printf(\"%lf \\n\",númerodecimallargo);\n"
            + "	printf(\"%e \\n\",númerodecimallargo);\n"
            + "	printf(\"%c \\n\",caracter);\n"
            + "	printf(\"%s \\n\",cadena.c_str());\n"
            + "}\n"
            + "	\n"
            + "int main (int argc, char *argv[]) {\n"
            + "	cout<<\"Lectura\\n\"<<endl;\n"
            + "	lecturaLenta();\n"
            + "	cout<<\"Impresión \\n\"<<endl;\n"
            + "	impresionNormal();\n"
            + "	cout<<endl;\n"
            + "	cout<<\"Lectura\\n\"<<endl;\n"
            + "	lecturaRapida();\n"
            + "	cout<<\"Impresión \\n\"<<endl;\n"
            + "	impresionConFormato();\n"
            + "	return 0;\n"
            + "}	", lecturapy = "#Los comentarios en Python se usa el # (Numeral)\n"
            + "#variables globales\n"
            + "#la identación define el orden\n"
            + "númeroentero=int(0)\n"
            + "númeroenterolargo=int(0)\n"
            + "númerodecimal=float(0)\n"
            + "númerodecimallargo=float(0)\n"
            + "caracter=''\n"
            + "cadena=\"\"\n"
            + "print(\"Lectura\")\n"
            + "#Lectura con tipo especificado\n"
            + "númeroentero=int(input())\n"
            + "númeroenterolargo=int(input())\n"
            + "númerodecimal=float(input())\n"
            + "númerodecimallargo=float(input())\n"
            + "caracter=input()\n"
            + "cadena=str(input())\n"
            + "print(\"Impresión\")\n"
            + "print(númeroentero)\n"
            + "print(númeroenterolargo)\n"
            + "print(númerodecimal)\n"
            + "print(númerodecimallargo)\n"
            + "print(caracter)\n"
            + "print(cadena)\n"
            + "print(\"Impresión formateada\")\n"
            + "#Se especifica el tipo de dato o la forma en que se imprimira\n"
            + "#obligatorio usar el % \n"
            + "print(\"%d\" % númeroentero)\n"
            + "print(\"%d\" % númeroenterolargo)\n"
            + "print(\"%f\" %númerodecimal)\n"
            + "print(\"%e\"%númerodecimal)\n"
            + "print(\"%f\"%númerodecimallargo)\n"
            + "print(\"%e\"%númerodecimallargo)\n"
            + "print(\"%c\"%caracter)\n"
            + "print(\"%s\"%cadena)";
    private String condicionalesjava = "JAVA\n"
            + "import java.util.Scanner;\n"
            + "public class CondicionalesCiclos {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        Scanner sc = new Scanner(System.in);\n"
            + "//Lectura \n"
            + "int número = sc.nextInt();\n"
            + "//Estructura de un condicional\n"
            + "//Dentro el parentesis va la condicion a revisar\n"
            + "        //Si se cumple se realiza las siguientes lineas\n"
            + "        //En caso contrario pasa al else \n"
            + "        //y se realiza las lineas siguientes del else\n"
            + "        if (número % 2 == 0) {\n"
            + "            System.out.println(\"Es par\");\n"
            + "} else {\n"
            + "            System.out.println(\"Es impar\");\n"
            + "        }\n"
            + "        System.out.println(\"\");\n"
            + "        System.out.println(\"Ciclo for \");\n"
            + "// variable iteradora, condicion , acumulador\n"
            + "        for (int i = 0; i < 10; i++) {\n"
            + "            System.out.println(i);\n"
            + "        }\n"
            + "        System.out.println(\"Ciclo while\");\n"
            + "//Variable, condicion, al final acumulador\n"
            + "        int acumulador = 0;\n"
            + "        while (acumulador < 10) {\n"
            + "            System.out.println(acumulador);\n"
            + "            acumulador++;\n"
            + "\n"
            + "        }\n"
            + "        System.out.println(\"Ciclo do while\");\n"
            + "//Haga hasta que una condición se cumpla\n"
            + "        acumulador = 0;\n"
            + "        do {\n"
            + "            System.out.println(acumulador);\n"
            + "            acumulador++;\n"
            + "        } while (acumulador < 10);\n"
            + "        System.out.println(\"Ciclo for each\");\n"
            + "//Iterar entre todos los elementos que tenga una estructura\n"
            + "        //Sin importar el tamaño \n"
            + "        int números[] = {1,2,3,4,5,6,7,8,9,0};\n"
            + "for (int o : números) {\n"
            + "            System.out.println(o);\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "}", condicionalescpp = "#include<bits/stdc++.h>\n"
            + "#include<cstdlib>\n"
            + "using namespace std;\n"
            + "\n"
            + "int main (int argc, char *argv[]) {\n"
            + "	\n"
            + "	int número;\n"
            + "	cin>>número;\n"
            + "	//Estructura de un condicional\n"
            + "	//Dentro el parentesis va la condicion a revisar\n"
            + "	//Si se cumple se realiza las siguientes lineas\n"
            + "	//En caso contrario pasa al else \n"
            + "	//y se realiza las lineas siguientes del else\n"
            + "	if (número % 2 == 0) {\n"
            + "		cout<<\"Es par\"<<endl;\n"
            + "	} else {\n"
            + "		cout<<\"Es impar\"<<endl;\n"
            + "	}\n"
            + "	cout<<endl;\n"
            + "	cout<<\"Ciclo for \"<<endl;\n"
            + "	// variable iteradora, condicion , acumulador\n"
            + "	for (int i = 0; i < 10; i++) {\n"
            + "		cout<<i<<endl;\n"
            + "	}\n"
            + "	cout<<\"Ciclo while\"<<endl;\n"
            + "	//Variable, condicion, al final acumulador\n"
            + "	int acumulador = 0;\n"
            + "	while (acumulador < 10) {\n"
            + "		cout<<acumulador<<endl;;\n"
            + "		acumulador++;\n"
            + "		\n"
            + "	}\n"
            + "	cout<<\"Ciclo do while\"<<endl;\n"
            + "	//Haga hasta que una condición se cumpla\n"
            + "	acumulador = 0;\n"
            + "	do {\n"
            + "		cout<<acumulador<<endl;\n"
            + "		acumulador++;\n"
            + "	} while (acumulador < 10);\n"
            + "	cout<<\"Ciclo for each\"<<endl;\n"
            + "	//Iterar entre todos los elementos que tenga una estructura\n"
            + "	//Sin importar el tamaño \n"
            + "	int números[] = {1,2,3,4,5,6,7,8,9,0};\n"
            + "	for (int o : números) {\n"
            + "		cout<<o<<endl;\n"
            + "	}\n"
            + "	return 0;\n"
            + "}	", condicionalespy = "numero=0;\n"
            + "numero =int(input())\n"
            + "#Estructura de un condicional\n"
            + "#Dentro el parentesis va la condicion a revisar\n"
            + "#Si se cumple se realiza las siguientes lineas\n"
            + "#En caso contrario pasa al else \n"
            + "#y se realiza las lineas siguientes del else\n"
            + "if (numero % 2 == 0):\n"
            + "    print(\"Es par\")\n"
            + "else: \n"
            + "    print(\"Es impar\")\n"
            + "print(\"Ciclo for \")\n"
            + "#variable iteradora, rango inicio,final\n"
            + "for i in range (0,10):\n"
            + "    print(i)\n"
            + "print(\"Ciclo while\")\n"
            + "#Variable, condicion, al final acumulador\n"
            + "acumulador = 0;\n"
            + "while (acumulador < 10):\n"
            + "    print(acumulador)\n"
            + "    acumulador=acumulador+1;\n"
            + "print(\"Ciclo for each\")\n"
            + "#Iterar entre todos los elementos que tenga una estructura\n"
            + "#Sin importar el tamaño \n"
            + "numeros =[1,2,3,4,5,6,7,8,9,0]\n"
            + "for o in numeros:\n"
            + "    print(o)";
    private String excepcionesjava = "import java.util.Scanner;\n"
            + "public class ControlExcep {\n"
            + "    public static void main(String[] args) {\n"
            + "        Scanner sc = new Scanner(System.in);\n"
            + "int número;\n"
            + "//Intenta guardar el dato en la variable\n"
            + "        //Si falla controla la excepcion y \n"
            + "        //realiza otra cosa sin terminar la ejecución\n"
            + "try {\n"
            + "            número=sc.nextInt();\n"
            + "            System.out.println(número);\n"
            + "} catch (Exception e) {\n"
            + "            System.out.println(\"El dato insertado no es un número\");\n"
            + "            System.out.println(\"O es muy grande para un tipo int\");\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "}", excepcionespy = "número=0\n"
            + "#Intenta guardar el dato en la variable\n"
            + "#Si falla controla la excepción y \n"
            + "#realiza otra cosa sin terminar la ejecución\n"
            + "try:\n"
            + "    número=int(input())\n"
            + "    print (número)\n"
            + "except:\n"
            + "    print (\"El dato insertado no es un número\")\n"
            + "    print (\"O es muy grande para un tipo int\")\n"
            + "";
    private String tiempoejecucion = "/*Calculo del tiempo de ejecución de un ciclo de 100000 números\n"
            + "Varia de maquina en maquina, y dependiendo de lo que se \n"
            + "encuentre en ejecución en la maquina*/\n"
            + "public class CalculoTiempo {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        long timeBefore = System.currentTimeMillis();\n"
            + "        final int N =100000;\n"
            + "        for (int i = 0; i <= N; i++) {\n"
            + "            System.out.println(i);\n"
            + "        }\n"
            + "        long timeAfter = System.currentTimeMillis();\n"
            + "        System.out.println((timeAfter-timeBefore)+\"ms\");\n"
            + "}\n"
            + "}";
    private String estructurasjava = "import java.util.*;\n"
            + "\n"
            + "public class Main {\n"
            + "\n"
            + "    public static Random r = new Random();\n"
            + "    public static int i, j;\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        Scanner sc = new Scanner(System.in);\n"
            + "System.out.println(\"Inserte cantidad de datos\");\n"
            + "        int n = sc.nextInt();\n"
            + "        System.out.println(\"Que estructura quiere utilizar? (Los números son aleatorios\");\n"
            + "        System.out.println(\"1) Vector fijo \");\n"
            + "        System.out.println(\"2) Vector dinamico\");\n"
            + "        System.out.println(\"3) Vector sin repeticion\");\n"
            + "        System.out.println(\"4) Matriz\");\n"
            + "        System.out.println(\"5) Diccionario\");\n"
            + "        System.out.println(\"6) Pila\");\n"
            + "System.out.println(\"7) Cola\");\n"
            + "        int aux = sc.nextInt();\n"
            + "        switch (aux) {\n"
            + "            case 1:\n"
            + "                vectorfijo(n);\n"
            + "                break;\n"
            + "            case 2:\n"
            + "                vectordinamico(n);\n"
            + "                break;\n"
            + "            case 3:\n"
            + "                vectorsinrepeticion(n);\n"
            + "                break;\n"
            + "            case 4:\n"
            + "matriz(n);\n"
            + "                break;\n"
            + "            case 5:\n"
            + "                Diccionario(n);\n"
            + "break;\n"
            + "            case 6:\n"
            + "                pila(n);\n"
            + "                break;\n"
            + "            case 7:\n"
            + "                cola(n);\n"
            + "                break;\n"
            + "\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void vectordinamico(int n) {\n"
            + "        ArrayList<Integer> arreglo = new ArrayList<>();\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            arreglo.add(r.nextInt());\n"
            + "        }\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            System.out.println(arreglo.get(i));\n"
            + "\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    public static void vectorfijo(int n) {\n"
            + "        int[] números = new int[n];\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            números[i] = r.nextInt();\n"
            + "        }\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            System.out.println(números[i]);\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    public static void matriz(int n) {\n"
            + "        int[][] matrix = new int[n][n];\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            for (j = 0; j < n; j++) {\n"
            + "                matrix[i][j] = r.nextInt(50);\n"
            + "\n"
            + "            }\n"
            + "        }\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            for (j = 0; j < n; j++) {\n"
            + "                System.out.print(matrix[i][j] + \" \");\n"
            + "\n"
            + "            }\n"
            + "            System.out.println(\"\");\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void vectorsinrepeticion(int n) {\n"
            + "        HashSet<Integer> sinrep = new HashSet<>();\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            sinrep.add(r.nextInt(50));\n"
            + "        }\n"
            + "        Iterator it = sinrep.iterator();\n"
            + "        while (it.hasNext()) {\n"
            + "            System.out.println(it.next());\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void Diccionario(int n) {\n"
            + "        HashMap<Integer, String> dicc = new HashMap<>();\n"
            + "        char letra = 'a';\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            dicc.put(r.nextInt(), letra + \"\");\n"
            + "            int aux = (int) letra;\n"
            + "            aux++;\n"
            + "            letra = (char) aux;\n"
            + "        }\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            System.out.println(dicc.get(i) + \"\");\n"
            + "\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    public static void pila(int n) {\n"
            + "        Stack<Integer> mipila = new Stack<>();\n"
            + "\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            mipila.push(r.nextInt(50));\n"
            + "        }\n"
            + "        while (!mipila.isEmpty()) {\n"
            + "            System.out.println(mipila.pop());\n"
            + "\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    public static void cola(int n) {\n"
            + "        Queue<Integer> micola = new LinkedList<>();\n"
            + "\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            micola.offer(r.nextInt(50));\n"
            + "        }\n"
            + "        while (!micola.isEmpty()) {\n"
            + "            System.out.println(micola.poll());\n"
            + "\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "}", estructurascpp = "#include<bits/stdc++.h>\n"
            + "#include<cstdlib>\n"
            + "using namespace std;\n"
            + "\n"
            + "int i, j;\n"
            + "\n"
            + "void vectordinamico(int n) {\n"
            + "	vector<int> arreglo;\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		arreglo.push_back(rand()%100);\n"
            + "	}\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		cout<<arreglo.at(i)<<endl;\n"
            + "		\n"
            + "	}\n"
            + "	\n"
            + "}\n"
            + "\n"
            + "void vectorfijo(int n) {\n"
            + "	int números[n];\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		números[i] = rand()%100;\n"
            + "	}\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		cout<<números[i]<<endl;;\n"
            + "	}\n"
            + "	\n"
            + "}\n"
            + "\n"
            + "void matriz(int n) {\n"
            + "	int matrix [n][n];\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		for (j = 0; j < n; j++) {\n"
            + "			matrix[i][j] = rand()%100;\n"
            + "			\n"
            + "		}\n"
            + "	}\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		for (j = 0; j < n; j++) {\n"
            + "			cout<<matrix[i][j] << \" \";\n"
            + "			\n"
            + "		}\n"
            + "		cout<<endl;\n"
            + "	}\n"
            + "}\n"
            + "\n"
            + "void vectorsinrepeticion(int n) {\n"
            + "	set<int> sinrep;\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		sinrep.insert(rand()%100);\n"
            + "	}\n"
            + "	for (auto itr = sinrep.begin(); itr != sinrep.end(); ++itr) { \n"
            + "		cout<<*itr<<endl;\n"
            + "	} \n"
            + "}\n"
            + "\n"
            + "void Diccionario(int n) {\n"
            + "	map<int, char> dicc;\n"
            + "	char letra = 'a';\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		dicc.insert({rand()%100, letra});\n"
            + "		int aux = (int) letra;\n"
            + "		aux++;\n"
            + "		letra = (char) aux;\n"
            + "	}\n"
            + "	for (auto itr = dicc.begin(); itr != dicc.end(); ++itr) { \n"
            + "		cout << itr->first \n"
            + "			<< '\\t' << itr->second << '\\n'; \n"
            + "	} \n"
            + "	\n"
            + "}\n"
            + "\n"
            + "void pila(int n) {\n"
            + "	stack<int> mipila;\n"
            + "	\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		mipila.push(rand() % 100);\n"
            + "	}\n"
            + "	while (!mipila.empty()) {\n"
            + "		cout<<mipila.top()<<endl;\n"
            + "		mipila.pop();\n"
            + "	}\n"
            + "	\n"
            + "}\n"
            + "void cola(int n) {\n"
            + "	queue<int> micola;\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		micola.push(rand() % 100);\n"
            + "	}\n"
            + "	while (!micola.empty()) {\n"
            + "		cout<<micola.front()<<endl;\n"
            + "		micola.pop();\n"
            + "	}\n"
            + "	\n"
            + "}	\n"
            + "\n"
            + "\n"
            + "\n"
            + "\n"
            + "int main (int argc, char *argv[]) {\n"
            + "	cout<<\"Inserte cantidad de datos\"<<endl;\n"
            + "	int n ;\n"
            + "	cin>>n;\n"
            + "	cout<<\"Que estructura quiere utilizar? (Los números son aleatorios\"<<endl;\n"
            + "	cout<<\"1) Vector fijo \"<<endl;\n"
            + "	cout<<\"2) Vector dinamico\"<<endl;\n"
            + "	cout<<\"3) Vector sin repeticion\"<<endl;\n"
            + "	cout<<\"4) Matriz\"<<endl;\n"
            + "	cout<<\"5) Diccionario\"<<endl;\n"
            + "	cout<<\"6) Pila\"<<endl;\n"
            + "	cout<<\"7) Cola\"<<endl;\n"
            + "	int aux;\n"
            + "	cin>>aux;\n"
            + "	switch (aux) {\n"
            + "	case 1:\n"
            + "		vectorfijo(n);\n"
            + "		break;\n"
            + "	case 2:\n"
            + "		vectordinamico(n);\n"
            + "		break;\n"
            + "	case 3:\n"
            + "		vectorsinrepeticion(n);\n"
            + "		break;\n"
            + "	case 4:\n"
            + "		matriz(n);\n"
            + "		break;\n"
            + "	case 5:\n"
            + "		Diccionario(n);\n"
            + "		break;\n"
            + "	case 6:\n"
            + "		pila(n);\n"
            + "		break;\n"
            + "	case 7:\n"
            + "		cola(n);\n"
            + "		break;\n"
            + "		\n"
            + "	}\n"
            + "	return 0;\n"
            + "}	", estructuraspy = "from collections import deque\n"
            + "import random\n"
            + "def vector(n):\n"
            + "    arreglo=[]\n"
            + "    for i in (0,n):\n"
            + "	arreglo.append(random.randint(0,100))\n"
            + "	\n"
            + "    for i in (arreglo):\n"
            + "        print(i)\n"
            + "\n"
            + "def matriz(n):\n"
            + "    matrix = []\n"
            + "    for i in range(n):\n"
            + "        row = []\n"
            + "        for j in range(n):\n"
            + "            row.append(random.randint(0,100))\n"
            + "        matrix.append(row)\n"
            + "    for i in range(n):\n"
            + "        for j in range(n):\n"
            + "            print(matrix[i][j],end =\" \")\n"
            + "        print()    \n"
            + "\n"
            + "def vectorsinrepeticion(n):\n"
            + "    sinrep={0}\n"
            + "    for i in range(n):\n"
            + "        sinrep.add(random.randint(0,100))\n"
            + "    sinrep.remove(0)    \n"
            + "    for i in sinrep :\n"
            + "        print(i)\n"
            + "\n"
            + "def Diccionario( n):\n"
            + "    dicc={}\n"
            + "    valor = 0\n"
            + "for i in range(n):\n"
            + "dicc[random.randint(0,100)]= valor\n"
            + "        valor=valor+1\n"
            + "for x in dicc:\n"
            + "        print(str(x)+\":\"+str(dicc[x]))\n"
            + "	\n"
            + "def pila(n) :\n"
            + "    mipila=[]\n"
            + "    for i in range(n):\n"
            + "        mipila.append(random.randint(0,100))\n"
            + "    while(len(mipila)!=0):\n"
            + "        print(mipila.pop())\n"
            + "\n"
            + "def cola(n): \n"
            + "    micola=deque([])\n"
            + "    for i in range(n):\n"
            + "        micola.append(random.randint(0,100))\n"
            + "\n"
            + "    while(len(micola)!=0):\n"
            + "print(micola.popleft())\n"
            + "	\n"
            + "\n"
            + "\n"
            + "print(\"Inserte cantidad de datos\")\n"
            + "n=int(input())\n"
            + "#No existe switch en python\n"
            + "print(\"Vector\")\n"
            + "vector(n)\n"
            + "print(\"Vector sin repetición\")\n"
            + "vectorsinrepeticion(n)\n"
            + "print(\"Diccionario\")\n"
            + "Diccionario(n)\n"
            + "print(\"Pila\")\n"
            + "pila(n)\n"
            + "print(\"Cola\")\n"
            + "cola(n);\n"
            + "print(\"Matriz\")\n"
            + "matriz(n)";
    private String binarysearch = "// Implementación Java de una busqueda binaria recursiva \n"
            + "\n"
            + "public class BinarySearch {\n"
            + " /*Retorna el indice de x si se encuentra presente\n"
            + "    en arr[1,2,....r]*, si no retorna -1*/\n"
            + "static  int binarySearch(int arr[], int l, int r, int x) {\n"
            + "        if (r >= l) {\n"
            + "            int mid = l + (r - l) / 2;\n"
            + "/*Si el elemento esta presente en el medio*/\n"
            + "if (arr[mid] == x) {\n"
            + "                return mid;\n"
            + "}\n"
            + "/*Si el elemento es más pequeño que la mitad\n"
            + "            entonces solo puede estar presente en el \n"
            + "            subarreglo izquierdo*/\n"
            + "            if (arr[mid] > x) {\n"
            + "return binarySearch(arr, l, mid - 1, x);\n"
            + "}\n"
            + "//Si no el elemento solo pued estar presente \n"
            + "            //en el subarreglo derecho \n"
            + "            return binarySearch(arr, mid + 1, r, x);\n"
            + "        }\n"
            + "//Si llegamos aqui, el elemento no esta presente\n"
            + "//en el arreglo\n"
            + "        return -1;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        int arr[] = {2, 3, 4, 10, 40};\n"
            + "        int n = arr.length;\n"
            + "        int x = 10;\n"
            + "        int result = binarySearch(arr, 0, n - 1, x);\n"
            + "        if (result == -1) {\n"
            + "            System.out.println(\"Elemento no presente\");\n"
            + "} else {\n"
            + "            System.out.println(\"Element encontrado en la posición \" + result);\n"
            + "        }\n"
            + "    }\n"
            + "}";
    private String exponentialsearch = "//Programa Java para encontrar un elemento\n"
            + "//x en un array ordenado usando Exponential Search\n"
            + "\n"
            + "import java.util.Arrays;\n"
            + "\n"
            + "public class ExponentialSearch {\n"
            + "\n"
            + "/* Retorna posición de la primerra ocurrencia \n"
            + "    de x en un arreglo*/\n"
            + "static int exponentialSearch(int arr[],\n"
            + "int n, int x) {\n"
            + "// Si z esta presente en la primera localización en si misma\n"
            + "        if (arr[0] == x) {\n"
            + "            return 0;\n"
            + "        }\n"
            + "/*Encuentra ranfo para la busqueda binaria\n"
            + "        por repetidos dobles*/\n"
            + "        int i = 1;\n"
            + "while (i < n && arr[i] <= x) {\n"
            + "i = i * 2;\n"
            + "        }\n"
            + "//llama la busqueda binaria para el rango encontrado \n"
            + "return Arrays.binarySearch(arr, i / 2,\n"
            + "                Math.min(i, n), x);\n"
            + "    }\n"
            + "    public static void main(String args[]) {\n"
            + "        int arr[] = {2, 3, 4, 10, 40};\n"
            + "        int x = 10;\n"
            + "        int result = exponentialSearch(arr, arr.length, x);\n"
            + "\n"
            + "System.out.println((result < 0)\n"
            + "                ? \"El elemento no esta presente en el array\"\n"
            + "                : \"Elemento encontrado en : \"\n"
            + "                + result);\n"
            + "    }\n"
            + "}";
    private String arraymaxminsearch = "/* Programa Java que busca el maximo y el minimo\n"
            + "en un array*/\n"
            + "public class ArrayMaxMinSearch { \n"
            + "/*Clase Pair es usada para retornar\n"
            + "dos valores de getMinMax()*/\n"
            + "    static class Pair { \n"
            + "\n"
            + "        int min; \n"
            + "        int max; \n"
            + "    } \n"
            + "\n"
            + "    static Pair getMinMax(int arr[], int n) { \n"
            + "        Pair minmax = new  Pair(); \n"
            + "        int i; \n"
            + "/*Si es el unico elemento, lo retorna como min y max*/\n"
            + "if (n == 1) { \n"
            + "            minmax.max = arr[0]; \n"
            + "            minmax.min = arr[0]; \n"
            + "            return minmax; \n"
            + "} \n"
            + "/*Si hay más de un elemento, \n"
            + "        entones inicializa min y más*/\n"
            + "if (arr[0] > arr[1]) { \n"
            + "            minmax.max = arr[0]; \n"
            + "            minmax.min = arr[1]; \n"
            + "        } else { \n"
            + "            minmax.max = arr[1]; \n"
            + "            minmax.min = arr[0]; \n"
            + "        } \n"
            + "        for (i = 2; i < n; i++) { \n"
            + "            if (arr[i] > minmax.max) { \n"
            + "                minmax.max = arr[i]; \n"
            + "            } else if (arr[i] < minmax.min) { \n"
            + "                minmax.min = arr[i]; \n"
            + "            } \n"
            + "        } \n"
            + "        return minmax; \n"
            + "    } \n"
            + "    public static void main(String args[]) { \n"
            + "        int arr[] = {1000, 11, 445, 1, 330, 3000}; \n"
            + "        int arr_size = 6; \n"
            + "        Pair minmax = getMinMax(arr, arr_size); \n"
            + "System.out.printf(\"\\nEl minimo elemento es %d\", minmax.min); \n"
            + "        System.out.printf(\"\\nEl maximo elemento es %d\", minmax.max); \n"
            + "    } \n"
            + "}";
    private String fibonaccisearch = "// Programa Java para Fibonacci Search  \n"
            + "\n"
            + "public class FibonacciSearch {\n"
            + "\n"
            + "//Función de utilidad para biscar el minimo\n"
            + "    //de dos elementos\n"
            + "    public static int min(int x, int y) {\n"
            + "        return (x <= y) ? x : y;\n"
            + "    }\n"
            + "\n"
            + "    /* Regresa el indice de x si esta presente, si no retorna -1*/\n"
            + "public static int fibMonaccianSearch(int arr[],\n"
            + "int x, int n) {\n"
            + "/* Inicializa los números fibonacci*/\n"
            + "        int fibMMm2 = 0; // (m-2)esimo número fibonacci. \n"
            + "        int fibMMm1 = 1; // (m-1)esimo número fibonacci. \n"
            + "        int fibM = fibMMm2 + fibMMm1; // mesimo fibonacci.\n"
            + "/* FibM va a ser almacenado como el más pequeño\n"
            + "        fibonacci más grande o igual a n*/\n"
            + "while (fibM < n) {\n"
            + "            fibMMm2 = fibMMm1;\n"
            + "            fibMMm1 = fibM;\n"
            + "            fibM = fibMMm2 + fibMMm1;\n"
            + "}\n"
            + "// Marca el rango eliminado del frente\n"
            + "        int offset = -1;\n"
            + "/* Si bien hay elementos a inspeccionar.\n"
            + "        Tenga en cuenta que comparamos arr [fibMm2] con x.\n"
            + "        Cuando fibM se convierte en 1, fibMm2 se convierte en 0 */\n"
            + "        while (fibM > 1) {\n"
            + "//Revisa si fibMm2 es una ubicación valida\n"
            + "int i = min(offset + fibMMm2, n - 1);\n"
            + "/*Si x es más grande que el valor\n"
            + "            en el indice fibMm2, fuera del subarray\n"
            + "desde offset a i*/\n"
            + "            if (arr[i] < x) {\n"
            + "                fibM = fibMMm1;\n"
            + "                fibMMm1 = fibMMm2;\n"
            + "                fibMMm2 = fibM - fibMMm1;\n"
            + "offset = i;\n"
            + "            } /*Si x es más grande que el valor en indice \n"
            + "            fibMm2, corta el subarreglo despues de i+1*/ \n"
            + "else if (arr[i] > x) {\n"
            + "                fibM = fibMMm2;\n"
            + "                fibMMm1 = fibMMm1 - fibMMm2;\n"
            + "fibMMm2 = fibM - fibMMm1;\n"
            + "            } /* Elemento encontrado, retorna indice*/ \n"
            + "		else {\n"
            + "                return i;\n"
            + "            }\n"
            + "        }\n"
            + "/* Comparando el ultimo elemento con x*/\n"
            + "if (fibMMm1 == 1 && arr[offset + 1] == x) {\n"
            + "return offset + 1;\n"
            + "        }\n"
            + "/*Elemento no encontrado, retorna -1*/\n"
            + "return -1;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int arr[] = {10, 22, 35, 40, 45, 50,\n"
            + "            80, 82, 85, 90, 100};\n"
            + "        int n = 11;\n"
            + "        int x = 85;\n"
            + "        System.out.println(\"Found at index: \"\n"
            + "+ fibMonaccianSearch(arr, x, n));\n"
            + "    }\n"
            + "}";
    private String jumpsearch = "//Programa Java que implementa Jump Search\n"
            + "public class JumpSearch {\n"
            + "\n"
            + "    public static int jumpSearch(int[] arr, int x) {\n"
            + "int n = arr.length;\n"
            + "//Buscando el tamaño del bloque que sera\n"
            + "//saltado\n"
            + "        int step = (int) Math.floor(Math.sqrt(n));\n"
            + "/* Buscando el bloque donde el elemento\n"
            + "        esta presente (Si esta presente)*/\n"
            + "int prev = 0;\n"
            + "        while (arr[Math.min(step, n) - 1] < x) {\n"
            + "            prev = step;\n"
            + "            step += (int) Math.floor(Math.sqrt(n));\n"
            + "if (prev >= n) {\n"
            + "                return -1;\n"
            + "            }\n"
            + "        }\n"
            + "/*Realizando una busqueda linear para x en \n"
            + "        el bloque empezando con prev*/\n"
            + "while (arr[prev] < x) {\n"
            + "            prev++;\n"
            + "/*Si nosotros alcanzamos el siguiente bloque\n"
            + "            o el fin del array el elemento no esta presente*/\n"
            + "if (prev == Math.min(step, n)) {\n"
            + "return -1;\n"
            + "            }\n"
            + "        }\n"
            + "// Si el elemento fue encontrado\n"
            + "if (arr[prev] == x) {\n"
            + "            return prev;\n"
            + "        }\n"
            + "        return -1;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "int arr[] = {0, 1, 1, 2, 3, 5, 8, 13, 21,\n"
            + "            34, 55, 89, 144, 233, 377, 610};\n"
            + "        int x = 55;\n"
            + "//Encontrar el indice de 'x' usando Jump Search\n"
            + "int index = jumpSearch(arr, x);\n"
            + "// Imprime el indice donde x fue encontrado\n"
            + "        System.out.println(\"\\nNúmero \" + x\n"
            + "                + \" esta en el indice \" + index);\n"
            + "    }\n"
            + "}";
    private String minabssumpair = "//Programa JAVA que busque el par de números\n"
            + "//que sumados de la minima suma absoluta\n"
            + "\n"
            + "public class MinAbsSumPair {\n"
            + "//función que busca el par \n"
            + "static void minAbsSumPair(int arr[], int arr_size) {\n"
            + "        int inv_count = 0;\n"
            + "        int l, r, min_sum, sum, min_l, min_r;\n"
            + "/*El array debe tener al menos 2 elementos*/\n"
            + "if (arr_size < 2) {\n"
            + "            System.out.println(\"Invalid Input\");\n"
            + "return;\n"
            + "        }\n"
            + "/* Inicialización de los valores*/\n"
            + "min_l = 0;\n"
            + "        min_r = 1;\n"
            + "        min_sum = arr[0] + arr[1];\n"
            + "        for (l = 0; l < arr_size - 1; l++) {\n"
            + "            for (r = l + 1; r < arr_size; r++) {\n"
            + "                sum = arr[l] + arr[r];\n"
            + "                if (Math.abs(min_sum) > Math.abs(sum)) {\n"
            + "                    min_sum = sum;\n"
            + "                    min_l = l;\n"
            + "min_r = r;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        System.out.println(\" Los dos elementos los cuales \"\n"
            + "                + \"tienen la suma minima son \"\n"
            + "                + arr[min_l] + \" y \" + arr[min_r]);\n"
            + "}\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "int arr[] = {1, 60, -10, 70, -80, 85};\n"
            + "        minAbsSumPair(arr, 6);\n"
            + "    }\n"
            + "\n"
            + "}";
    private String missingnosearch = "//Programa java para buscar el número perdido\n"
            + "//usando xor\n"
            + "public class MissingNoSearch {\n"
            + "//Función que busca el número perdido\n"
            + "static int getMissingNo(int a[], int n) {\n"
            + "int x1 = a[0];\n"
            + "        int x2 = 1;\n"
            + "/*For XOR para todos los elementos \n"
            + "del arreglo*/\n"
            + "        for (int i = 1; i < n; i++) {\n"
            + "x1 = x1 ^ a[i];\n"
            + "        }\n"
            + "/* For xor de todos los elementos de 1 a n+1 */\n"
            + "for (int i = 2; i <= n + 1; i++) {\n"
            + "x2 = x2 ^ i;\n"
            + "        }\n"
            + "        return (x1 ^ x2);\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        int a[] = {1, 2, 3, 4, 5, 7, 8};\n"
            + "        int miss = getMissingNo(a, 7);\n"
            + "System.out.println(miss);\n"
            + "    }\n"
            + "}";
    private String pairdifferrencesearch = "// Programa Java para buscar un par\n"
            + "// Dada una diferencia\n"
            + "public class PairDifferenceSearch {\n"
            + "//La función asume que el array esta ordenado\n"
            + "static boolean findPair(int arr[], int n) {\n"
            + "int size = arr.length;\n"
            + "// Inicializa la posición de dos elementos\n"
            + "        int i = 0, j = 1;\n"
            + "// Busca por el par\n"
            + "while (i < size && j < size) {\n"
            + "            if (i != j && arr[j] - arr[i] == n) {\n"
            + "                System.out.print(\"Par Encontrado: \"\n"
            + "                        + \"( \" + arr[i] + \", \" + arr[j] + \" )\");\n"
            + "                return true;\n"
            + "            } else if (arr[j] - arr[i] < n) {\n"
            + "j++;\n"
            + "            } else {\n"
            + "                i++;\n"
            + "            }\n"
            + "        }\n"
            + "//No encuentra el par\n"
            + "        System.out.print(\"No hay tal par\");\n"
            + "return false;\n"
            + "    }\n"
            + "    public static void main(String[] args) {\n"
            + "        int arr[] = {1, 8, 30, 40, 100};\n"
            + "        int n = 60;\n"
            + "        findPair(arr, n);\n"
            + "}\n"
            + "}";
    private String ternarysearch = "//Programa Java para ilustrar \n"
            + "//recursivamente la aproximación\n"
            + "//de una busqueda ternaria\n"
            + "\n"
            + "public class TernarySearch {\n"
            + "\n"
            + "//Función que realiza la busqueda ternaria\n"
            + "static int ternarySearch(int l, int r, int key, int ar[]) {\n"
            + "if (r >= l) {\n"
            + "//encontrar el mid1 y mid 2\n"
            + "int mid1 = l + (r - l) / 3;\n"
            + "            int mid2 = r - (r - l) / 3;\n"
            + "//Verificar si la key esta presente en algun medio\n"
            + "if (ar[mid1] == key) {\n"
            + "                return mid1;\n"
            + "            }\n"
            + "            if (ar[mid2] == key) {\n"
            + "                return mid2;\n"
            + "}\n"
            + "/*Desde que la key no este presente en el mid\n"
            + "            verifica en cada region si esta presente\n"
            + "            luego repite la operación de busqueda\n"
            + "            en esa región*/\n"
            + "            if (key < ar[mid1]) {\n"
            + "//La key yace entre 1 y mid1\n"
            + "return ternarySearch(l, mid1 - 1, key, ar);\n"
            + "            } else if (key > ar[mid2]) {\n"
            + "//La key yace entre mid2 y r\n"
            + "return ternarySearch(mid2 + 1, r, key, ar);\n"
            + "} else {\n"
            + "//La key  yace entre mid 1 y mid 2\n"
            + "return ternarySearch(mid1 + 1, mid2 - 1, key, ar);\n"
            + "            }\n"
            + "        }\n"
            + "// key no encontrada\n"
            + "        return -1;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "int l, r, p, key;\n"
            + "//Cree el array y ordenelo si no lo está\n"
            + "        int ar[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n"
            + "// Indice inicial\n"
            + "        l = 0;\n"
            + "// Tamaño del arreglo \n"
            + "        r = 9;\n"
            + "// Buscando por el 5\n"
            + "        // key que va a ser buscada en el array\n"
            + "key = 5;\n"
            + "// Busca usando Ternary Search\n"
            + "        p = ternarySearch(l, r, key, ar);\n"
            + "// Imprime el resultado\n"
            + "        System.out.println(\"Indice de \" + key + \" es \" + p);\n"
            + "// Buscando por el 50\n"
            + "        // Key a ser buscada en el array\n"
            + "key = 50;\n"
            + "// Buscar usando Ternary Search\n"
            + "        p = ternarySearch(l, r, key, ar);\n"
            + "// Imprime el resultado \n"
            + "        System.out.println(\"Index of \" + key + \" is \" + p);\n"
            + "}\n"
            + "}";
    private String recursivebubblesort = "//Programa java que realiza Bubble Sort Recursivo\n"
            + "import java.util.Arrays; \n"
            + "\n"
            + "public class RecursiveBubbleSort  \n"
            + "{ \n"
            + "\n"
            + "    static void bubbleSort(int arr[], int n) \n"
            + "    { \n"
            + "// Caso base\n"
            + "        if (n == 1) \n"
            + "            return; \n"
            + "//Un paso de Bubble Sort, luego de este\n"
            + "       //paso, el elemento más largo es movido\n"
            + "//  hasta el final\n"
            + "        for (int i=0; i<n-1; i++) \n"
            + "            if (arr[i] > arr[i+1]) \n"
            + "            {   //intercambia arr[i], arr[i+1] \n"
            + "                int temp = arr[i]; \n"
            + "                arr[i] = arr[i+1]; \n"
            + "                arr[i+1] = temp; \n"
            + "            } \n"
            + "        bubbleSort(arr, n-1); \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        int arr[] = {64, 34, 25, 12, 22, 11, 90};\n"
            + "  bubbleSort(arr, arr.length);\n"
            + "        System.out.println(\"Array ordenado : \"); \n"
            + "        System.out.println(Arrays.toString(arr)); \n"
            + "} \n"
            + "}";
    private String quicksort = "// Programa java para la implementación de QuickSort\n"
            + "\n"
            + "public class QuickSort {\n"
            + "\n"
            + "    /* Esta función toma el ultimo elemento como\n"
            + "    pivote, coloca el pivote en la posición correcta\n"
            + "    en el array ordenado, y coloca todos los más \n"
            + "    pequeñps (Más pequeños que el pivote) a la izquierda\n"
            + "    del pivote, y todos los más grandes a la derecha del\n"
            + "pivote*/\n"
            + "    static int partition(int arr[], int low, int high) {\n"
            + "        int pivot = arr[high];\n"
            + "        int i = (low - 1); // Indice del elemento más pequeño\n"
            + "        for (int j = low; j < high; j++) {\n"
            + "/*Si el actual elemento es más pequeño\n"
            + "            p igual que el pivote*/\n"
            + "if (arr[j] <= pivot) {\n"
            + "                i++;\n"
            + "//intercambia arr[i] y arr[j] \n"
            + "int temp = arr[i];\n"
            + "                arr[i] = arr[j];\n"
            + "arr[j] = temp;\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "// Intercambia arr[i+1] y arr[high] (o pivote) \n"
            + "int temp = arr[i + 1];\n"
            + "        arr[i + 1] = arr[high];\n"
            + "        arr[high] = temp;\n"
            + "\n"
            + "        return i + 1;\n"
            + "}\n"
            + "\n"
            + "/*arr[] --> Array que sera ordenado, \n"
            + "low  --> indice inicial, \n"
            + "      high  --> indice final */\n"
            + "    static void sort(int arr[], int low, int high) {\n"
            + "        if (low < high) {\n"
            + "            /* pi esta particionando indices, arr[pi] is  \n"
            + "              now at right place */\n"
            + "            int pi = partition(arr, low, high);\n"
            + "// Recursivamente ordena elementos antes de \n"
            + "            // la partición y despues de la partición\n"
            + "sort(arr, low, pi - 1);\n"
            + "            sort(arr, pi + 1, high);\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "/* Imprimir array */\n"
            + "    static void printArray(int arr[]) {\n"
            + "        int n = arr.length;\n"
            + "        for (int i = 0; i < n; ++i) {\n"
            + "            System.out.print(arr[i] + \" \");\n"
            + "        }\n"
            + "        System.out.println();\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        int arr[] = {10, 7, 8, 9, 1, 5};\n"
            + "        int n = arr.length;\n"
            + "        sort(arr, 0, n - 1);\n"
            + "        System.out.println(\"Array ordenado\");\n"
            + "printArray(arr);\n"
            + "    }\n"
            + "}";
    private String radixsort = "//Implementación java de Radix Sort\n"
            + "\n"
            + "import java.util.*;\n"
            + "\n"
            + "public class RadixSort {\n"
            + "\n"
            + "// Una función de utilidad que obtiene\n"
            + "    //El maximo valor en arr[] \n"
            + "static int getMax(int arr[], int n) {\n"
            + "        int mx = arr[0];\n"
            + "        for (int i = 1; i < n; i++) {\n"
            + "            if (arr[i] > mx) {\n"
            + "                mx = arr[i];\n"
            + "}\n"
            + "        }\n"
            + "        return mx;\n"
            + "    }\n"
            + "\n"
            + "    /*Una función que realiza conteo de ordenamiento en \n"
            + "    arr[] de acuerdo al digito\n"
            + "    representado como exp*/\n"
            + "static void countSort(int arr[], int n, int exp) {\n"
            + "        int output[] = new int[n]; // Array de salida\n"
            + "        int i;\n"
            + "        int count[] = new int[10];\n"
            + "Arrays.fill(count, 0);\n"
            + "        // Almacena el conteo de las ocurrencias en count[]\n"
            + "for (i = 0; i < n; i++) {\n"
            + "            count[(arr[i] / exp) % 10]++;\n"
            + "}\n"
            + "// cambia count[i] de tal manera que ahora\n"
            + "        //contenga la actual posicion de este digito en\n"
            + "//output[]\n"
            + "        for (i = 1; i < 10; i++) {\n"
            + "            count[i] += count[i - 1];\n"
            + "        }\n"
            + "//Contruye el array de salida\n"
            + "        for (i = n - 1; i >= 0; i--) {\n"
            + "            output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n"
            + "count[(arr[i] / exp) % 10]--;\n"
            + "        }\n"
            + "// copia el array de salida a arr[], ahora arr[] \n"
            + "        // contiene los números ordenados de acuerdo al digito\n"
            + "//actual \n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            arr[i] = output[i];\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static void radixsort(int arr[], int n) {\n"
            + "// Encuentra el maximo número para conocer el número \n"
            + "        // de digitos\n"
            + "        int m = getMax(arr, n);\n"
            + "for (int exp = 1; m / exp > 0; exp *= 10) {\n"
            + "            countSort(arr, n, exp);\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "//Imprimir el array\n"
            + "    static void print(int arr[], int n) {\n"
            + "        for (int i = 0; i < n; i++) {\n"
            + "            System.out.print(arr[i] + \" \");\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};\n"
            + "        int n = arr.length;\n"
            + "        radixsort(arr, n);\n"
            + "        print(arr, n);\n"
            + "}\n"
            + "}";
    private String shellsort = "// Implementación java de ShellSort\n"
            + "public class ShellSort \n"
            + "{   /*Imprimir el array */\n"
            + "    static void printArray(int arr[]) \n"
            + "    { \n"
            + "        int n = arr.length; \n"
            + "        for (int i=0; i<n; ++i) \n"
            + "            System.out.print(arr[i] + \" \"); \n"
            + "        System.out.println(); \n"
            + "    } \n"
            + "    //Función ordenadora Shell Sort\n"
            + "static  int sort(int arr[]) \n"
            + "{ \n"
            + "        int n = arr.length; \n"
            + "//Inicia con un gran salto, luego reduce el salto\n"
            + "for (int gap = n/2; gap > 0; gap /= 2) \n"
            + "{   //Realiza un insertion sort con salto\n"
            + "            // Los primeros elementros del sato a[0..gap-1]\n"
            + "            // estan ya en un orden de salto que sigue agregando\n"
            + "            //un elemento más hasta que el array entero este ordenado\n"
            + "for (int i = gap; i < n; i += 1) \n"
            + "{ \n"
            + "//Agrega a[i] a los elementos que estan en el ordenamiento\n"
            + "// con salto\n"
            + "                int temp = arr[i]; \n"
            + "                int j; \n"
            + "                for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) \n"
            + "                    arr[j] = arr[j - gap]; \n"
            + "                arr[j] = temp; \n"
            + "            } \n"
            + "        } \n"
            + "        return 0; \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        int arr[] = {12, 34, 54, 2, 3}; \n"
            + "        System.out.println(\"Array antes de ordenar\"); \n"
            + "        printArray(arr); \n"
            + "        sort(arr);\n"
            + "        System.out.println(\"Array despues de ordenar\"); \n"
            + "printArray(arr); \n"
            + "    } \n"
            + "}  ";
    private String timsort = "// Programa Java que realiza TimSort\n"
            + "\n"
            + "public class TimSort {\n"
            + "\n"
            + "    static int RUN = 32;\n"
            + "\n"
            + "// esta función ordena el arreglo \n"
            + "    //desde el índice izquierdo hasta\n"
            + "    //a la derecha el índice que es de tamaño más alto RUN \n"
            + "public static void insertionSort(int[] arr, int left, int right) {\n"
            + "        for (int i = left + 1; i <= right; i++) {\n"
            + "            int temp = arr[i];\n"
            + "            int j = i - 1;\n"
            + "            while (arr[j] > temp && j >= left) {\n"
            + "                arr[j + 1] = arr[j];\n"
            + "                j--;\n"
            + "            }\n"
            + "            arr[j + 1] = temp;\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void merge(int[] arr, int l,\n"
            + "int m, int r) {   //Array original esta separado en dos partes\n"
            + "        // array derecho e izquierdo \n"
            + "        int len1 = m - l + 1, len2 = r - m;\n"
            + "int[] left = new int[len1];\n"
            + "        int[] right = new int[len2];\n"
            + "        for (int x = 0; x < len1; x++) {\n"
            + "            left[x] = arr[l + x];\n"
            + "        }\n"
            + "        for (int x = 0; x < len2; x++) {\n"
            + "            right[x] = arr[m + 1 + x];\n"
            + "        }\n"
            + "\n"
            + "        int i = 0;\n"
            + "        int j = 0;\n"
            + "        int k = l;\n"
            + "// despues de comparar, \n"
            + "        // after comparing,unimos los dos array  \n"
            + "        // en un subarray más largo\n"
            + "        while (i < len1 && j < len2) {\n"
            + "if (left[i] <= right[j]) {\n"
            + "                arr[k] = left[i];\n"
            + "                i++;\n"
            + "            } else {\n"
            + "                arr[k] = right[j];\n"
            + "j++;\n"
            + "            }\n"
            + "            k++;\n"
            + "        }\n"
            + "//Copia los elementos restates de la izquiera, si hay\n"
            + "while (i < len1) {\n"
            + "            arr[k] = left[i];\n"
            + "k++;\n"
            + "            i++;\n"
            + "        }\n"
            + "\n"
            + "// Copia los elementos restates de la derecha, si hay\n"
            + "while (j < len2) {\n"
            + "            arr[k] = right[j];\n"
            + "            k++;\n"
            + "            j++;\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void timSort(int[] arr, int n) {\n"
            + "//Ordena individualmente los subarrays de \n"
            + "        //tamaño RUN\n"
            + "for (int i = 0; i < n; i += RUN) {\n"
            + "            insertionSort(arr, i, Math.min((i + 31), (n - 1)));\n"
            + "}\n"
            + "//Comienza a unir de tamaño run, luego\n"
            + "        //podra unir de tamaño 64, 128, 256 y asi...\n"
            + "for (int size = RUN; size < n; size = 2 * size) {\n"
            + "// Toma un punto inicial del subarray izquierdo\n"
            + "            // nosotros vamos a unir arr[left..left+size-1] y\n"
            + "//arr[left+size, left+2*size-1], luego de cada union\n"
            + "// nosotros incrementamos izquiera en  2*size  \n"
            + "            for (int left = 0; left < n; left += 2 * size) {\n"
            + "//Encontramos punto de finalizacion de\n"
            + "                // el subarray izquierdo, mid+1\n"
            + "                // mid+1 es el punto inicial del \n"
            + "//subarray derecho  \n"
            + "                int mid = left + size - 1;\n"
            + "                int right = Math.min((left + 2 * size - 1), (n - 1));\n"
            + "\n"
            + "// une sub array arr[left.....mid] y  \n"
            + "                // arr[mid+1....right]  \n"
            + "                merge(arr, left, mid, right);\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "// Imprimir el array\n"
            + "    public static void printArray(int[] arr, int n) {\n"
            + "        for (int i = 0; i < n; i++) {\n"
            + "            System.out.print(arr[i] + \" \");\n"
            + "        }\n"
            + "        System.out.print(\"\\n\");\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int[] arr = {5, 21, 7, 23, 19};\n"
            + "        int n = arr.length;\n"
            + "        System.out.print(\"Given Array is\\n\");\n"
            + "        printArray(arr, n);\n"
            + "        timSort(arr, n);\n"
            + "        System.out.print(\"After Sorting Array is\\n\");\n"
            + "printArray(arr, n);\n"
            + "    }\n"
            + "}";
    private String treesort = "//Codigo java que implementa Tree Sort \n"
            + "public class TreeSort {\n"
            + "//Clase conteniendo hijo izquierdo\n"
            + "    //y derecho del nodo actual, y \n"
            + "    // el valor del nodo (Key)\n"
            + "static class Node {\n"
            + "\n"
            + "        int key;\n"
            + "        Node left, right;\n"
            + "\n"
            + "        public Node(int item) {\n"
            + "            key = item;\n"
            + "            left = right = null;\n"
            + "}\n"
            + "    }\n"
            + "\n"
            + "// Raiz del arbol de busqueda\n"
            + "    //binaria\n"
            + "static Node root;\n"
            + "//Constructor inicial\n"
            + "    static void init() {\n"
            + "        root = null;\n"
            + "    }\n"
            + "//Este metodo principalmente\n"
            + "    static void insert(int key) {\n"
            + "root = insertRec(root, key);\n"
            + "    }\n"
            + "/*Una función recursiva que inserta \n"
            + "    nuevos valores al arbol de busqueda binaria*/\n"
            + "static Node insertRec(Node root, int key) {\n"
            + "/*Si el arbol esta vacio\n"
            + "        Retorne un nuevo nodo*/\n"
            + "if (root == null) {\n"
            + "            root = new Node(key);\n"
            + "return root;\n"
            + "        }\n"
            + "/*De otra forma, baja por el arbol*/\n"
            + "if (key < root.key) {\n"
            + "            root.left = insertRec(root.left, key);\n"
            + "        } else if (key > root.key) {\n"
            + "            root.right = insertRec(root.right, key);\n"
            + "}\n"
            + "/*Retorna la raiz*/\n"
            + "        return root;\n"
            + "    }\n"
            + "/*Una función que realiza recorrido\n"
            + "    inorden atraves del arbol*/\n"
            + "static void inorderRec(Node root) {\n"
            + "        if (root != null) {\n"
            + "            inorderRec(root.left);\n"
            + "            System.out.print(root.key + \" \");\n"
            + "            inorderRec(root.right);\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static void treeins(int arr[]) {\n"
            + "        for (int i = 0; i < arr.length; i++) {\n"
            + "            insert(arr[i]);\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "\n"
            + "        int arr[] = {5, 4, 7, 2, 11};\n"
            + "        treeins(arr);\n"
            + "        inorderRec(root);\n"
            + "}\n"
            + "}";
    private String mergesort = "/*Programa java para Merge Sort*/\n"
            + "public class MergeSort \n"
            + "{   /*Une dos subarrays de arr[]\n"
            + "    Primer subarray es arr[1...m]\n"
            + "    Segundo subarray es arr[m+1..r]*/\n"
            + "static   void merge(int arr[], int l, int m, int r) \n"
            + "{   //Encuentra tamaños de dos subarrays a ser unidos\n"
            + "int n1 = m - l + 1; \n"
            + "        int n2 = r - m; \n"
            + "        /* Crear arrays temporales */\n"
            + "        int L[] = new int [n1]; \n"
            + "        int R[] = new int [n2]; \n"
            + "/*Copia datos en los arrays temporales*/\n"
            + "for (int i=0; i<n1; ++i) \n"
            + "            L[i] = arr[l + i]; \n"
            + "        for (int j=0; j<n2; ++j) \n"
            + "R[j] = arr[m + 1+ j]; \n"
            + "/*Une los arreglos temporales*/\n"
            + "        // Indices iniciales del los dos subarrays\n"
            + "        int i = 0, j = 0; \n"
            + "//indice inicial de array unido\n"
            + "int k = l; \n"
            + "        while (i < n1 && j < n2) \n"
            + "        { \n"
            + "            if (L[i] <= R[j]) \n"
            + "            { \n"
            + "                arr[k] = L[i]; \n"
            + "                i++; \n"
            + "            } \n"
            + "            else\n"
            + "            { \n"
            + "                arr[k] = R[j]; \n"
            + "j++; \n"
            + "            } \n"
            + "            k++; \n"
            + "        } \n"
            + "        /*Copia los elementos restanes de L[] si hay*/\n"
            + "while (i < n1) \n"
            + "        { \n"
            + "            arr[k] = L[i]; \n"
            + "i++; \n"
            + "            k++; \n"
            + "        } \n"
            + "//Copia los elementos restanes de R[] si hay\n"
            + "while (j < n2) \n"
            + "        { \n"
            + "            arr[k] = R[j]; \n"
            + "            j++; \n"
            + "            k++; \n"
            + "        } \n"
            + "    } \n"
            + "  static  void sort(int arr[], int l, int r) \n"
            + "{ \n"
            + "        if (l < r) \n"
            + "        { \n"
            + "//Encuentra el punto medio\n"
            + "            int m = (l+r)/2; \n"
            + "// Ordena los dos subarrays\n"
            + "sort(arr, l, m); \n"
            + "            sort(arr , m+1, r); \n"
            + "// Une los subarrays\n"
            + "            merge(arr, l, m, r); \n"
            + "} \n"
            + "    } \n"
            + "\n"
            + "//Imprimir array\n"
            + "    static void printArray(int arr[]) \n"
            + "    { \n"
            + "        int n = arr.length; \n"
            + "        for (int i=0; i<n; ++i) \n"
            + "            System.out.print(arr[i] + \" \"); \n"
            + "        System.out.println(); \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        int arr[] = {12, 11, 13, 5, 6, 7}; \n"
            + "\n"
            + "        System.out.println(\"Array dado\"); \n"
            + "        printArray(arr); \n"
            + "   sort(arr, 0, arr.length-1); \n"
            + "        System.out.println(\"\\nArray ordenado\"); \n"
            + "printArray(arr); \n"
            + "    } \n"
            + "}";
    private String binaryinsertionsort = "// Programa java implementando\n"
            + "// Binary Insertion Sort\n"
            + "\n"
            + "import java.util.Arrays; \n"
            + "public class BinaryInsertionSort \n"
            + "{ \n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        final int[] arr = {37, 23, 0, 17, 12, 72, 31, \n"
            + "                             46, 100, 88, 54 }; \n"
            + "\n"
            + "        sort(arr); \n"
            + "        for(int i=0; i<arr.length; i++) \n"
            + "            System.out.print(arr[i]+\" \"); \n"
            + "    } \n"
            + "\n"
            + "    static  void sort(int array[]) \n"
            + "    { \n"
            + "        for (int i = 1; i < array.length; i++) \n"
            + "{ \n"
            + "            int x = array[i]; \n"
            + "// Encontrar ubicación para insertar usando\n"
            + "// Binary Search\n"
            + "            int j = Math.abs(Arrays.binarySearch(array, 0, i, x) + 1); \n"
            + "            System.arraycopy(array, j, array, j+1, i-j); \n"
            + "// Colocar elemento en su correcta localización\n"
            + "            array[j] = x; \n"
            + "        } \n"
            + "    } \n"
            + "} ";
    private String bitonicsort = "/* Programa java para Bitonic Sort*/\n"
            + "/* Nota: Este programa solo funciona si el tamaño\n"
            + "de la entrada es una potencia de 2*/\n"
            + "public class BitonicSort {\n"
            + "/* El parámetro dir indica la dirección de ordenamiento,\n"
            + "       ASCENDIENDO o DESCENDIENDO; si (a [i]> a [j]) está de acuerdo\n"
            + "       con la dirección, entonces a[i] y a[j] son\n"
            + "intercambiados*/\n"
            + "    static void compAndSwap(int a[], int i, int j, int dir) {\n"
            + "        if ((a[i] > a[j] && dir == 1)\n"
            + "                || (a[i] < a[j] && dir == 0)) {\n"
            + "// intercambiando elementos\n"
            + "            int temp = a[i];\n"
            + "a[i] = a[j];\n"
            + "            a[j] = temp;\n"
            + "        }\n"
            + "    }\n"
            + "    static void bitonicMerge(int a[], int low, int cnt, int dir) {\n"
            + "        if (cnt > 1) {\n"
            + "            int k = cnt / 2;\n"
            + "            for (int i = low; i < low + k; i++) {\n"
            + "                compAndSwap(a, i, i + k, dir);\n"
            + "            }\n"
            + "            bitonicMerge(a, low, k, dir);\n"
            + "            bitonicMerge(a, low + k, k, dir);\n"
            + "        }\n"
            + "    }\n"
            + "    static void bitonicSort(int a[], int low, int cnt, int dir) {\n"
            + "        if (cnt > 1) {\n"
            + "            int k = cnt / 2;\n"
            + "// Ordena en orden ascendente, dir es 1 \n"
            + "            bitonicSort(a, low, k, 1);\n"
            + "// ordena en orden descendente, dir es 0\n"
            + "bitonicSort(a, low + k, k, 0);\n"
            + "// une toda la secuencia en orden ascendente\n"
            + "bitonicMerge(a, low, cnt, dir);\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static void sort(int a[], int N, int up) {\n"
            + "        bitonicSort(a, 0, N, up);\n"
            + "    }\n"
            + "\n"
            + "/*Imprimir array */\n"
            + "    static void printArray(int arr[]) {\n"
            + "        int n = arr.length;\n"
            + "        for (int i = 0; i < n; ++i) {\n"
            + "            System.out.print(arr[i] + \" \");\n"
            + "        }\n"
            + "        System.out.println();\n"
            + "    }\n"
            + "\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        int a[] = {3, 7, 4, 8, 6, 2, 1, 5};\n"
            + "        int up = 1;\n"
            + "        sort(a, a.length, up);\n"
            + "        System.out.println(\"\\nArray ordenado\");\n"
            + "printArray(a);\n"
            + "    }\n"
            + "}";
    private String cocktailsort = "// Programa java implementando Cocktail sort\n"
            + "public class CocktailSort {\n"
            + "\n"
            + "    static void cocktailSort(int a[]) {\n"
            + "        boolean swapped = true;\n"
            + "        int start = 0;\n"
            + "        int end = a.length;\n"
            + "        while (swapped == true) {\n"
            + "// Resetea la bandera intercambiada al entrar\n"
            + "            // en el ciclo, porque puede ser true de la\n"
            + "            // anterior iteración\n"
            + "            swapped = false;\n"
            + "// Ciclo del fondo a encima igual\n"
            + "// que bubble sort\n"
            + "            for (int i = start; i < end - 1; ++i) {\n"
            + "                if (a[i] > a[i + 1]) {\n"
            + "                    int temp = a[i];\n"
            + "                    a[i] = a[i + 1];\n"
            + "                    a[i + 1] = temp;\n"
            + "swapped = true;\n"
            + "                }\n"
            + "            }\n"
            + "   // Si nada fue movido, array esta ordenado\n"
            + "            if (swapped == false) {\n"
            + "                break;\n"
            + "            }\n"
            + "            // de otra forma, resetea la bandera intercambiada\n"
            + "            // de tal forma que pueda ser usada en el \n"
            + "            //siguiente proceso\n"
            + "            swapped = false;\n"
            + "// Mueve el punto final atras en uno, porque\n"
            + "            // el item al final esta en la derecha completa\n"
            + "end = end - 1;\n"
            + "            // from top to bottom, doing the \n"
            + "            // same comparison as in the previous stage \n"
            + "            for (int i = end - 1; i >= start; i--) {\n"
            + "                if (a[i] > a[i + 1]) {\n"
            + "                    int temp = a[i];\n"
            + "                    a[i] = a[i + 1];\n"
            + "                    a[i + 1] = temp;\n"
            + "swapped = true;\n"
            + "                }\n"
            + "            }\n"
            + "// Incrementa el punto inicial, por que\n"
            + "            // la ultima fase pudo haber movido el siguiente\n"
            + "            // más pequeño número en la derecha completa\n"
            + "start = start + 1;\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    /* Imprime el array*/\n"
            + "    static void printArray(int a[]) {\n"
            + "        int n = a.length;\n"
            + "        for (int i = 0; i < n; i++) {\n"
            + "            System.out.print(a[i] + \" \");\n"
            + "        }\n"
            + "        System.out.println();\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        ;\n"
            + "        int a[] = {5, 1, 4, 2, 8, 0, 2};\n"
            + "        cocktailSort(a);\n"
            + "        System.out.println(\"Arreglo ordenado\");\n"
            + "printArray(a);\n"
            + "    }\n"
            + "}";
    private String combsort = "// Programa java implementando Comb Sort\n"
            + "public class CombSort \n"
            + "{   // Para buscar espacio entre elementos\n"
            + "static  int getNextGap(int gap) \n"
            + "    { \n"
            + "        gap = (gap*10)/13; \n"
            + "        if (gap < 1) \n"
            + "            return 1; \n"
            + "        return gap; \n"
            + "    } \n"
            + "  static  void sort(int arr[]) \n"
            + "{ \n"
            + "        int n = arr.length; \n"
            + "\n"
            + "// Inicializa espacio\n"
            + "int gap = n; \n"
            + "        boolean swapped = true; \n"
            + "/*Mantiene ejecutando mientras gap es más que 1 y la \n"
            + "        ultima iteración causa un intercambio*/ \n"
            + "while (gap != 1 || swapped == true) \n"
            + "        { \n"
            + "            gap = getNextGap(gap); \n"
            + "/*Inicializa swapped como falso, aso \n"
            + "podemos verificar si el intercambio paso\n"
            + "            o no*/ \n"
            + "            swapped = false; \n"
            + "            //Compara todos los elementos con el espacio actual \n"
            + "for (int i=0; i<n-gap; i++) \n"
            + "            { \n"
            + "                if (arr[i] > arr[i+gap]) \n"
            + "{   //Intercambia arr[i] y arr[i+gap]\n"
            + "int temp = arr[i]; \n"
            + "                    arr[i] = arr[i+gap]; \n"
            + "arr[i+gap] = temp; \n"
            + "// Se intercambió\n"
            + "swapped = true; \n"
            + "                } \n"
            + "            } \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "\n"
            + "        int arr[] = {8, 4, 1, 56, 3, -44, 23, -6, 28, 0}; \n"
            + "        sort(arr); \n"
            + "        System.out.println(\"Array ordenado\"); \n"
            + "        for (int i=0; i<arr.length; ++i) \n"
            + "            System.out.print(arr[i] + \" \"); \n"
            + "\n"
            + "} \n"
            + "}";
    private String countingsort = "// Implementación java de Counting Sort\n"
            + "public class CountingSort \n"
            + "{ \n"
            + "   static  void sort(char arr[]) \n"
            + "{ \n"
            + "        int n = arr.length; \n"
            + "// El array de caracteres que sera el array \n"
            + "        //ordenado de salida\n"
            + "        char output[] = new char[n]; \n"
            + "// Crea un array de conteo para almacenar \n"
            + "        // conteo individual de caracteres e inicializar\n"
            + "// array de conteo en 0\n"
            + "        int count[] = new int[256]; \n"
            + "        for (int i=0; i<256; ++i) \n"
            + "            count[i] = 0; \n"
            + "// Almacena el conteo de cada caracter\n"
            + "for (int i=0; i<n; ++i) \n"
            + "++count[arr[i]]; \n"
            + "// Cambian count[i] de forma que ahora contenga la \n"
            + "        //posición actual de este caracter en el array de saliday \n"
            + "for (int i=1; i<=255; ++i) \n"
            + "            count[i] += count[i-1]; \n"
            + "// Construye el array de caracteres de salida\n"
            + "        // Para hacerlo estable lo hacemos en orden inverso\n"
            + "for (int i = n-1; i>=0; i--) \n"
            + "        { \n"
            + "            output[count[arr[i]]-1] = arr[i]; \n"
            + "--count[arr[i]]; \n"
            + "        } \n"
            + "//Copia el array de salida a arr, asi arr ahora\n"
            + "// contiene los caracteres ordenados \n"
            + "        for (int i = 0; i<n; ++i) \n"
            + "            arr[i] = output[i]; \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "\n"
            + "        char arr[] = {'g', 'e', 'e', 'k', 's', 'f', 'o', \n"
            + "                    'r', 'g', 'e', 'e', 'k', 's'\n"
            + "                    }; \n"
            + "        sort(arr); \n"
            + "        System.out.print(\"array de caracteres ordenado: \"); \n"
            + "        for (int i=0; i<arr.length; ++i) \n"
            + "            System.out.print(arr[i]); \n"
            + "} \n"
            + "}";
    private String cyclesort = "// Java program to implement cycle sort \n"
            + "//Programa java implementando Cycle sort\n"
            + "public class CycleSort { \n"
            + "    public static void cycleSort(int arr[], int n) \n"
            + "{   //Contador de escrituras en memoria\n"
            + "        int writes = 0; \n"
            + "//Pasar poe los elementros del array\n"
            + "        //y ponerlos en el lugar correcto \n"
            + "for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++) {  \n"
            + "// Inicializa item como punto inicial\n"
            + "            int item = arr[cycle_start]; \n"
            + "// Encuentra posicion donde nosotros pondremos el item\n"
            + "            // Basicamente contamos todos los elementos más pequeños\n"
            + "//a la derecha del item\n"
            + "            int pos = cycle_start; \n"
            + "            for (int i = cycle_start + 1; i < n; i++) \n"
            + "                if (arr[i] < item) \n"
            + "                    pos++; \n"
            + "//Si item esta ya en la posicion correcta\n"
            + "if (pos == cycle_start) \n"
            + "                continue; \n"
            + "//Ignorar todos los elementos duplicados\n"
            + "            while (item == arr[pos]) \n"
            + "                pos += 1; \n"
            + "//Ponemos el item en su posición correcta\n"
            + "if (pos != cycle_start) { \n"
            + "                int temp = item; \n"
            + "                item = arr[pos]; \n"
            + "                arr[pos] = temp; \n"
            + "                writes++; \n"
            + "} \n"
            + "//Rota el resto del ciclo\n"
            + "            while (pos != cycle_start) { \n"
            + "                pos = cycle_start; \n"
            + "                // Encuentra posicion donde poner el elemento \n"
            + "for (int i = cycle_start + 1; i < n; i++) \n"
            + "                    if (arr[i] < item) \n"
            + "                        pos += 1; \n"
            + "//Ignora todos los duplicados\n"
            + "                while (item == arr[pos]) \n"
            + "                    pos += 1; \n"
            + "\n"
            + "// Ponemos el item en su posición correcta\n"
            + "if (item != arr[pos]) { \n"
            + "                    int temp = item; \n"
            + "                    item = arr[pos]; \n"
            + "                    arr[pos] = temp; \n"
            + "                    writes++; \n"
            + "                } \n"
            + "            } \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        int arr[] = { 1, 8, 3, 9, 10, 10, 2, 4 }; \n"
            + "        int n = arr.length; \n"
            + "        cycleSort(arr, n); \n"
            + "        System.out.println(\"Luego de ordenar : \"); \n"
            + "        for (int i = 0; i < n; i++) \n"
            + "            System.out.print(arr[i] + \" \"); \n"
            + "} \n"
            + "} ";
    private String mergesort3way = "//Porgrama java que realiza Merge Sort de tres vias\n"
            + "public class MergeSort3Way \n"
            + "{ \n"
            + "    public static void mergeSort3Way(Integer[] gArray) \n"
            + "{   //Si el arrat tiene tamaño 0, retorna null\n"
            + "        if (gArray == null) \n"
            + "            return; \n"
            + "        //Creando duplicado del array dado\n"
            + "Integer[] fArray = new Integer[gArray.length]; \n"
            + "//Copiando elementos del array dado al\n"
            + "//array duplicado\n"
            + "        System.arraycopy(gArray, 0, fArray, 0, fArray.length); \n"
            + "        mergeSort3WayRec(fArray, 0, gArray.length, gArray); \n"
            + "//Copiando elementos del array duplicado al\n"
            + "//array dado\n"
            + "        System.arraycopy(fArray, 0, gArray, 0, fArray.length); \n"
            + "} \n"
            + "    /*Realizando el algoritmo Merge Sort en el array\n"
            + "    dado para los valores en el rando de los indices \n"
            + "    [low,high], low es el menor y high es el mayor\n"
            + "Exclusivo*/\n"
            + "    public static void mergeSort3WayRec(Integer[] gArray, \n"
            + "                  int low, int high, Integer[] destArray) \n"
            + "{ \n"
            + "        //Si el array tiene tamaño 1 no haga nada\n"
            + "if (high - low < 2) \n"
            + "            return; \n"
            + "// Separando el array en tres partes\n"
            + "        int mid1 = low + ((high - low) / 3); \n"
            + "        int mid2 = low + 2 * ((high - low) / 3) + 1; \n"
            + "// Ordenando las tres partes recursivamente\n"
            + "        mergeSort3WayRec(destArray, low, mid1, gArray); \n"
            + "mergeSort3WayRec(destArray, mid1, mid2, gArray); \n"
            + "        mergeSort3WayRec(destArray, mid2, high, gArray); \n"
            + "// Uniendo las tres partes\n"
            + "        merge(destArray, low, mid1, mid2, high, gArray); \n"
            + "    } \n"
            + "/*Une los rangos ordenados (low, mid1),(mid1,mid2)\n"
            + "    y (mid2, high), mid 1 es el primer indice punto \n"
            + "    medio en todo el rando para unir mid2 es segundo*/\n"
            + "public static void merge(Integer[] gArray, int low, \n"
            + "                           int mid1, int mid2, int high, \n"
            + "                                   Integer[] destArray) \n"
            + "    { \n"
            + "        int i = low, j = mid1, k = mid2, l = low; \n"
            + "// escoje el más pequeño de los más pequeños en los\n"
            + "//tres rangos\n"
            + "        while ((i < mid1) && (j < mid2) && (k < high)) \n"
            + "        { \n"
            + "            if (gArray[i].compareTo(gArray[j]) < 0) \n"
            + "            { \n"
            + "                if (gArray[i].compareTo(gArray[k]) < 0) \n"
            + "                    destArray[l++] = gArray[i++]; \n"
            + "\n"
            + "                else\n"
            + "                    destArray[l++] = gArray[k++]; \n"
            + "            } \n"
            + "            else\n"
            + "            { \n"
            + "                if (gArray[j].compareTo(gArray[k]) < 0) \n"
            + "                    destArray[l++] = gArray[j++]; \n"
            + "                else\n"
            + "                    destArray[l++] = gArray[k++]; \n"
            + "            } \n"
            + "        } \n"
            + "        while ((i < mid1) && (j < mid2)) \n"
            + "        { \n"
            + "            if (gArray[i].compareTo(gArray[j]) < 0) \n"
            + "                destArray[l++] = gArray[i++]; \n"
            + "            else\n"
            + "                destArray[l++] = gArray[j++]; \n"
            + "        }  \n"
            + "        while ((j < mid2) && (k < high)) \n"
            + "        { \n"
            + "            if (gArray[j].compareTo(gArray[k]) < 0) \n"
            + "                destArray[l++] = gArray[j++]; \n"
            + "\n"
            + "            else\n"
            + "                destArray[l++] = gArray[k++]; \n"
            + "     } \n"
            + "        while ((i < mid1) && (k < high)) \n"
            + "        { \n"
            + "            if (gArray[i].compareTo(gArray[k]) < 0) \n"
            + "                destArray[l++] = gArray[i++]; \n"
            + "            else\n"
            + "                destArray[l++] = gArray[k++]; \n"
            + "        } \n"
            + "        while (i < mid1) \n"
            + " destArray[l++] = gArray[i++]; \n"
            + "        while (j < mid2) \n"
            + " destArray[l++] = gArray[j++]; \n"
            + "        while (k < high) \n"
            + "            destArray[l++] = gArray[k++]; \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "\n"
            + "        Integer[] data = new Integer[] {45, -2, -45, 78, \n"
            + "                               30, -42, 10, 19, 73, 93}; \n"
            + "        mergeSort3Way(data); \n"
            + "System.out.println(\"Despues de merge sort de 3 vias: \"); \n"
            + "for (int i = 0; i < data.length; i++) \n"
            + "            System.out.print(data[i] + \" \"); \n"
            + "} \n"
            + "}";
    private String pigeonholesort = "/*Programa java que implemeta Pigeonhole Sort*/\n"
            + "import java.util.*;\n"
            + "\n"
            + "public class PigeonholeSort {\n"
            + "\n"
            + "    static void pigeonhole_sort(int arr[],\n"
            + "            int n) {\n"
            + "        int min = arr[0];\n"
            + "        int max = arr[0];\n"
            + "        int range, i, j, index;\n"
            + "        for (int a = 0; a < n; a++) {\n"
            + "            if (arr[a] > max) {\n"
            + "                max = arr[a];\n"
            + "            }\n"
            + "            if (arr[a] < min) {\n"
            + "                min = arr[a];\n"
            + "            }\n"
            + "        }\n"
            + "        range = max - min + 1;\n"
            + "        int[] phole = new int[range];\n"
            + "        Arrays.fill(phole, 0);\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            phole[arr[i] - min]++;\n"
            + "        }\n"
            + "        index = 0;\n"
            + "        for (j = 0; j < range; j++) {\n"
            + "            while (phole[j]-- > 0) {\n"
            + "                arr[index++] = j + min;\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int[] arr = {8, 3, 2, 7, 4, 6, 8};\n"
            + "        System.out.print(\"Array ordenado : \");\n"
            + "        pigeonhole_sort(arr, arr.length);\n"
            + "        for (int i = 0; i < arr.length; i++) {\n"
            + "            System.out.print(arr[i] + \" \");\n"
            + "}\n"
            + "    }\n"
            + "\n"
            + "}";
    private String ahocorasick = "//Codigo JAVA que implementa el algoritmo\n"
            + "// Aho Corasick de busqueda de palabras\n"
            + "import java.util.LinkedList;\n"
            + "import java.util.Queue;\n"
            + "\n"
            + "public class AhoCorasick {\n"
            + "\n"
            + "    static class TrieNode {\n"
            + "        private final int SIZE = 4;\n"
            + "        TrieNode parent;\n"
            + "        TrieNode fall;\n"
            + "        TrieNode[] children;\n"
            + "        char c;\n"
            + "        TrieNode next;\n"
            + "        boolean isEnd;\n"
            + "        public TrieNode() {\n"
            + "            children = new TrieNode[SIZE];\n"
            + "        }\n"
            + "\n"
            + "        public TrieNode(char c) {\n"
            + "            this();\n"
            + "            this.c = c;\n"
            + "        }\n"
            + "        public TrieNode child(char ch) {\n"
            + "            TrieNode node = children[ch % SIZE];\n"
            + "            if (node == null) {\n"
            + "                return null;\n"
            + "            } else {\n"
            + "                while (node.next != null) {\n"
            + "                    if (node.c == ch) {\n"
            + "                        return node;\n"
            + "}\n"
            + "                    node = node.next;\n"
            + "                }\n"
            + "\n"
            + "                // Caracter estaba al final de la lista\n"
            + "if (node.c == ch) {\n"
            + "                    return node;\n"
            + "                }\n"
            + "\n"
            + "                return null;\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        public void addWord(String word) {\n"
            + "            char firstChar = word.charAt(0);\n"
            + "            TrieNode child = child(firstChar);\n"
            + "            if (child == null) {\n"
            + "                child = new TrieNode(firstChar);\n"
            + "                child.parent = this;\n"
            + "                int pos = firstChar % SIZE;\n"
            + "                if (children[pos] == null) {\n"
            + "                    children[pos] = child;\n"
            + "                } else {\n"
            + "                    TrieNode node = children[pos];\n"
            + "                    while (node.next != null) {\n"
            + "                        node = node.next;\n"
            + "                    }\n"
            + "\n"
            + "                    node.next = child;\n"
            + "                }\n"
            + "            }\n"
            + "\n"
            + "            if (word.length() > 1) {\n"
            + "                child.addWord(word.substring(1));\n"
            + "            } else {\n"
            + "                child.isEnd = true;\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        public boolean contains(String word) {\n"
            + "            if (word.length() == 0) {\n"
            + "                return isEnd;\n"
            + "            } else {\n"
            + "                TrieNode node = child(word.charAt(0));\n"
            + "                if (node == null) {\n"
            + "                    return false;\n"
            + "                } else {\n"
            + "                    return node.contains(word.substring(1));\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        public void constructFallLinks() {\n"
            + "            TrieNode root = this;\n"
            + "            root.fall = root;\n"
            + "\n"
            + "            // BFS\n"
            + "            Queue<TrieNode> queue = new LinkedList<>();\n"
            + "            queue.add(root);\n"
            + "            while (!queue.isEmpty()) {\n"
            + "                TrieNode currentNode = queue.poll();\n"
            + "\n"
            + "// Agrega hijo\n"
            + "                for (int i = 0; i < SIZE; i++) {\n"
            + "                    TrieNode node = currentNode.children[i];\n"
            + "                    if (node != null) {\n"
            + "                        while (node.next != null) {\n"
            + "                            queue.add(node);\n"
            + "                            node = node.next;\n"
            + "                        }\n"
            + "                        queue.add(node);\n"
            + "                    }\n"
            + "                }\n"
            + "\n"
            + "                if (currentNode != root) {\n"
            + "// Atraviesa arriba la caida del padre para encontrar\n"
            + "                    // el sufijo más largo\n"
            + "                    //o hasta que alcanzamos la raiz del arbol\n"
            + "TrieNode f = currentNode.parent.fall;\n"
            + "                    while (f.child(currentNode.c) != null && f != root) {\n"
            + "                        f = f.fall;\n"
            + "                    }\n"
            + "                    currentNode.fall = f.child(currentNode.c);\n"
            + "\n"
            + "if (currentNode.fall == null) {\n"
            + "// Sufijo no encontrado, caemos la raiz\n"
            + "currentNode.fall = root;\n"
            + "                    }\n"
            + "\n"
            + "                    if (currentNode.fall == currentNode) {\n"
            + "currentNode.fall = root;\n"
            + "                    }\n"
            + "\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "/*Realiza una bsuqueda en el texto de la palabras\n"
            + "cotenidas en Trie*/\n"
            + "        public void search(String text) {\n"
            + "            TrieNode root = this;\n"
            + "            TrieNode currentNode = root;\n"
            + "            TrieNode node;\n"
            + "            TrieNode n;\n"
            + "            char[] chars = text.toCharArray();\n"
            + "            for (char ch : chars) {\n"
            + "                node = currentNode;\n"
            + "                while (node.child(ch) == null && node != root) {\n"
            + "                    node = node.fall;\n"
            + "                }\n"
            + "                if (node == root) {\n"
            + "                    node = node.child(ch);\n"
            + "                    if (node == null) {\n"
            + "                        node = root;\n"
            + "                    }\n"
            + "                } else {\n"
            + "                    node = node.child(ch);\n"
            + "                }\n"
            + "\n"
            + "                n = node;\n"
            + "                while (n != root) {\n"
            + "if (n.isEnd) {\n"
            + "                        System.out.println(\"Encontrada palabra que termina en \" + n.c);\n"
            + "}\n"
            + "                    n = n.fall;\n"
            + "                }\n"
            + "                currentNode = node;\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        TrieNode trie = new TrieNode();\n"
            + "        trie.addWord(\"soft\");\n"
            + "        trie.addWord(\"fo\");\n"
            + "        trie.constructFallLinks();\n"
            + "trie.search(\"abcfosoft\");\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "}";
    private String anagramspattern = "// Programa java que busca todos los anagramás\n"
            + "// de un patrón en un texto \n"
            + "public class AnagramsPattern \n"
            + "{ \n"
            + "    static final int MAX = 256; \n"
            + "// Esta función retorna true si los contenidos\n"
            + "    // de arr1[] y arr2[] son iguales, de otra forma es falso\n"
            + "static boolean compare(char arr1[], char arr2[]) \n"
            + "    { \n"
            + "        for (int i = 0; i < MAX; i++) \n"
            + "            if (arr1[i] != arr2[i]) \n"
            + "return false; \n"
            + "        return true; \n"
            + "    } \n"
            + "// Esta función busca todas las permutaciones de \n"
            + "// pat[] en txt[]\n"
            + "    static void search(String pat, String txt) \n"
            + "    { \n"
            + "        int M = pat.length(); \n"
            + "        int N = txt.length(); \n"
            + "\n"
            + "// countP[]:  Almacena el conteo de todos\n"
            + "        // los caracteres del patrón\n"
            + "        // countTW[]: Almacena el conteo de los caracteres\n"
            + "        // la ventana de texto\n"
            + "        char[] countP = new char[MAX]; \n"
            + "char[] countTW = new char[MAX]; \n"
            + "        for (int i = 0; i < M; i++) \n"
            + "        { \n"
            + "            (countP[pat.charAt(i)])++; \n"
            + "            (countTW[txt.charAt(i)])++; \n"
            + "} \n"
            + "//Atravesar atravez de los caracteres restantes de patrón\n"
            + "for (int i = M; i < N; i++) \n"
            + "{   //Compara conteos de la ventana actual\n"
            + "            // de texto con los conteos de pattern[]\n"
            + "if (compare(countP, countTW)) \n"
            + "                System.out.println(\"Encontrado en indice \" + \n"
            + "(i - M));  \n"
            + "// Agreca el actual caracter a la ventana actual\n"
            + "            (countTW[txt.charAt(i)])++; \n"
            + "// Remueve el primer caracter de la anterior ventana\n"
            + "countTW[txt.charAt(i-M)]--; \n"
            + "} \n"
            + "        // Revisa por la ultima ventana en el texto\n"
            + "if (compare(countP, countTW)) \n"
            + "            System.out.println(\"Encontrado en indice \" +  \n"
            + "                                       (N - M)); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        String txt = \"BACDGABCDA\"; \n"
            + "        String pat = \"ABCD\"; \n"
            + "search(pat, txt); \n"
            + "    } \n"
            + "}";
    private String boyermoore = "/*Programa java para heuristica de malos caracteres\n"
            + "usando el algoritmo de Boyer Moore*/\n"
            + "\n"
            + "public class BoyerMoore{ \n"
            + "\n"
            + "     static int NO_OF_CHARS = 256; \n"
            + "//Una función de utilidad para obtener el maximo de\n"
            + "//dos enteros\n"
            + "\n"
            + "     static int max (int a, int b) { return (a > b)? a: b; } \n"
            + "//El preprocesado del algoritmo\n"
            + "     static void badCharHeuristic( char []str, int size,int badchar[]) \n"
            + "{ \n"
            + "      int i; \n"
            + "\n"
            + "      // Inicializa todas las ocurrencias en  -1 \n"
            + "for (i = 0; i < NO_OF_CHARS; i++) \n"
            + "badchar[i] = -1; \n"
            + "      /*Llena el actual valor de la ultima ocurrencia\n"
            + "de un caracter*/\n"
            + "      for (i = 0; i < size; i++) \n"
            + "           badchar[(int) str[i]] = i; \n"
            + "} \n"
            + "/* Una función de busqueda de patrón que usa \n"
            + "     la heuristica de mal caracter*/\n"
            + "static void search( char txt[],  char pat[]) \n"
            + "     { \n"
            + "      int m = pat.length; \n"
            + "      int n = txt.length; \n"
            + "\n"
            + "      int badchar[] = new int[NO_OF_CHARS]; \n"
            + "/* Llena el arreglo de malos caracteres llamando\n"
            + "      la función de preprocesado para el patrón dado*/\n"
            + "      badCharHeuristic(pat, m, badchar); \n"
            + "      int s = 0;  // s  es cambiado del patron con respecto al texto  \n"
            + "while(s <= (n - m)) \n"
            + "      { \n"
            + "          int j = m-1; \n"
            + "/* Mantiene reduciento el indice j para el patrón\n"
            + "          mientras los caracteres del patrón y el texto \n"
            + "          estan coincidiendo en s*/\n"
            + "          while(j >= 0 && pat[j] == txt[s+j]) \n"
            + "              j--; \n"
            + "/*Si el patrón esta presente en el actual\n"
            + "          cambio, entonces el indice j se convertira en -1\n"
            + "          luego del ciclo de arriba*/\n"
            + "          if (j < 0) \n"
            + "          { \n"
            + "              System.out.println(\"Patrón encontrado en cambio = \" + s); \n"
            + "\n"
            + "s += (s+m < n)? m-badchar[txt[s+m]] : 1; \n"
            + "\n"
            + "          } \n"
            + "\n"
            + "          else\n"
            + "\n"
            + "              s += max(1, j - badchar[txt[s+j]]); \n"
            + "      } \n"
            + "     } \n"
            + "\n"
            + "    public static void main(String []args) { \n"
            + "\n"
            + "         char txt[] = \"ABAAABCDABCABC\".toCharArray(); \n"
            + "         char pat[] = \"ABC\".toCharArray(); \n"
            + "         search(txt, pat); \n"
            + "} \n"
            + "}";
    private String finiteautomata = "// Programa java para el algoritmo\n"
            + "// Finite Automata de busqueda de patrones\n"
            + "public class FiniteAutomata {\n"
            + "\n"
            + "    static int NO_OF_CHARS = 256;\n"
            + "\n"
            + "    static int getNextState(char[] pat, int M,\n"
            + "int state, int x) {\n"
            + "// Si el caracter c es el mismo como el \n"
            + "        // siguiente en patrón, simplemente incrementa\n"
            + "        // state\n"
            + "if (state < M && x == pat[state]) {\n"
            + "return state + 1;\n"
            + "        }\n"
            + "// ns almacena el resultado el cual es \n"
            + "        // el siguiente state\n"
            + "        int ns, i;\n"
            + "/* ns finalmente contiene el prefijo más largo\n"
            + "        el cual tambien es sufijo en \"pat[0..state-1]c\"\n"
            + "        Empieza desde el valor más largo posible \n"
            + "        y se detiene cuando se encuentra un prefijo el cual\n"
            + "        es tambien sufijo*/\n"
            + "        for (ns = state; ns > 0; ns--) {\n"
            + "if (pat[ns - 1] == x) {\n"
            + "                for (i = 0; i < ns - 1; i++) {\n"
            + "                    if (pat[i] != pat[state - ns + 1 + i]) {\n"
            + "                        break;\n"
            + "                    }\n"
            + "                }\n"
            + "                if (i == ns - 1) {\n"
            + "                    return ns;\n"
            + "}\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        return 0;\n"
            + "    }\n"
            + "/*Esta función construye la tabla TF la cual\n"
            + "    representa Finite Automata del patrón dado*/\n"
            + "static void computeTF(char[] pat, int M, int TF[][]) {\n"
            + "        int state, x;\n"
            + "        for (state = 0; state <= M; ++state) {\n"
            + "            for (x = 0; x < NO_OF_CHARS; ++x) {\n"
            + "                TF[state][x] = getNextState(pat, M, state, x);\n"
            + "}\n"
            + "        }\n"
            + "    }\n"
            + "/* Imprime todas las ocurrencuas de pat en txt*/\n"
            + "static void search(char[] pat, char[] txt) {\n"
            + "        int M = pat.length;\n"
            + "        int N = txt.length;\n"
            + "        int[][] TF = new int[M + 1][NO_OF_CHARS];\n"
            + "        computeTF(pat, M, TF);\n"
            + "// Procesa txt sobre FA.\n"
            + "        int i, state = 0;\n"
            + "        for (i = 0; i < N; i++) {\n"
            + "            state = TF[state][txt[i]];\n"
            + "            if (state == M) {\n"
            + "                System.out.println(\"Patrón encontrado \"\n"
            + "                        + \"en indice \" + (i - M + 1));\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "char[] pat = \"AABAACAADAABAAABAA\".toCharArray();\n"
            + "        char[] txt = \"AABA\".toCharArray();\n"
            + "        search(txt, pat);\n"
            + "    }\n"
            + "}";
    private String kmpstringmatching = "/* Programa java implementando el algoritmo \n"
            + "de busqueda KMP*/\n"
            + "public class KMPStringMatching {\n"
            + "\n"
            + "static void KMPSearch(String pat, String txt) {\n"
            + "        int M = pat.length();\n"
            + "        int N = txt.length();\n"
            + "// Crea lps[] el cual podra mantener el\n"
            + "        // más largo prefijo sufijo para patrón\n"
            + "int lps[] = new int[M];\n"
            + "int j = 0; // indice de pat[] \n"
            + "// Preprocesa el patrón (Calcula lps[]) \n"
            + "computeLPSArray(pat, M, lps);\n"
            + "        int i = 0; // indice para txt[] \n"
            + "        while (i < N) {\n"
            + "            if (pat.charAt(j) == txt.charAt(i)) {\n"
            + "                j++;\n"
            + "                i++;\n"
            + "            }\n"
            + "            if (j == M) {\n"
            + "                System.out.println(\"Encontrado patrón \"\n"
            + "+ \"en indice \" + (i - j));\n"
            + "                j = lps[j - 1];\n"
            + "            } // no coincide luego de j veces\n"
            + "else if (i < N && pat.charAt(j) != txt.charAt(i)) {\n"
            + "/*No coincide lps[0..lps[j-1]] caracteres\n"
            + "                ellos coincidiran de todos modos*/\n"
            + "if (j != 0) {\n"
            + "                    j = lps[j - 1];\n"
            + "                } else {\n"
            + "                    i = i + 1;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static void computeLPSArray(String pat, int M, int lps[]) {\n"
            + "// Longitus del anterior prefijo sufijo más largo\n"
            + "        int len = 0;\n"
            + "        int i = 1;\n"
            + "        lps[0] = 0; // lps[0] es siempre 0\n"
            + "\n"
            + "// el ciclo calcula lps[i] para i = 1 hasta M-1 \n"
            + "while (i < M) {\n"
            + "            if (pat.charAt(i) == pat.charAt(len)) {\n"
            + "                len++;\n"
            + "                lps[i] = len;\n"
            + "                i++;\n"
            + "            } else // (pat[i] != pat[len]) \n"
            + "{\n"
            + "// Esto es dificl, considere el ejemplo\n"
            + "                // AAACAAAA y i = 7. la idea es similar\n"
            + "                // el paso de busqueda\n"
            + "                if (len != 0) {\n"
            + "                    len = lps[len - 1];\n"
            + "// Tambien, note que no incrementamos \n"
            + "//i aqui\n"
            + "                } else // if (len == 0) \n"
            + "                {\n"
            + "                    lps[i] = len;\n"
            + "                    i++;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        String txt = \"ABABDABACDABABCABAB\";\n"
            + "        String pat = \"ABABCABAB\";\n"
            + "KMPSearch(pat, txt);\n"
            + "    }\n"
            + "}";
    private String manacheralgorithm = "// Programa java implementando el algoritmo de Manacher\n"
            + "// LPS: longest palindrome string\n"
            + "public class ManacherAlgorithm {\n"
            + "\n"
            + "    static char text[];\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        text = \"babcbabcbaccba\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "        text = \"abaaba\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "        text = \"abababa\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "        text = \"abcbabcbabcba\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "        text = \"caba\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "        text = \"abacdfgdcaba\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "        text = \"abacdfgdcabba\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "        text = \"abacdedcaba\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "    }\n"
            + "\n"
            + "    static int min(int a, int b) {\n"
            + "        int res = a;\n"
            + "        if (b < a) {\n"
            + "            res = b;\n"
            + "        }\n"
            + "        return res;\n"
            + "    }\n"
            + "\n"
            + "    static void findLongestPalindromicString() {\n"
            + "        int N = text.length;\n"
            + "        if (N == 0) {\n"
            + "return;\n"
            + "        }\n"
            + "        N = 2 * N + 1; //Conteo de posición\n"
            + "int L[] = new int[N]; //LPS tamaño de array\n"
            + "L[0] = 0;\n"
            + "        L[1] = 1;\n"
            + "        int C = 1; //Posición central\n"
            + "        int R = 2; //posición Centro derecho\n"
            + "        int i = 0; //Posición actual derecho\n"
            + "        int iMirror; //Posición actual izquierda\n"
            + "        int maxLPSLength = 0;\n"
            + "int maxLPSCenterPosition = 0;\n"
            + "        int start = -1;\n"
            + "        int end = -1;\n"
            + "int diff = -1;\n"
            + "//Descomentar para imprimir tamaño del arreglo LPS\n"
            + "//printf(\"%d %d \", L[0], L[1]); \n"
            + "        for (i = 2; i < N; i++) {\n"
            + "            iMirror = 2 * C - i;\n"
            + "            L[i] = 0;\n"
            + "            diff = R - i;\n"
            + "            if (diff > 0) {\n"
            + "                L[i] = min(L[iMirror], diff);\n"
            + "}\n"
            + "/*Intente expandir palíndromo centrado en currentRightPosition i\n"
            + "            Aquí para posiciones impares, comparamos caracteres y\n"
            + "            si coinciden, aumente la longitud de LPS en UNO\n"
            + "            Si la posición es igual, solo incrementamos LPS en UNO sin*/\n"
            + "try {\n"
            + "                while (((i + L[i]) < N && (i - L[i]) > 0)\n"
            + "&& (((i + L[i] + 1) % 2 == 0)\n"
            + "                        || (text[(i + L[i] + 1) / 2] == text[(i - L[i] - 1) / 2]))) {\n"
            + "                    L[i]++;\n"
            + "                }\n"
            + "            } catch (Exception e) {\n"
            + "}\n"
            + "//Comparación de cualquier caracter\n"
            + "            if (L[i] > maxLPSLength) \n"
            + "{\n"
            + "                maxLPSLength = L[i];\n"
            + "                maxLPSCenterPosition = i;\n"
            + "            }\n"
            + "            if (i + L[i] > R) {\n"
            + "                C = i;\n"
            + "                R = i + L[i];\n"
            + "}\n"
            + "//Descomentar para imprimir tamaño del arreglo LPS\n"
            + "//printf(\"%d \", L[i]); \n"
            + "        }\n"
            + "        start = (maxLPSCenterPosition - maxLPSLength) / 2;\n"
            + "        end = start + maxLPSLength - 1;\n"
            + "        System.out.println(\"LPS del string es \" + String.copyValueOf(text) + \": \");\n"
            + "\n"
            + "        for (i = start; i <= end; i++) {\n"
            + "            System.out.printf(\"%c\", text[i]);\n"
            + "\n"
            + "}\n"
            + "        System.out.println(\"\");\n"
            + "    }\n"
            + "}";
    private String rabinkarp = "/*Implementación java del algoritmo de \n"
            + "Rabin Karp*/ \n"
            + "public class RabinKarp  \n"
            + "{   // d es elnúmero de caracteres en el alfabeto de entrada\n"
            + "public final static int d = 256; \n"
            + "/* pat -> patrón \n"
            + "        txt -> texto\n"
            + "        q -> Un número primo\n"
            + "*/\n"
            + "    static void search(String pat, String txt, int q) \n"
            + "    { \n"
            + "        int M = pat.length(); \n"
            + "        int N = txt.length(); \n"
            + "int i, j; \n"
            + "        int p = 0; // valor hash  del patrón\n"
            + "        int t = 0; // valor hash  del txt \n"
            + "        int h = 1; \n"
            + "// el valor de h debe ser \"pow(d, M-1)%q\"\n"
            + "for (i = 0; i < M-1; i++) \n"
            + "            h = (h*d)%q; \n"
            + "/*Calcula el valor hash del patron y primera \n"
            + "ventana de texto*/\n"
            + "        for (i = 0; i < M; i++) \n"
            + "        { \n"
            + "            p = (d*p + pat.charAt(i))%q; \n"
            + "            t = (d*t + txt.charAt(i))%q; \n"
            + "} \n"
            + "//Desliza el patrón por encima del texto uno por uno\n"
            + "        for (i = 0; i <= N - M; i++) \n"
            + "        { \n"
            + "/*Verifica los valores hash de la actual ventana de text\n"
            + "            y patrón. Si el valor hash coincide entonces solo revisa \n"
            + "            los caratceres uno por uno*/\n"
            + "            if ( p == t ) \n"
            + "            {   /*Revisa por caracteres uno por uno*/\n"
            + "for (j = 0; j < M; j++) \n"
            + "                { \n"
            + "                    if (txt.charAt(i+j) != pat.charAt(j)) \n"
            + "                        break; \n"
            + "                } \n"
            + "// Si p==t y pat[0...M-1] = txt[i, i+1, ...i+M-1] \n"
            + "if (j == M) \n"
            + "                    System.out.println(\"Patron encontrado en el indice \" + i); \n"
            + "            } \n"
            + "// Calcula el valor hash de la siguiente ventana de texto\n"
            + "            // Remueve el digito lider, y final\n"
            + "if ( i < N-M ) \n"
            + "            { \n"
            + "                t = (d*(t - txt.charAt(i)*h) + txt.charAt(i+M))%q; \n"
            + "/*Nosotros obtendremos un valor negativo de t\n"
            + "                convirtiendolo a positivo*/\n"
            + "                if (t < 0) \n"
            + "t = (t + q); \n"
            + "            } \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        String txt = \"EQUIPO ARTEMIS\"; \n"
            + "        String pat = \"ARTE\"; \n"
            + "int q = 101; // un número primo\n"
            + "        search(pat, txt, q); \n"
            + "    } \n"
            + "}  ";
    private String wildcardpattern = "//Programa java que implementa el cotejamiento\n"
            + "// de patrones con Wildcard\n"
            + "import java.util.Arrays;\n"
            + "\n"
            + "public class WildcardPattern {\n"
            + "//Función que coteja str con el patron wildcard\n"
            + "static boolean strmatch(String str, String pattern,\n"
            + "int n, int m) {\n"
            + "// Patron vacio colo puede coincidir \n"
            + "// con string vacio\n"
            + "        if (m == 0) {\n"
            + "            return (n == 0);\n"
            + "}\n"
            + "// Tabla de busqueda para almacenar resultados\n"
            + "// de subproblemás\n"
            + "        boolean[][] lookup = new boolean[n + 1][m + 1];\n"
            + "        //Inicializa la tabla en falso\n"
            + "        for (int i = 0; i < n + 1; i++) {\n"
            + "            Arrays.fill(lookup[i], false);\n"
            + "}\n"
            + "        lookup[0][0] = true;\n"
            + "//Solo '*' puede coincidri con string vacio\n"
            + "for (int j = 1; j <= m; j++) {\n"
            + "            if (pattern.charAt(j - 1) == '*') {\n"
            + "lookup[0][j] = lookup[0][j - 1];\n"
            + "            }\n"
            + "        }\n"
            + "// Llena la yabla \n"
            + "for (int i = 1; i <= n; i++) {\n"
            + "            for (int j = 1; j <= m; j++) {\n"
            + "/*Dos casos que podemos ver de '*'\n"
            + "                a) Ignoramos '*' y pasamos al siguiente\n"
            + "                caracter en el patrón\n"
            + "                b) '*' coincide con un iesimo\n"
            + "                caracter en una entrada*/\n"
            + "\n"
            + "                if (pattern.charAt(j - 1) == '*') {\n"
            + "lookup[i][j] = lookup[i][j - 1]\n"
            + "|| lookup[i - 1][j];\n"
            + "                } \n"
            + "/*Actuales caracteres son considerados \n"
            + "                como coincidentes en dos casos\n"
            + "                a) actual caracter de patron es '?'\n"
            + "b) caracteres actuales coinciden*/\n"
            + "                else if (pattern.charAt(j - 1) == '?'\n"
            + "                        || str.charAt(i - 1) == pattern.charAt(j - 1)) {\n"
            + "                    lookup[i][j] = lookup[i - 1][j - 1];\n"
            + "} // Si el caracter no coincide\n"
            + "                else {\n"
            + "lookup[i][j] = false;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        return lookup[n][m];\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        String str = \"baaabab\";\n"
            + "        String pattern = \"*****ba*****ab\";\n"
            + "//Casos de prueba \n"
            + "// String pattern = \"ba*****ab\";\n"
            + "// String pattern = \"ba*ab\";\n"
            + "        // String pattern = \"a*ab\";\n"
            + "        // String pattern = \"a*****ab\";\n"
            + "        // String pattern = \"*a*****ab\";\n"
            + "        // String pattern = \"ba*ab****\";\n"
            + "        // String pattern = \"****\";\n"
            + "        // String pattern = \"*\";\n"
            + "        // String pattern = \"aa?ab\";\n"
            + "        // String pattern = \"b*b\";\n"
            + "        // String pattern = \"a*a\";\n"
            + "        // String pattern = \"baaabab\";\n"
            + "        // String pattern = \"?baaabab\";\n"
            + "        // String pattern = \"*baaaba*\"; \n"
            + "\n"
            + "        if (strmatch(str, pattern, str.length(),\n"
            + "                pattern.length())) {\n"
            + "            System.out.println(\"Si\");\n"
            + "        } else {\n"
            + "            System.out.println(\"No\");\n"
            + "}\n"
            + "\n"
            + "    }\n"
            + "}";
    private String gcdlcm = "//Programa java que realiza\n"
            + "//Maximo comun divisor y minimo comun multiplo\n"
            + "public class GCDLCM {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "int a =8,b=12;\n"
            + "        System.out.println(\"GCD de a y b es :\"+gcd(a, b));\n"
            + "        System.out.println(\"LCM de a y b es :\"+lcm(a, b));\n"
            + "}\n"
            + "//Maximo Comun Divisor\n"
            + "    public static int gcd(int a, int b) {\n"
            + "        return b == 0 ? a : gcd(b, a % b);\n"
            + "    }\n"
            + "//Minimo Comun Multiplo\n"
            + "    public static int lcm(int a, int b) {\n"
            + "        return a * (b / gcd(a, b));\n"
            + "}\n"
            + "}";
    private String primalitytest = "//Programa java que verifica si un número\n"
            + "// es primo o no\n"
            + "public class PrimalityTest {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        boolean isprime = false;\n"
            + "        int n = 5;\n"
            + "        if (isPrime(n)) {\n"
            + "            System.out.println(\"Es primo\");\n"
            + "} else {\n"
            + "            System.out.println(\"No es primo\");\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "//Prueba de primalidad\n"
            + "public static boolean isPrime(int x) {\n"
            + "        if (x < 2) {\n"
            + "            return false;\n"
            + "        }\n"
            + "        if (x == 2) {\n"
            + "            return true;\n"
            + "        }\n"
            + "        if (x % 2 == 0) {\n"
            + "            return false;\n"
            + "        }\n"
            + "        for (int i = 3; i * i <= x; i++) {\n"
            + "            if (x % i == 0) {\n"
            + "                return false;\n"
            + "}\n"
            + "        }\n"
            + "        return true;\n"
            + "    }\n"
            + "\n"
            + "}";
    private String primefactors = "//Programa que descompone un número n\n"
            + "// en sus factores primos\n"
            + "public class PrimeFactors {\n"
            + "\n"
            + "public static void main(String[] args) {\n"
            + "        primeFactors(12);\n"
            + "    }\n"
            + "//Descomposicion en factores primos\n"
            + "    public static void primeFactors(int N) {\n"
            + "        for (long p = 2; p * p <= N; ++p) {\n"
            + "            while (N % p == 0) {\n"
            + "                System.out.println(p);\n"
            + "                N /= p;\n"
            + "            }\n"
            + "        }\n"
            + "        if (N > 1) {\n"
            + "            System.out.println(N);\n"
            + "}\n"
            + "    }\n"
            + "\n"
            + "}";
    private String divisibilitybysmallnumbers = "//Programa que verifica la divisibilidad de un \n"
            + "// número entre los números 1 a 12\n"
            + "public class DivisibilityBySmallNumbers {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        boolean[] res = divisility(12);\n"
            + "        for (int i = 0; i < res.length; i++) {\n"
            + "            System.out.println(i+\" : \"+res[i]);\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static public boolean[] divisility(int num) {\n"
            + "        String M = String.valueOf(num);\n"
            + "        int n=M.length();\n"
            + "        boolean[] isMultipleOf = new boolean[13];\n"
            + "        int sum = 0;\n"
            + "        for (char c : M.toCharArray()) {\n"
            + "            sum += c - '0';\n"
            + "        }\n"
            + "        int lastDigit = M.charAt(n - 1) - '0';\n"
            + "//Divisibilidad entre 1\n"
            + "        isMultipleOf[1] = true;\n"
            + "//Divisibilidad entre 2\n"
            + "        isMultipleOf[2] = lastDigit % 2 == 0;\n"
            + "//Divisibilidad entre 3\n"
            + "        isMultipleOf[3] = sum % 3 == 0;\n"
            + "//Divisibilidad entre 4\n"
            + "if (n > 1) {\n"
            + "            isMultipleOf[4] = Integer.parseInt(M.substring(n - 2, n)) % 4 == 0;\n"
            + "} else {\n"
            + "            isMultipleOf[4] = lastDigit % 4 == 0;\n"
            + "        }\n"
            + "        //Divisibilidad entre 5\n"
            + "        isMultipleOf[5] = lastDigit == 0 || lastDigit == 5;\n"
            + "        //Divisibilidad entre 6\n"
            + "isMultipleOf[6] = isMultipleOf[2] && isMultipleOf[3];\n"
            + "        int altSum = 0;\n"
            + "        int[] pattern = {1, 3, 2, -1, -3, -2};\n"
            + "        int j = 0;\n"
            + "        for (int i = n - 1; i >= 0; i--) {\n"
            + "            altSum += pattern[j] * (M.charAt(i) - '0');\n"
            + "j = (j + 1) % 6;\n"
            + "        }\n"
            + "        //Divisibilidad entre 7\n"
            + "        isMultipleOf[7] = Math.abs(altSum) % 7 == 0;\n"
            + "//Divisibilidad entre 8\n"
            + "        if (n > 2) {\n"
            + "            isMultipleOf[8] = Integer.parseInt(M.substring(n - 3, n)) % 8 == 0;\n"
            + "        } else {\n"
            + "isMultipleOf[8] = Integer.parseInt(M) % 8 == 0;\n"
            + "        }\n"
            + "        //Divisibilidad entre 9\n"
            + "        isMultipleOf[9] = sum % 8 == 0;\n"
            + "//Divisibilidad entre 10\n"
            + "        isMultipleOf[10] = lastDigit == 0;\n"
            + "altSum = 0;\n"
            + "        int s = 1;\n"
            + "        for (int i = n - 1; i >= 0; i--) {\n"
            + "            altSum += s * (M.charAt(i) - '0');\n"
            + "s = -s;\n"
            + "        }\n"
            + "//Divisibilidad entre 11\n"
            + "        isMultipleOf[11] = Math.abs(altSum) % 11 == 0;\n"
            + "        //Divisibilidad entre 12\n"
            + "isMultipleOf[12] = isMultipleOf[3] && isMultipleOf[4];\n"
            + "        return isMultipleOf;\n"
            + "}\n"
            + "}";
    private String numberofdivisors = "//Programa java que cuenta el número\n"
            + "// de divisores de x\n"
            + "public class NumberOfDivisors {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "System.out.println(divisors(56));\n"
            + "    }\n"
            + "\n"
            + "//Todos los divisores de un número\n"
            + "public static int divisors(int x) {\n"
            + "        int nDiv = 1;\n"
            + "        for (int p = 2; p * p <= x; ++p) {\n"
            + "            int cnt = 0;\n"
            + "            while (x % p == 0) {\n"
            + "                ++cnt;\n"
            + "                x /= p;\n"
            + "            }\n"
            + "            nDiv *= cnt + 1;\n"
            + "        }\n"
            + "        if (x > 1) {\n"
            + "            nDiv *= 2;\n"
            + "        }\n"
            + "        return nDiv;\n"
            + "\n"
            + "}\n"
            + "\n"
            + "}";
    private String primenumbers = "//Programa java que encuentra todos los números \n"
            + "//primos bajo N\n"
            + "import java.util.Arrays;\n"
            + "\n"
            + "public class PrimeNumbers {\n"
            + "\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        boolean[] res = sieveEratostenes(100);\n"
            + "        for (int i = 0; i < res.length; i++) {\n"
            + "            System.out.println(i+\" : \"+res[i]);\n"
            + "}\n"
            + "    }\n"
            + "\n"
            + "//Criba de Eratostenes (Todos los primos bajo un número)\n"
            + "public static boolean[] sieveEratostenes(int N) {\n"
            + "        boolean[] prime = new boolean[N + 1];\n"
            + "        Arrays.fill(prime, true);\n"
            + "        prime[0] = prime[1] = false;\n"
            + "        for (int p = 2; p * p <= N; p++) {\n"
            + "            if (prime[p]) {\n"
            + "                for (int i = p * p; i <= N; i += p) {\n"
            + "                    prime[i] = false;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "        return prime;\n"
            + "}\n"
            + "\n"
            + "}";
    private String fibonaccilastdigit = "// Programa java que encuentra el ultimo digito \n"
            + "// de un nesimo número fibonacci\n"
            + "public class FibonacciLastDigit {\n"
            + "//Funcion que retona el nesimo\n"
            + "    // Número de fibonacci\n"
            + "static long fib(long n) {\n"
            + "        long F[][] = new long[][]{{1, 1}, {1, 0}};\n"
            + "        if (n == 0) {\n"
            + "            return 0;\n"
            + "        }\n"
            + "        power(F, n - 1);\n"
            + "        return F[0][0];\n"
            + "}\n"
            + "//Función que multiplica dos\n"
            + "    // matrices y almacera el resultado en la primera\n"
            + "static void multiply(long F[][], long M[][]) {\n"
            + "        long x = F[0][0] * M[0][0]\n"
            + "                + F[0][1] * M[1][0];\n"
            + "        long y = F[0][0] * M[0][1]\n"
            + "                + F[0][1] * M[1][1];\n"
            + "        long z = F[1][0] * M[0][0]\n"
            + "                + F[1][1] * M[1][0];\n"
            + "        long w = F[1][0] * M[0][1]\n"
            + "                + F[1][1] * M[1][1];\n"
            + "        F[0][0] = x;\n"
            + "        F[0][1] = y;\n"
            + "        F[1][0] = z;\n"
            + "        F[1][1] = w;\n"
            + "    }\n"
            + "    static void power(long F[][], long n) {\n"
            + "        if (n == 0 || n == 1) {\n"
            + "            return;\n"
            + "        }\n"
            + "        long M[][] = new long[][]{{1, 1}, {1, 0}};\n"
            + "        power(F, n / 2);\n"
            + "        multiply(F, F);\n"
            + "if (n % 2 != 0) {\n"
            + "multiply(F, M);\n"
            + "}\n"
            + "    }\n"
            + "// Retorna el ultimo digito \n"
            + "// nesimo número fibonacci\n"
            + "public static long findLastDigit(long n) {\n"
            + "        return (fib(n) % 10);\n"
            + "    }\n"
            + "    public static void main(String[] args) {\n"
            + "        int n;\n"
            + "        n = 1;\n"
            + "        System.out.println(findLastDigit(n));\n"
            + "        n = 61;\n"
            + "        System.out.println(findLastDigit(n));\n"
            + "        n = 7;\n"
            + "        System.out.println(findLastDigit(n));\n"
            + "        n = 67;\n"
            + "        System.out.println(findLastDigit(n));\n"
            + "}\n"
            + "}";
    private String longfibonacci = "//Porgrama java que busca el nesimo número\n"
            + "// de fibonacci cuando n puede ser muy largo\n"
            + "import java.math.*; \n"
            + "\n"
            + "public class LongFibonacci \n"
            + "{ \n"
            + "    static BigInteger fib(int n) \n"
            + "    { \n"
            + "        BigInteger a = BigInteger.valueOf(0); \n"
            + "        BigInteger b = BigInteger.valueOf(1); \n"
            + "        BigInteger c = BigInteger.valueOf(1); \n"
            + "        for (int j=2 ; j<=n ; j++) \n"
            + "        { \n"
            + "            c =  a.add(b); \n"
            + "            a = b; \n"
            + "            b = c; \n"
            + "        } \n"
            + "        return (a); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "{ \n"
            + "        int n = 1000; \n"
            + "        System.out.println(\"Fibonacci de  \" + n + \n"
            + "            \" termino\" + \" \" +\"es\" +\" \" + fib(n)); \n"
            + "    } \n"
            + "}";
    private String isfibonumber = "// Programa que verifica si x es número fibonacci\n"
            + "public class IsFiboNumber\n"
            + "{   // Función que retorna si x es cuadrado perfecto\n"
            + "static  boolean isPerfectSquare(int x) \n"
            + "    { \n"
            + "        int s = (int) Math.sqrt(x); \n"
            + "return (s*s == x); \n"
            + "    } \n"
            + "    //Función que verifica si es número fibonacci\n"
            + "static boolean isFibonacci(int n) \n"
            + "{   // N es fibinacci si uno de 5*n*n+4 o or 5*n*n - 4\n"
            + "        // o ambos son cuadrados perfectos\n"
            + "        return isPerfectSquare(5*n*n + 4) || \n"
            + "isPerfectSquare(5*n*n - 4); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        for (int i = 1; i <= 10; i++) \n"
            + "             System.out.println(isFibonacci(i) ?  i +  \" Es un número de fibonacci\" : \n"
            + "                                                  i + \" No es un número de fibonacci\"); \n"
            + "    } \n"
            + "}";
    private String allpermutations = "//Programa java que imprime todas las permutaciones\n"
            + "// de un conjunto \n"
            + "import java.util.HashSet;\n"
            + "import java.util.Iterator;\n"
            + "import java.util.Set;\n"
            + "\n"
            + "public class AllPermutations {\n"
            + "\n"
            + "    static Set<String> permutations;\n"
            + "    static Set<String> result = new HashSet<String>();\n"
            + "\n"
            + "    public static Set<String> permutation(String string) {\n"
            + "        permutations = new HashSet<>();\n"
            + "\n"
            + "        int n = string.length();\n"
            + "        for (int i = n - 1; i >= 0; i--) {\n"
            + "            shuffle(string.charAt(i));\n"
            + "        }\n"
            + "        return permutations;\n"
            + "    }\n"
            + "\n"
            + "    private static void shuffle(char c) {\n"
            + "        if (permutations.isEmpty()) {\n"
            + "            permutations.add(String.valueOf(c));\n"
            + "        } else {\n"
            + "            Iterator<String> it = permutations.iterator();\n"
            + "            for (int i = 0; i < permutations.size(); i++) {\n"
            + "\n"
            + "                String temp1;\n"
            + "                for (; it.hasNext();) {\n"
            + "                    temp1 = it.next();\n"
            + "                    for (int k = 0; k < temp1.length() + 1; k += 1) {\n"
            + "                        StringBuilder sb = new StringBuilder(temp1);\n"
            + "\n"
            + "                        sb.insert(k, c);\n"
            + "\n"
            + "                        result.add(sb.toString());\n"
            + "                    }\n"
            + "                }\n"
            + "            }\n"
            + "            permutations = result;\n"
            + "            result = new HashSet<>();\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        Set<String> finalresult = permutation(\"1234\");\n"
            + "        System.out.println(\"\\nHay en total \" + finalresult.size() + \" permutaciones:\");\n"
            + "        Iterator<String> it = finalresult.iterator();\n"
            + "        while (it.hasNext()) {\n"
            + "            System.out.println(it.next());\n"
            + "}\n"
            + "    }\n"
            + "}";
    private String combination = "//Programa java que imprime todas las combinaciones\n"
            + "// de tamaño r en un arreglo de tamaño n\n"
            + "public class Combination {\n"
            + "\n"
            + "/* arr[] ---> Array de entrada\n"
            + "data[] ---> Array temporal que almacenara la combinación actual\n"
            + "    start & end --->  Iniciando y terminando indices en arr[]\n"
            + "    index ---> Actual indice en data[]\n"
            + "    r ---> Tamaño de una combinacion a ser impresa*/\n"
            + "static void combinationUtil(int arr[], int data[], int start,\n"
            + "            int end, int index, int r) {\n"
            + "// Actual combinación esta lsta para ser impresa, se imprime\n"
            + "if (index == r) {\n"
            + "            for (int j = 0; j < r; j++) {\n"
            + "                System.out.print(data[j] + \" \");\n"
            + "            }\n"
            + "            System.out.println(\"\");\n"
            + "            return;\n"
            + "        }\n"
            + "\n"
            + "        for (int i = start; i <= end && end - i + 1 >= r - index; i++) {\n"
            + "            data[index] = arr[i];\n"
            + "            combinationUtil(arr, data, i + 1, end, index + 1, r);\n"
            + "        }\n"
            + "    }\n"
            + "    static void printCombination(int arr[], int n, int r) {\n"
            + "        int data[] = new int[r];\n"
            + "        combinationUtil(arr, data, 0, n - 1, 0, r);\n"
            + "    }\n"
            + "    public static void main(String[] args) {\n"
            + "        int arr[] = {1, 2, 3, 4, 5};\n"
            + "        int r = 3;\n"
            + "        int n = arr.length;\n"
            + "printCombination(arr, n, r);\n"
            + "    }\n"
            + "}";
    private String combinationscompose = "//Programa java que imprime todas\n"
            + "//las combinaciones que pueden componer un número dado\n"
            + "public class CombinationsCompose {\n"
            + "//Función imprime todas las combinaciones de números 1, 2, ...MAX_POINT\n"
            + "    // que su suma resulte  n\n"
            + "    // i es usado en recursion para mantener revisión del indice\n"
            + "    // en arr[] donde el siguiente elemento sera añadido\n"
            + "    // Valor inicial de i debe ser pasado como 0\n"
            + "\n"
            + "static void printCompositions(int arr[], int n, int i) {\n"
            + "        int MAX_POINT = 3;\n"
            + "        if (n == 0) {\n"
            + "            printArray(arr, i);\n"
            + "        } else if (n > 0) {\n"
            + "            for (int k = 1; k <= MAX_POINT; k++) {\n"
            + "                arr[i] = k;\n"
            + "                printCompositions(arr, n - k, i + 1);\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "// Imprime array\n"
            + "    static void printArray(int arr[], int m) {\n"
            + "        for (int i = 0; i < m; i++) {\n"
            + "            System.out.print(arr[i] + \" \");\n"
            + "        }\n"
            + "        System.out.println();\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int n = 5;\n"
            + "        int size = 100;\n"
            + "        int[] arr = new int[size];\n"
            + "System.out.println(\"Diferentes composiciones formadas por 1, 2 y 3 de \" + n + \" son \");\n"
            + "        printCompositions(arr, n, 0);\n"
            + "    }\n"
            + "}";
    private String allsets = "//Programa java que imprime todos los subconjuntos de \n"
            + "//un conjunto\n"
            + "public class Allsets {\n"
            + "    static void printSubsets(char set[]) {\n"
            + "int n = set.length;\n"
            + "// Ejecuta un ciclo imprimiendo todos\n"
            + "        //  los subconjuntos 2^n uno por uno\n"
            + "for (int i = 0; i < (1 << n); i++) {        \n"
            + "System.out.print(\"{ \");\n"
            + "//Imprime el subconjunto actual\n"
            + "            for (int j = 0; j < n; j++) // (1<<j) es un número con jesimo bit 1\n"
            + "{\n"
            + "                if ((i & (1 << j)) > 0) {\n"
            + "                    System.out.print(set[j] + \" \");\n"
            + "                }\n"
            + "            }\n"
            + "            System.out.println(\"}\");\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        char set[] = {'a', 'b', 'c'};\n"
            + "printSubsets(set);\n"
            + "    }\n"
            + "}";
    private String hanoitowels = "//Programa java que calcula los movimientos\n"
            + "// necesarios para completar las torres de Hanoi\n"
            + "// Sin importar el número de discos n\n"
            + "public class HanoiTowels {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "//Número de discos\n"
            + "        int n;\n"
            + "        n = 8;\n"
            + "        hanoi(n, \"Primera torre\", \"Segunda torre\", \"Tercera torre\");\n"
            + "    }\n"
            + "    static int paso = 1;\n"
            + "//Función recursiva de busqueda\n"
            + "static void hanoi(int n, String from, String temp, String to) {\n"
            + "        if (n == 0) {\n"
            + "            return;\n"
            + "        }\n"
            + "        hanoi(n - 1, from, to, temp);\n"
            + "        System.out.println(paso + \": Mover disco \" + n + \" de \" + from + \" a \" + to);\n"
            + "        paso++;\n"
            + "        hanoi(n - 1, temp, from, to);\n"
            + "}\n"
            + "\n"
            + "}";
    private String axplusbyequalsn = "//Programa que calcula la solución de\n"
            + "// ax + by = n \n"
            + "\n"
            + "public class AXplusBYequalsN { \n"
            + "\n"
            + "    static void solution(int a, int b, int n) \n"
            + "{ \n"
            + "//A traves de todos los posibles valores\n"
            + "for (int i = 0; i * a <= n; i++) \n"
            + "{ \n"
            + "//Verifica si se satisface la ecuación\n"
            + "if ((n - (i * a)) % b == 0) \n"
            + "            { \n"
            + "                System.out.println(\"x = \" + i +  \n"
            + "                                   \", y = \" +  \n"
            + "                                   (n - (i * a)) / b);     \n"
            + "                return ; \n"
            + "} \n"
            + "        } \n"
            + "\n"
            + "        System.out.println(\"Sin solución\"); \n"
            + "} \n"
            + "\n"
            + "    public static void main (String[] args)  \n"
            + "    { \n"
            + "        int a = 2, b = 3, n = 7; \n"
            + "        solution(a, b, n); \n"
            + "\n"
            + "} \n"
            + "}";
    private String amodxequalb = "/* Programa java que encuentra x tal que\n"
            + "a % x es igual  b.*/\n"
            + "public class AmodXequalB {\n"
            + "\n"
            + "    static void modularEquation(int a, int b) {\n"
            + "// Si a es menos que b, entonces no hay solución\n"
            + "if (a < b) {\n"
            + "            System.out.println(\"No solution possible \");\n"
            + "return;\n"
            + "        }\n"
            + "/*Si a es igual a b, entonces cada número \n"
            + "        más grande que a sera la solución, entonces\n"
            + "        es infinito*/\n"
            + "        if (a == b) {\n"
            + "System.out.println(\"Infinite Solution possible \");\n"
            + "return;\n"
            + "        }\n"
            + "/*todo el número resultante debe ser mayor\n"
            + "        que b y (a-b) deben ser divisibles\n"
            + "        por número resultante\n"
            + "        variable count almacena el número de\n"
            + "        valores posibles*/ \n"
            + "        int count = 0;\n"
            + "        int n = a - b;\n"
            + "        int y = (int) Math.sqrt(a - b);\n"
            + "        for (int i = 1; i <= y; ++i) {\n"
            + "if (n % i == 0) {\n"
            + "/*Revisando por ambos divisor y \n"
            + "                cociente cual divide (a-b) completamente\n"
            + "y mayor que b*/  \n"
            + "                if (n / i > b) {\n"
            + "                    count++;\n"
            + "}\n"
            + "                if (i > b) {\n"
            + "                    count++;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "/* Aqui y es añadido dos veces en la\n"
            + "        ultima iteracón entonces y deberia ser decrementado\n"
            + "        para obtener la solución correcta*/ \n"
            + "if (y * y == n && y > b) {\n"
            + "            count--;\n"
            + "        }\n"
            + "        System.out.println(count);\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int a = 21, b = 5;\n"
            + "        modularEquation(a, b);\n"
            + "}\n"
            + "}";
    private String factorial = "// Programa java que encuentra el \n"
            + "// factorial de un número\n"
            + "public class Factorial {\n"
            + "static int factorial(int n) {\n"
            + "        if (n == 0) {\n"
            + "            return 1;\n"
            + "        }\n"
            + "\n"
            + "        return n * factorial(n - 1);\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "int num = 5;\n"
            + "        System.out.println(\"Factorial de \" + num + \" es \" + factorial(5));\n"
            + "    }\n"
            + "}";
    private String bigfactorial = "// Programa java que calcula factoriales\n"
            + "// de números enormes\n"
            + "\n"
            + "public class BigFactorial { \n"
            + "\n"
            + "    static void factorial(int n) \n"
            + "    { \n"
            + "        int res[] = new int[500]; \n"
            + "        res[0] = 1; \n"
            + "int res_size = 1; \n"
            + "// Aplicamos la formula normal de facotorial\n"
            + "// n! = 1 * 2 * 3 * 4...*n \n"
            + "        for (int x = 2; x <= n; x++) \n"
            + "            res_size = multiply(x, res, res_size); \n"
            + "\n"
            + "        System.out.println(\"Factorial of given number is \"); \n"
            + "        for (int i = res_size - 1; i >= 0; i--) \n"
            + "            System.out.print(res[i]); \n"
            + "    } \n"
            + "\n"
            + "    static int multiply(int x, int res[], int res_size) \n"
            + "{ \n"
            + "        int carry = 0; // inicializar carry\n"
            + "// Uno por uno multiplicamos n con \n"
            + "        //los digitos individuales de res[] \n"
            + "for (int i = 0; i < res_size; i++) \n"
            + "        { \n"
            + "            int prod = res[i] * x + carry; \n"
            + "res[i] = prod % 10; //Almacenar ultimo digito de  \n"
            + "// 'prod' en res[] \n"
            + "            carry = prod/10; // Poner el resto de carry \n"
            + "        } \n"
            + "        //Pone el carry en res e incrementa el tamaño del resultadolt size \n"
            + "while (carry!=0) \n"
            + "        { \n"
            + "            res[res_size] = carry % 10; \n"
            + "            carry = carry / 10; \n"
            + "            res_size++; \n"
            + "        } \n"
            + "        return res_size; \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "{ \n"
            + "        factorial(100); \n"
            + "    } \n"
            + "}";
    private String binomialcoefficients = "// Programa java que  calcula el valor\n"
            + "// de coeficientes binomiales\n"
            + "public class BinomialCoefficients { \n"
            + "// Retorna el valor del coeficiente binomial\n"
            + "// C(n, k) \n"
            + "    static int binomialCoeff(int n, int k)  \n"
            + "    { \n"
            + "\n"
            + "// Casos base\n"
            + "        if (k == 0 || k == n) \n"
            + "            return 1; \n"
            + "\n"
            + "// Recursión\n"
            + "        return binomialCoeff(n - 1, k - 1) +  \n"
            + "                    binomialCoeff(n - 1, k); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args)  \n"
            + "   { \n"
            + "        int n = 5, k = 2; \n"
            + "        System.out.printf(\"Valor de C(%d, %d) is %d \", \n"
            + "                        n, k, binomialCoeff(n, k)); \n"
            + "} \n"
            + "}";
    private String cassiniidentity = "//Programa java que demuestra \n"
            + "// la identidad de Cassini\n"
            + "\n"
            + "public class CassiniIdentity\n"
            + "{ \n"
            + "// Retorna (-1)^n \n"
            + "static int cassini(int n) \n"
            + "    { \n"
            + "       return (n & 1) != 0 ? -1 : 1; \n"
            + "    }  \n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "         int n = 5; \n"
            + "         System.out.println(cassini(n)); \n"
            + "} \n"
            + "}";
    private String epowx = "// Programa eficiente que calcula e elevado x\n"
            + "public class EpowX {\n"
            + "// Función que retorna aproximado de e^x\n"
            + "    // Usando suma de los primeros n terminos\n"
            + "// de la serie de Taylor \n"
            + "    static float exponential(int n, float x) {\n"
            + "        float sum = 1;\n"
            + "        for (int i = n - 1; i > 0; --i) {\n"
            + "            sum = 1 + x * sum / i;\n"
            + "        }\n"
            + "        return sum;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int n = 10;\n"
            + "        float x = 1;\n"
            + "        System.out.println(\"e^x = \" + exponential(n, x));\n"
            + "}\n"
            + "}";
    private String euclideulertheorem = "//Programa que verifica el teorema de Euclides Euler\n"
            + "import java.util.ArrayList;\n"
            + "\n"
            + "public class EuclidEulerTheorem {\n"
            + "\n"
            + "    static ArrayList<Long> power2 = new ArrayList<Long>();\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "//Almacenando potencias de 2 para acceder \n"
            + "        // en tiempo O(1) \n"
            + "for (int i = 0; i < 62; i++) {\n"
            + "            power2.add(0L);\n"
            + "        }\n"
            + "\n"
            + "        for (int i = 0; i <= 60; i++) {\n"
            + "            power2.set(i, (1L << i));\n"
            + "}\n"
            + "        System.out.println(\"Generando los primeros números que satisfacen el teorema de Euclid Euler\\n\");\n"
            + "for (long i = 2; i <= 25; i++) {\n"
            + "            long no = ((power2.get((int) i) - 1L) * (power2.get((int) (i - 1))));\n"
            + "            if (isperfect(no) && (no % 2 == 0)) {\n"
            + "                System.out.println(\"(2^\" + i + \" - 1) * (2^(\" + i + \" - 1)) = \" + no + \"\\n\");\n"
            + "\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static boolean isperfect(long n) // Números perfectos\n"
            + "{   /* Verifica si n es suma perfecta de dividores\n"
            + "        excepto por el número en si mismo*/\n"
            + "long s = -n;\n"
            + "        for (long i = 1; i * i <= n; i++) {\n"
            + "// es i un divisor de n\n"
            + "if (n % i == 0) {\n"
            + "                long factor1 = i, factor2 = n / i;\n"
            + "                s += factor1 + factor2;\n"
            + "// aqui i*i == n\n"
            + "                if (factor1 == factor2) {\n"
            + "                    s -= i;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "        return (n == s);\n"
            + "    }\n"
            + "\n"
            + "    boolean isprime(long n) {\n"
            + "// Verifica cual número es primo o no\n"
            + "for (int i = 2; i * i <= n; i++) {\n"
            + "            if (n % i == 0) {\n"
            + "                return false;\n"
            + "}\n"
            + "        }\n"
            + "        return false;\n"
            + "    }\n"
            + "}";
    private String euclideanalgorithm = "//Programa java que demuestra el algoritmo de Euclides  \n"
            + "public class  EuclideanAlgorithm\n"
            + "{ \n"
            + "// Algoritmo de euclides extendido\n"
            + "public static int gcd(int a, int b) \n"
            + "    { \n"
            + "        if (a == 0) \n"
            + "            return b;    \n"
            + "        return gcd(b%a, a); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        int a = 10, b = 15, g; \n"
            + "        g = gcd(a, b); \n"
            + "        System.out.println(\"GCD(\" + a +  \" , \" + b+ \") = \" + g); \n"
            + "\n"
            + "        a = 35; b = 10; \n"
            + "        g = gcd(a, b); \n"
            + "        System.out.println(\"GCD(\" + a +  \" , \" + b+ \") = \" + g); \n"
            + "\n"
            + "        a = 31; b = 2; \n"
            + "        g = gcd(a, b); \n"
            + "        System.out.println(\"GCD(\" + a +  \" , \" + b+ \") = \" + g); \n"
            + "\n"
            + "} \n"
            + "}";
    private String eulertotient = "// Programa simple que calcula el valor \n"
            + "// de la función  totient Euler\n"
            + "public class EulerTotient { \n"
            + "// Función que retorna gcd de a y b\n"
            + "static int gcd(int a, int b) \n"
            + "    { \n"
            + "        if (a == 0) \n"
            + "            return b; \n"
            + "        return gcd(b % a, a); \n"
            + "} \n"
            + "// Función que evalua función totient de euler\n"
            + "static int phi(int n) \n"
            + "    { \n"
            + "        int result = 1; \n"
            + "        for (int i = 2; i < n; i++) \n"
            + "            if (gcd(i, n) == 1) \n"
            + "                result++; \n"
            + "        return result; \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        int n; \n"
            + "\n"
            + "        for (n = 1; n <= 10; n++) \n"
            + "            System.out.println(\"phi(\" + n + \") = \" + phi(n)); \n"
            + "} \n"
            + "}";
    private String factorialnumdigits = "// Programa java que encuentra número de \n"
            + "// digitos en un factorial\n"
            + "public class FactorialNumDigits  \n"
            + "{   // Retorna el número de digtos\n"
            + "    // en n! \n"
            + "static int findDigits(int n) \n"
            + "{   // Factorial existe solo para n>=0 \n"
            + "if (n < 0) \n"
            + "            return 0; \n"
            + "// Caso base\n"
            + "        if (n <= 1) \n"
            + "return 1; \n"
            + "// si no itera atravez de n y calcula el valor\n"
            + "double digits = 0; \n"
            + "        for (int i=2; i<=n; i++) \n"
            + "            digits += Math.log10(i); \n"
            + "\n"
            + "        return (int)(Math.floor(digits)) + 1; \n"
            + "    } \n"
            + "\n"
            + "    public static void main (String[] args)  \n"
            + "    { \n"
            + "        System.out.println(findDigits(1)); \n"
            + "        System.out.println(findDigits(5)); \n"
            + "        System.out.println(findDigits(10)); \n"
            + "        System.out.println(findDigits(120)); \n"
            + "} \n"
            + "}";
    private String factorialnumdigitsop = "// Programa java que encuentra el número de digitos\n"
            + "// en un factorial\n"
            + "public class FactorialNumDigitsOP {\n"
            + "\n"
            + "    public static double M_E = 2.71828182845904523536;\n"
            + "    public static double M_PI = 3.141592654;\n"
            + "/* Funcion que retorna el número de digitos presente en \n"
            + "    n! desde que el resultado sea muy largo*/\n"
            + "static long findDigits(int n) {\n"
            + "\n"
            + "        if (n < 0) {\n"
            + "            return 0;\n"
            + "        }\n"
            + "\n"
            + "        // caso base\n"
            + "        if (n <= 1) {\n"
            + "return 1;\n"
            + "        }\n"
            + "// Usamos la formula de Kamenestsky para\n"
            + "        // calcular el número de digitos\n"
            + "        double x = (n * Math.log10(n / M_E)\n"
            + "+ Math.log10(2 * M_PI * n)\n"
            + "                / 2.0);\n"
            + "\n"
            + "        return (long) Math.floor(x) + 1;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        System.out.println(findDigits(1));\n"
            + "        System.out.println(findDigits(50000000));\n"
            + "        System.out.println(findDigits(1000000000));\n"
            + "        System.out.println(findDigits(120));\n"
            + "}\n"
            + "}";
    private String fermatlittletheorem = "/*Programa de Java para encontrar modular.\n"
            + " inverso de un módulo bajo m\n"
            + " utilizando el pequeño teorema de Fermat.\n"
            + " Este programa funciona solo si m es primo.*/\n"
            + "public class FermatLittleTheorem\n"
            + "{ \n"
            + "    static int __gcd(int a, int b) \n"
            + "    { \n"
            + "\n"
            + "        if(b == 0)  \n"
            + "        { \n"
            + "            return a; \n"
            + "        } \n"
            + "        else \n"
            + "        { \n"
            + "            return __gcd(b, a % b); \n"
            + "} \n"
            + "    } \n"
            + "// Computa x^y bajo modulo m\n"
            + "static int power(int x,int y,int m) \n"
            + "    { \n"
            + "        if (y == 0) \n"
            + "            return 1; \n"
            + "        int p = power(x, y / 2, m) % m; \n"
            + "        p = (p * p) % m; \n"
            + "\n"
            + "        return (y % 2 == 0) ? p : (x * p) % m; \n"
            + "} \n"
            + "// Función para encontrar modular\n"
            + "    // inverso bajo un modulo m\n"
            + "    // Asumimos m es primo\n"
            + "    static void modInverse(int a, int m) \n"
            + "    { \n"
            + "        if (__gcd(a, m) != 1) \n"
            + "            System.out.print(\"No existe inverso\"); \n"
            + "\n"
            + "        else { \n"
            + "// Si a y m son primos relativos, entonces\n"
            + "            // modulo inverso es a^(m-2) mod m \n"
            + "            System.out.print(\"Multiplicación modular inversa es \"\n"
            + "+power(a, m - 2, m)); \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "    public static void main (String[] args)  \n"
            + "{ \n"
            + "        int a = 3, m = 11; \n"
            + "        modInverse(a, m); \n"
            + "    } \n"
            + "}";
    private String fibonaccigoldenratio = "// Programa java que encuentra el \n"
            + "// nesimo número fibonacci\n"
            + "public class FiboGoldenRatio\n"
            + "{   //Valor aproximado del golden ratio\n"
            + "// Approximate value of golden ratio \n"
            + "    static double PHI = 1.6180339; \n"
            + "// Números fibonacci hasta 5\n"
            + "    static int f[] = { 0, 1, 1, 2, 3, 5 }; \n"
            + "// Función que encuentra nesimo\n"
            + "// número fibonacci\n"
            + "static int fib (int n) \n"
            + "{   // Números fibonacci menores a 6\n"
            + "        if (n < 6) \n"
            + "            return f[n]; \n"
            + "// Si no comience conteo desde el quinto\n"
            + "int t = 5; \n"
            + "        int fn = 5; \n"
            + "        while (t < n) { \n"
            + "            fn = (int)Math.round(fn * PHI); \n"
            + "            t++; \n"
            + "        } \n"
            + "        return fn;  \n"
            + "    } \n"
            + "\n"
            + "    public static void main (String[] args)  \n"
            + "    { \n"
            + "        int n = 9; \n"
            + "        System.out.println(n + \" número fibonacci= \"\n"
            + "                                                +fib(n)); \n"
            + "} \n"
            + "}";
    private String floatgcd = "// Programa java que encuentra el GCD de dos\n"
            + "// números flotantes\n"
            + "public class FloatGCD { \n"
            + "// Funcion recursiva que retorna gcd de a y b  \n"
            + "static double gcd(double a, double b) \n"
            + "    { \n"
            + "        if (a < b) \n"
            + "            return gcd(b, a); \n"
            + "\n"
            + "// Caso base\n"
            + "        if (Math.abs(b) < 0.001) \n"
            + "            return a; \n"
            + "\n"
            + "        else\n"
            + "            return (gcd(b, a -  \n"
            + "                   Math.floor(a / b) * b)); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        double a = 1.20, b = 22.5; \n"
            + "        System.out.printf(\"%.1f\" ,gcd(a, b)); \n"
            + "} \n"
            + "} ";
    private String fractionsproduct = "//Programa java que encuentra el producto\n"
            + "// de N fracciones en forma reducida\n"
            + "\n"
            + "public class Fractionsproduct {\n"
            + "// Función que retorna el gcd de a y b\n"
            + "static int gcd(int a, int b) {\n"
            + "        if (a == 0) {\n"
            + "            return b;\n"
            + "        }\n"
            + "        return gcd(b % a, a);\n"
            + "    }\n"
            + "\n"
            + "    static void productReduce(int n, int num[],\n"
            + "            int den[]) {\n"
            + "        int new_num = 1, new_den = 1;\n"
            + "//Encontrando el producto de todos los N\n"
            + "// numeradores y denominadores\n"
            + "        for (int i = 0; i < n; i++) {\n"
            + "            new_num *= num[i];\n"
            + "new_den *= den[i];\n"
            + "        }\n"
            + "// Encontrando GCD de nuevo numerados y denominador \n"
            + "int GCD = gcd(new_num, new_den);\n"
            + "// Convirtiendo en forma reducids\n"
            + "        new_num /= GCD;\n"
            + "new_den /= GCD;\n"
            + "        System.out.println(new_num + \"/\" + new_den);\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int n = 3;\n"
            + "        int num[] = {1, 2, 5};\n"
            + "        int den[] = {2, 1, 6};\n"
            + "productReduce(n, num, den);\n"
            + "\n"
            + "    }\n"
            + "}";
    private String josephus = "//Implementación java de dos Algoritmos que realizan la\n"
            + "// busqueda josephus sabiendo número personas y tamaño\n"
            + "// de salto\n"
            + "public class Josephus {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        System.out.println(josephus(6, 2));\n"
            + "        System.out.println(josephusModular(6, 2));\n"
            + "    }\n"
            + "//Busqueda por algoritmo voraz\n"
            + "    static int josephus(int n, int k) {\n"
            + "        int d[] = new int[n + 1];\n"
            + "        d[0] = -1;\n"
            + "        for (int i = 1; i <= n; i++) {\n"
            + "            d[i] = i;\n"
            + "        }\n"
            + "        int i = n;\n"
            + "        int a = 0;\n"
            + "        while (i != 1) {\n"
            + "            i--;\n"
            + "            a = next(a, k, d);\n"
            + "            d[a] = -1;\n"
            + "            a++;\n"
            + "        }\n"
            + "        for ( i = 0; d[i] == -1; i++);\n"
            + "return d[i];\n"
            + "    }\n"
            + "//Calcule la posición siguiente a caer \n"
            + "static int next(int a, int k, int[] d) {\n"
            + "        int j = a - 1;\n"
            + "        for (int i = 0; i < k;) {\n"
            + "            j = (j + 1) % d.length;\n"
            + "            if (d[j] != -1) {\n"
            + "                i++;\n"
            + "            }\n"
            + "        }\n"
            + "        return j;\n"
            + "    }\n"
            + " //busqueda por matematica modular\n"
            + "    static int josephusModular(int n, int k) {\n"
            + "        int f = 0;\n"
            + "        for (int i = 1; i <= n; i++) {\n"
            + "            f = (f + k) % i;\n"
            + "\n"
            + "        }\n"
            + "        return f + 1;\n"
            + "}\n"
            + "\n"
            + "}";
    private String cardinalnumbers = "//Programa java que convierte números ordinales\n"
            + "// en números cardinales en ingles\n"
            + "public class CardinalNumbers {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        for (int i = 1; i <= 10; i++) {\n"
            + "            System.out.println(i+cardinalNumber(i));\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static String cardinalNumber(int n) {\n"
            + "if (n % 10 == 1 && n % 100 != 11) {\n"
            + "return \"st\";\n"
            + "        }\n"
            + "        if (n % 10 == 2 && n % 100 != 12) {\n"
            + "return \"nd\";\n"
            + "        }\n"
            + "        if (n % 10 == 3 && n % 100 != 13) {\n"
            + "            return \"rd\";\n"
            + "}\n"
            + "        return \"th\";\n"
            + "    }\n"
            + "}";
    private String romannumbers = "//Implementación java que convierte números decimales\n"
            + "// a números romanos y viceversa usando matematica modular\n"
            + "public class RomanNumbers {\n"
            + "// Arrays constantes de letras romanas\n"
            + "    static String unit[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n"
            + "    static String ten[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n"
            + "    static String hnd[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        System.out.println(toRoman(122));\n"
            + "        System.out.println(toDecimal(\"CXXII\"));\n"
            + "}\n"
            + "//Función que convierte a romano\n"
            + "    static String toRoman(int n) {\n"
            + "//Los números romanos no tienen letras\n"
            + "        //más alla de los miles\n"
            + "        int a;\n"
            + "StringBuilder sb = new StringBuilder();\n"
            + "        if (n >= 1000) {\n"
            + "            a = n / 1000;\n"
            + "            for (int i = 1; i <= a; i++) {\n"
            + "sb.append(\"M\");\n"
            + "            }\n"
            + "            n %= 1000;\n"
            + "        }\n"
            + "//Letras de las centenas\n"
            + "sb.append(hnd[n / 100]);\n"
            + "        n = n % 100;\n"
            + "//Letras de las decenas\n"
            + "        sb.append(ten[n / 10]);\n"
            + "//Letras de las unidades\n"
            + "        sb.append(unit[n % 10]);\n"
            + "        return sb.toString();\n"
            + "    }\n"
            + "//Devuelve el valor de cada letra\n"
            + "static int valor(char ch) {\n"
            + "        switch (ch) {\n"
            + "            case 'I':\n"
            + "                return 1;\n"
            + "            case 'V':\n"
            + "                return 5;\n"
            + "            case 'X':\n"
            + "                return 10;\n"
            + "            case 'L':\n"
            + "                return 50;\n"
            + "            case 'C':\n"
            + "                return 100;\n"
            + "            case 'D':\n"
            + "                return 500;\n"
            + "            case 'M':\n"
            + "return 1000;\n"
            + "        }\n"
            + "        return 0;\n"
            + "    }\n"
            + "    //Función que convierte a decimal\n"
            + "static int toDecimal(String num) {\n"
            + "        int sum = 0;\n"
            + "        int last = 0;\n"
            + "        int next;\n"
            + "//Toma cada letra y verifica si esta antes o despues \n"
            + "        // suma si esta despues, resta si esta antes\n"
            + "for (int i = num.length() - 1; i >= 0; i--) {\n"
            + "            next = valor(num.charAt(i));\n"
            + "            if (last <= next) {\n"
            + "                sum += next;\n"
            + "            } else {\n"
            + "                sum -= next;\n"
            + "            }\n"
            + "            last = next;\n"
            + "}\n"
            + "        return sum;\n"
            + "\n"
            + "    }\n"
            + "}";
    private String gcdmultiple = "// Programa java que encuentra\n"
            + "// el maximo comun divisor de 2 o más \n"
            + "//números\n"
            + "public class GCDMultiple { \n"
            + "// Funcion que retorna gcd de a y b\n"
            + "static int gcd(int a, int b) \n"
            + "    { \n"
            + "        if (a == 0) \n"
            + "            return b; \n"
            + "        return gcd(b % a, a); \n"
            + "} \n"
            + "// Función que encuentra gcd de un arreglo de números\n"
            + "static int findGCD(int arr[], int n) \n"
            + "    { \n"
            + "        int result = arr[0]; \n"
            + "        for (int i = 1; i < n; i++) \n"
            + "            result = gcd(arr[i], result); \n"
            + "\n"
            + "        return result; \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        int arr[] = { 2, 4, 6, 8, 16 }; \n"
            + "        int n = arr.length; \n"
            + "        System.out.println(findGCD(arr, n)); \n"
            + "} \n"
            + "}";
    private String hardyramanujantheorem = "// Programa java que cuenta todos los \n"
            + "// factores primos\n"
            + "\n"
            + "public class HardyRamanujanTheorem { \n"
            + "// Una función que cuenta factores primos de \n"
            + "//un número n\n"
            + "    static int exactPrimeFactorCount(int n) \n"
            + "    { \n"
            + "        int count = 0; \n"
            + "        if (n % 2 == 0) { \n"
            + "            count++; \n"
            + "while (n % 2 == 0) \n"
            + "                n = n / 2; \n"
            + "        } \n"
            + "        // n debe ser impar en este punto, asi \n"
            + "        //podemos saltar un elemento (i=i+2)\n"
            + "for (int i = 3; i <= Math.sqrt(n); i = i + 2)  \n"
            + "        { \n"
            + "            if (n % i == 0) { \n"
            + "                count++; \n"
            + "                while (n % i == 0) \n"
            + "n = n / i; \n"
            + "            } \n"
            + "        } \n"
            + "        // Esta condición es para controlar el caso\n"
            + "        // cuando n es un factor primo más grande que 2\n"
            + "if (n > 2) \n"
            + "            count++; \n"
            + "        return count; \n"
            + "    } \n"
            + "\n"
            + "    public static void main (String[] args)  \n"
            + "{ \n"
            + "        int n = 51242183; \n"
            + "        System.out.println( \"El número de diferentes \"\n"
            + "                            + \" factores primos es \"\n"
            + "            + exactPrimeFactorCount(n)); \n"
            + "        System.out.println( \"El valor de (log(n))\"\n"
            + "                   + \" es \" + Math.log(Math.log(n))) ; \n"
            + "    } \n"
            + "}";
    private String hoaxnumber = "// Programa java que verifica si un número es \n"
            + "// falso o no\n"
            + "import java.util.*; \n"
            + "\n"
            + "public class HoaxNumber { \n"
            + "    /*Función que encuentra distintos factores primos\n"
            + "dado un número n*/\n"
            + "\n"
            + "    static List<Integer> primeFactors(int n) \n"
            + "    { \n"
            + "        List<Integer> res = new ArrayList<>(); \n"
            + "        if (n % 2 == 0)  \n"
            + "        { \n"
            + "            while (n % 2 == 0) \n"
            + "                n = n / 2; \n"
            + "res.add(2); \n"
            + "        } \n"
            + "/*N es impar en este punto\n"
            + "        desde que ya no sea divisible por 2\n"
            + "        entonces podemos probar solamente\n"
            + "        por números impares, mientras sean \n"
            + "factores de n*/\n"
            + "        for (int i = 3; i <= Math.sqrt(n); \n"
            + "                                i = i + 2)  \n"
            + "        { \n"
            + "//Verifica si i es factor primo\n"
            + "            if (n % i == 0)  \n"
            + "            { \n"
            + "                while (n % i == 0) \n"
            + "                    n = n / i; \n"
            + "                res.add(i); \n"
            + "} \n"
            + "        } \n"
            + "/*Esra condición es para controlar\n"
            + "        el caso cuando n es un número primo\n"
            + "        más grande que 2*/\n"
            + "        if (n > 2) \n"
            + "res.add(n); \n"
            + "        return res; \n"
            + "} \n"
            + "/*Función que calcula suma de digitos de distintos\n"
            + "    factores primos de dado n y la suma de digitos\n"
            + "    de número n. compara las sumás obtenidas*/\n"
            + "static boolean isHoax(int n) \n"
            + "{  \n"
            + "/*Distintos factores primos de n seran almacenados\n"
            + "        en vector pf*/ \n"
            + "        List<Integer> pf = primeFactors(n); \n"
            + "/* Si n es un número primo\n"
            + "        no puede ser un número falso*/\n"
            + "if (pf.get(0) == n) \n"
            + "            return false; \n"
            + "/*Encontrando suma de digitos de \n"
            + "        distintos factores primos de n*/\n"
            + "int all_pf_sum = 0;  \n"
            + "        for (int i = 0; i < pf.size(); i++) \n"
            + "{ \n"
            + "// Encontramos la suma de digitos de \n"
            + "            // el actual factor primo pf[i] \n"
            + "int pf_sum; \n"
            + "            for (pf_sum = 0; pf.get(i) > 0;  \n"
            + "                pf_sum += pf.get(i) % 10,  \n"
            + "                   pf.set(i,pf.get(i) / 10)); \n"
            + "\n"
            + "            all_pf_sum += pf_sum; \n"
            + "} \n"
            + "// Encontrando suma de digitos de n\n"
            + "int sum_n; \n"
            + "        for (sum_n = 0; n > 0; sum_n += n % 10, \n"
            + "n /= 10); \n"
            + "// Comparando las dos sumás calculadas\n"
            + "return sum_n == all_pf_sum; \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        int n = 84; \n"
            + "        if (isHoax(n)) \n"
            + "System.out.print( \"Un número falso\\n\"); \n"
            + "        else\n"
            + "            System.out.print(\"No es número falso\\n\"); \n"
            + "    } \n"
            + "}";
    private String largestpowdividesfactorial = "/* Programa java que encuentra la potencia más larga de\n"
            + "un número (La cual puede ser compuesta) que divide \n"
            + "factorial*/\n"
            + "public class LargestPowDividesFactorial {\n"
            + "\n"
            + "/* For que encuentra la maxima potencia de número primo\n"
            + "    p que puede dividir un número facorial*/\n"
            + "static int findPowerPrime(int fact, int p) {\n"
            + "        int res = 0;\n"
            + "        while (fact > 0) {\n"
            + "            res += fact / p;\n"
            + "fact /= p;\n"
            + "        }\n"
            + "\n"
            + "        return res;\n"
            + "    }\n"
            + "\n"
            + "// Retorna la suma de todos los factores de n\n"
            + "static int findPowerComposite(int fact, int n) {\n"
            + "// Para almacernar el resultado ( Potencia minima de un \n"
            + "        // factor primo que divide fact)\n"
            + "int res = Integer.MAX_VALUE;\n"
            + "// Atravesar atraves de todos los factores\n"
            + "// primos de n\n"
            + "        for (int i = 2; i <= Math.sqrt(n); i++) {\n"
            + "// contador para contar la potencia del número primo\n"
            + "int count = 0;\n"
            + "            if (n % i == 0) {\n"
            + "                count++;\n"
            + "                n = n / i;\n"
            + "            }\n"
            + "            if (count > 0) {\n"
            + "// Maxima potencia de i que divide \n"
            + "                // fact, dividimos por count para \n"
            + "                // manejar multiples ocurrencias de \n"
            + "// un factor primo\n"
            + "                int curr_pow = findPowerPrime(fact, i) / count;\n"
            + "res = Math.min(res, curr_pow);\n"
            + "            }\n"
            + "        }\n"
            + "// Esta condición es para manejar \n"
            + "        // el caso cuando n es un número primo mayor \n"
            + "// que 2\n"
            + "        if (n >= 2) {\n"
            + "            int curr_pow = findPowerPrime(fact, n);\n"
            + "            res = Math.min(res, curr_pow);\n"
            + "        }\n"
            + "        return res;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int fact = 146, n = 5;\n"
            + "        System.out.println(findPowerComposite(fact, n));\n"
            + "}\n"
            + "}";
    private String lcmofarrayelements = "// Programa java que calcula el minimo común multiplo\n"
            + "// de n elementos\n"
            + "\n"
            + "public class Lcmofarrayelements {\n"
            + "\n"
            + "    public static long lcm_of_array_elements(int[] element_array) {\n"
            + "        long lcm_of_array_elements = 1;\n"
            + "        int divisor = 2;\n"
            + "        while (true) {\n"
            + "            int counter = 0;\n"
            + "            boolean divisible = false;\n"
            + "            for (int i = 0; i < element_array.length; i++) {\n"
            + "\n"
            + "// lcm_of_array_elements (n1, n2, ... 0) = 0. \n"
            + "// Para cada número negativo lo convertimos\n"
            + "                // En positivo y calculamos lcm_of_array_elements. \n"
            + "if (element_array[i] == 0) {\n"
            + "                    return 0;\n"
            + "                } else if (element_array[i] < 0) {\n"
            + "                    element_array[i] = element_array[i] * (-1);\n"
            + "                }\n"
            + "                if (element_array[i] == 1) {\n"
            + "                    counter++;\n"
            + "}\n"
            + "/* Divide element_array por diviser si completa\n"
            + "división */\n"
            + "                if (element_array[i] % divisor == 0) {\n"
            + "                    divisible = true;\n"
            + "                    element_array[i] = element_array[i] / divisor;\n"
            + "}\n"
            + "            }\n"
            + "/*Si el divisor es capaz de dividir completamente cualquier número.\n"
            + "            de la matriz multiplicar con lcm_of_array_elements\n"
            + "            y almacenar en lcm_of_array_elements y continuar\n"
            + "            al mismo divisor para encontrar el siguiente factor.\n"
            + "            si no incrementar divisor*/\n"
            + "\n"
            + "            if (divisible) {\n"
            + "lcm_of_array_elements = lcm_of_array_elements * divisor;\n"
            + "} else {\n"
            + "                divisor++;\n"
            + "            }\n"
            + "//Verifica si todo element_Array es 1 indicando\n"
            + "            // encontramos todos los factores y terminamos el ciclo\n"
            + "if (counter == element_array.length) {\n"
            + "                return lcm_of_array_elements;\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int[] element_array = {2, 7, 3, 9, 4};\n"
            + "        System.out.println(lcm_of_array_elements(element_array));\n"
            + "}\n"
            + "}";
    private String leonardonumber = "//Pograma java qque busca el nesimo número\n"
            + "// de Leonardo\n"
            + "public class LeonardoNumber { \n"
            + "    static int leonardo(int n) \n"
            + "    { \n"
            + "        if (n == 0 || n == 1) \n"
            + "            return 1; \n"
            + "        return (leonardo(n - 1) + leonardo(n - 2) + 1); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "{ \n"
            + "        System.out.println(leonardo(3)); \n"
            + "    } \n"
            + "}";
    private String modularexponentiation = "// Programa iteratico que calcula \n"
            + "// potencia modular \n"
            + "public class ModularExponentiation { \n"
            + "\n"
            + "/* Función iterativa que calcula\n"
            + "       (x^y)%p in O(log y) */\n"
            + "static int power(int x, int y, int p) \n"
            + "{ \n"
            + "// Inicializar resultado\n"
            + "        int res = 1;      \n"
            + "// Actualiza x si es más que    \n"
            + "        // o igual a p \n"
            + "        x = x % p; \n"
            + "        while (y > 0) \n"
            + "        {   //Si y es impar, multiplica x con res\n"
            + "            if((y & 1)==1) \n"
            + "                res = (res * x) % p; \n"
            + "// y debe ser par ahora\n"
            + "            // y = y / 2 \n"
            + "            y = y >> 1;  \n"
            + "            x = (x * x) % p;  \n"
            + "        } \n"
            + "        return res; \n"
            + "} \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        int x = 2; \n"
            + "        int y = 5; \n"
            + "        int p = 13; \n"
            + "System.out.println(\"La potencia es \" + power(x, y, p)); \n"
            + "    } \n"
            + "} ";
    private String multipleeulertotient = "// Programa java que eficientemente calcula valores de\n"
            + "// la formula totient de euler para multiples entradas\n"
            + "\n"
            + "import java.util.*;\n"
            + "\n"
            + "public class MultipleEulerTotient {\n"
            + "\n"
            + "static int MAX = 100001;\n"
            + "// Almacena números primos arriba hasta MAX -1\n"
            + "static ArrayList<Integer> p = new ArrayList<Integer>();\n"
            + "// Encurntra los números primos hasta MAX-1 Y\n"
            + "// los almacena en p\n"
            + "\n"
            + "    static void sieve() {\n"
            + "int[] isPrime = new int[MAX + 1];\n"
            + "        for (int i = 2; i <= MAX; i++) {\n"
            + "// Si prime[i] no es marcado antes\n"
            + "            if (isPrime[i] == 0) {\n"
            + "// Llena el vector para cada nuevo\n"
            + "                // primo encontrado\n"
            + "                p.add(i);\n"
            + "for (int j = 2; i * j <= MAX; j++) {\n"
            + "isPrime[i * j] = 1;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "// Función que encuentra totient de n\n"
            + "static int phi(int n) {\n"
            + "int res = n;\n"
            + "// Este ciclo corre sqrt(n / ln(n)) veces\n"
            + "for (int i = 0; p.get(i) * p.get(i) <= n; i++) {\n"
            + "if (n % p.get(i) == 0) {\n"
            + "                // resta multiplos de p[i] de r\n"
            + "                res -= (res / p.get(i));\n"
            + "// Remueve todas las ocurrencias de p[i] en n\n"
            + "while (n % p.get(i) == 0) {\n"
            + "n /= p.get(i);\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "// cuando n es un factor primo mayor \n"
            + "// que sqrt(n) \n"
            + "        if (n > 1) {\n"
            + "            res -= (res / n);\n"
            + "        }\n"
            + "        return res;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) { \n"
            + "//Preprocesa todos los primos hasta 10 ^ 5  \n"
            + "sieve();\n"
            + "        System.out.println(phi(11));\n"
            + "        System.out.println(phi(21));\n"
            + "        System.out.println(phi(31));\n"
            + "        System.out.println(phi(41));\n"
            + "        System.out.println(phi(51));\n"
            + "        System.out.println(phi(61));\n"
            + "        System.out.println(phi(91));\n"
            + "System.out.println(phi(101));\n"
            + "\n"
            + "    }\n"
            + "}";
    private String naturalcoprimesum = "/* Código de Java para determinar si los números\n"
            + "1 a N se puede dividir en dos conjuntos\n"
            + "tal que la diferencia absoluta entre\n"
            + "la suma de estos dos conjuntos es M y estos\n"
            + "dos sumás son co-primos*/\n"
            + "public class NaturalCoprimeSum  \n"
            + "{ \n"
            + "    static int GCD (int a, int b) \n"
            + "    { \n"
            + "        return b == 0 ? a : GCD(b, a % b); \n"
            + "} \n"
            + "/*función que devuelve valor booleano\n"
            + "     sobre la base de si es posible\n"
            + "     dividir 1 a N números en dos conjuntos\n"
            + "     Que satisfacen las condiciones dadas.*/\n"
            + "\n"
            + "static boolean isSplittable(int n, int m) \n"
            + "{ \n"
            + "// Inicializando suma total de 1\n"
            + "        //a n \n"
            + "int total_sum = (n * (n + 1)) / 2; \n"
            + "        /*desde (1) total_sum = sum_s1 + sum_s2 \n"
            + "y (2) m = sum_s1 - sum_s2 asumiendo \n"
            + "        sum_s1> sum_s2. resolviendo estas 2 \n"
            + "        ecuaciones para obtener sum_s1 y sum_s2*/\n"
            + "int sum_s1 = (total_sum + m) / 2; \n"
            + "        // total_sum = sum_s1 + sum_s2 \n"
            + "        // y asi \n"
            + "        int sum_s2 = total_sum - sum_s1; \n"
            + "/*Si la suma total es menor que la \n"
            + "        diferencia absoluta, no hay forma \n"
            + "        de que podamos dividir n números \n"
            + "        en dos conjuntos, así que devuelva falso*/\n"
            + "if (total_sum < m) \n"
            + "            return false; \n"
            + "/*Compruebe si estas dos sumás son\n"
            + "        enteros y se suman a\n"
            + "        suma total y también si su\n"
            + "        La diferencia absoluta es m.*/\n"
            + "if (sum_s1 + sum_s2 == total_sum &&\n"
            + "sum_s1 - sum_s2 == m) \n"
            + "// Ahora si las dos sumás son coprimos\n"
            + "            // Entonces retorna true, si no false\n"
            + "return (GCD(sum_s1, sum_s2) == 1); \n"
            + "/*si dos sumás no suman la suma total\n"
            + "          o si su diferencia absoluta.\n"
            + "         no es m, entonces no hay manera de\n"
            + "         dividir n números, por lo tanto retorna false*/ \n"
            + "return false; \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String args[])  \n"
            + "    { \n"
            + "        int n = 5, m = 7; \n"
            + "        if (isSplittable(n, m)) \n"
            + "            System.out.println(\"Si\"); \n"
            + "        else\n"
            + "            System.out.println(\"No\"); \n"
            + "\n"
            + "} \n"
            + "}";
    private String zeckendorftheorem = "/*Programa java para el Teorema de Zeckendorf, \n"
            + "encuentra la representación de n como suma de \n"
            + "números de fibonacci no vecinos*/\n"
            + "public class ZeckendorfTheorem { \n"
            + "    public static int nearestSmallerEqFib(int n) \n"
            + "    { \n"
            + "// Casos base\n"
            + "        if (n == 0 || n == 1) \n"
            + "            return n; \n"
            + "//Encuentra el mayor número fibonacci menor que n \n"
            + "int f1 = 0, f2 = 1, f3 = 1; \n"
            + "        while (f3 <= n) { \n"
            + "            f1 = f2; \n"
            + "            f2 = f3; \n"
            + "            f3 = f1 + f2; \n"
            + "        } \n"
            + "        return f2; \n"
            + "} \n"
            + "// Imprime representación de fibonacci  \n"
            + "    public static void printFibRepresntation(int n) \n"
            + "    { \n"
            + "        while (n > 0) {     \n"
            + "// Encuentra el mayor número fibonacci menor \n"
            + "            // o igual que n \n"
            + "            int f = nearestSmallerEqFib(n); \n"
            + "// Imprime el número fibonacci encontrado\n"
            + "            System.out.print(f + \" \"); \n"
            + "// Reduce n \n"
            + "            n = n - f; \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "{ \n"
            + "        int n = 30; \n"
            + "        System.out.println(\"Representación de fibonacci no vecinos \"\n"
            + "                           + \" de  \" + n + \" es\");   \n"
            + "        printFibRepresntation(n); \n"
            + "    } \n"
            + "}";
    private String rossertheorem = "// Programa java que verifica el Teorema de Rosser\n"
            + "import java.util.*; \n"
            + "public class RosserTheorem \n"
            + "{ \n"
            + "    static ArrayList<Integer> prime=new ArrayList<Integer>();  \n"
            + "// Criba de Eratostenes\n"
            + "    static void sieve() \n"
            + "{ \n"
            + "        int n = 10000; \n"
            + "        boolean []isprime=new boolean[n+2]; \n"
            + "        for(int i=0;i<n;i++) \n"
            + "            isprime[i]=true;      \n"
            + "        isprime[0]=false; \n"
            + "        isprime[1] =false; \n"
            + "        for (int i = 2; i <= n; i++) { \n"
            + "            if (isprime[i]) { \n"
            + "                for (int j = i * i; j <= n; j += i) \n"
            + "isprime[j] =false; \n"
            + "            } \n"
            + "        } \n"
            + "//Almacena primos en prime[] \n"
            + "for (int i = 0; i <= n; i++) \n"
            + "            if (isprime[i]) \n"
            + "                prime.add(i); \n"
            + "} \n"
            + "\n"
            + "// Verifica el TEOREMA DE  ROSSER para todos los números  \n"
            + "// Menores a n\n"
            + "    static void verifyRosser(int n) \n"
            + "{ \n"
            + "        System.out.println(\"TEOREMA DE ROSSER: nesimo número primo > n * (ln n)\"); \n"
            + "\n"
            + "for (int i = 0; i < n; i++) \n"
            + "            if (prime.get(i) > (i + 1) * Math.log(i + 1)) { \n"
            + "                System.out.println( \"para n = \" + (i+1)  \n"
            + "+ \", nesimo número primo = \"\n"
            + "                    + prime.get(i) + \"\\n\\t\"\n"
            + "+ prime.get(i) + \" > \" + (i + 1) \n"
            + "                    + \" * ln(\" + (i + 1) + \")\"); \n"
            + "            } \n"
            + "    } \n"
            + "    public static void main(String [] args) \n"
            + "{ \n"
            + "        sieve(); \n"
            + "        verifyRosser(20);        \n"
            + "    } \n"
            + "}";
    private String sieveoderathosthenesoptimizated = "/*Programa java que genera todos los números primos\n"
            + "menores a N en O(N) Eratostenes Optimizado*/\n"
            + "import java.util.ArrayList;\n"
            + "\n"
            + "public class SieveofEratosthenesOptimizated\n"
            + "{ \n"
            + "    static final int MAX_SIZE = 1000001; \n"
            + "// isPrime[] : isPrime[i] es true si el número es primo  \n"
            + "    // prime[] : Almacena todos los números primos menores a N \n"
            + "    // SPF[] Almacena los factores primos más pequeños de un número \n"
            + "    // [Por ejemplo : factor primo más pequeño que '8' y '16' es  \n"
            + "    //  '2' entonces nosotros ponemos SPF[8]=2 , SPF[16]=2 ] \n"
            + "static ArrayList<Boolean>isprime = new ArrayList<>(MAX_SIZE); \n"
            + "    static ArrayList<Integer>prime = new ArrayList<>(); \n"
            + "    static ArrayList<Integer>SPF = new ArrayList<>(MAX_SIZE); \n"
            + "// Metodo que genera todos los factores primos menores de N\n"
            + "static void manipulated_seive(int N) \n"
            + "{   // 0 y 1 no son primos\n"
            + "        isprime.set(0, false); \n"
            + "        isprime.set(1, false); \n"
            + "\n"
            + "// llena el resto de las entradas\n"
            + "for (int i=2; i<N ; i++) \n"
            + "{ \n"
            + "// si isPrime[i] == True entonces i es  \n"
            + "            // número primo\n"
            + "if (isprime.get(i)) \n"
            + "            { \n"
            + "// pone i dentro de prime[]  \n"
            + "prime.add(i); \n"
            + "// un número primo es su propio factor primo\n"
            + "                // más pequeño\n"
            + "                SPF.set(i,i); \n"
            + "            } \n"
            + "/*Eliminar todos los múltiplos de i * prime [j] que son\n"
            + "            no primos haciendo isPrime [i * prime [j]] = false\n"
            + "            y ponga el factor primo más pequeño de i * Prime [j] como prime [j]\n"
            + "            [Por ejemplo: dejemos i = 5, j = 0, prime[j] = 2 [i * prime [j] = 		10]\n"
            + "            por lo que el factor primo más pequeño de '10' es '2' que es prime 		[j]]\n"
            + "            este bucle se ejecuta solo una vez para el número que no es primo*/\n"
            + "\n"
            + "for (int j=0; \n"
            + "                 j < prime.size() &&\n"
            + "                 i*prime.get(j) < N && prime.get(j) <= SPF.get(i); \n"
            + "                 j++) \n"
            + "            { \n"
            + "                isprime.set(i*prime.get(j),false); \n"
            + "// Pone el factor primo más pequeño de i*prime[j] \n"
            + "SPF.set(i*prime.get(j),prime.get(j)) ; \n"
            + "            } \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String args[])  \n"
            + "{ \n"
            + "        int N = 13 ; //Debe ser menor que  MAX_SIZE        \n"
            + "// inicializando isprime y SPF\n"
            + "        for (int i = 0; i < MAX_SIZE; i++){ \n"
            + "            isprime.add(true); \n"
            + "            SPF.add(2); \n"
            + "}      \n"
            + "        manipulated_seive(N);   \n"
            + "//Imprima todos los números primos menores que n \n"
            + "for (int i=0; i<prime.size() && prime.get(i) <= N ; i++) \n"
            + "            System.out.print(prime.get(i) + \" \"); \n"
            + "} \n"
            + "}";
    private String smithnumber = "// Programa java que verifica si un número es \n"
            + "// número de Smith o no\n"
            + "import java.util.ArrayList;\n"
            + "\n"
            + "public class SmithNumber \n"
            + "{ \n"
            + "\n"
            + "    static int MAX  = 10000; \n"
            + "//Array que almacena todos los primos menores o iguales\n"
            + "// a 10^6\n"
            + "    static ArrayList <Integer>  primes = new ArrayList<>(); \n"
            + "//Función de la criba de Sundaram\n"
            + "    static void sieveSundaram() \n"
            + "    { \n"
            + "/*En general criva de Sundaram, produce primos más pequeños.\n"
            + "        que (2 * x + 2) para un número dado el número x. Ya que\n"
            + "         Queremos primos más pequeños que MAX, reducimos MAX a la mitad\n"
            + "         Esta matriz se usa para separar números del forma\n"
            + "         i + j + 2ij de otros donde 1 <= i <= j*/\n"
            + "boolean marked[] = new boolean[MAX/2 + 100]; \n"
            + "//Lógica principal de Sundaram, marcar todos los números\n"
            + "        // loc cuales no generan número primo haciendo 2*i+1\n"
            + "for (int i=1; i<=(Math.sqrt(MAX)-1)/2; i++) \n"
            + "            for (int j=(i*(i+1))<<1; j<=MAX/2; j=j+2*i+1) \n"
            + "marked[j] = true; \n"
            + "\n"
            + "// 2s es número primo\n"
            + "        primes.add(2); \n"
            + "// Imprime los otros primos, primos restantes son de la \n"
            + "        //forma 2*i+1 de tal manera que marked[i] es falso\n"
            + "for (int i=1; i<=MAX/2; i++) \n"
            + "            if (marked[i] == false) \n"
            + "                primes.add(2*i + 1); \n"
            + "} \n"
            + "// Retorna true si n es un número de Smith, si no falso \n"
            + "static boolean isSmith(int n) \n"
            + "{ \n"
            + "        int original_no = n; \n"
            + "// Encuentra la suma de los digitos de los factores \n"
            + "        //  primos de n\n"
            + "        int pDigitSum = 0; \n"
            + "for (int i = 0; primes.get(i) <= n/2; i++) \n"
            + "        { \n"
            + "            while (n % primes.get(i) == 0) \n"
            + "{   // Si primes[i] es un factor primo\n"
            + "                // agrega sus digitos a pDigitSum\n"
            + "                int p = primes.get(i); \n"
            + "n = n/p; \n"
            + "                while (p > 0) \n"
            + "                { \n"
            + "                    pDigitSum += (p % 10); \n"
            + "p = p/10; \n"
            + "                } \n"
            + "            } \n"
            + "        } \n"
            + "        /*Si n!=! entonces un primo sigue para ser sumado*/\n"
            + "if (n != 1 && n != original_no) \n"
            + "        { \n"
            + "            while (n > 0) \n"
            + "{ \n"
            + "                pDigitSum = pDigitSum + n%10; \n"
            + "                n = n/10; \n"
            + "            } \n"
            + "        } \n"
            + "// Todos los factores primos sumados \n"
            + "        // Ahora suma los digitos del número original \n"
            + "int sumDigits = 0; \n"
            + "        while (original_no > 0) \n"
            + "{ \n"
            + "            sumDigits = sumDigits + original_no % 10; \n"
            + "            original_no = original_no/10; \n"
            + "        } \n"
            + "        // Si la suma de los digistos en factores primos \n"
            + "        // y la suma de digitos en el número original son los mismos\n"
            + "        // entonces true, si no false\n"
            + "        return (pDigitSum == sumDigits); \n"
            + "} \n"
            + "\n"
            + "\n"
            + "    public static void main(String[] args)  \n"
            + "{   //Encuentra todos los números primos antes del limite\n"
            + "        // estos números son usados para encontrar factores primos\n"
            + "        sieveSundaram();   \n"
            + "        System.out.println(\"Imprimiento primeros números de Smith\" + \n"
            + "\" usando isSmith()\");   \n"
            + "        for (int i=1; i<500; i++) \n"
            + "           if (isSmith(i)) \n"
            + "              System.out.print(i + \" \"); \n"
            + "} \n"
            + "}";
    private String sphenicnumber = "// Programa JAVA que verifica si un número\n"
            + "// es esfenico o no\n"
            + "\n"
            + "import java.util.ArrayList;\n"
            + "import java.util.Collections;\n"
            + "import java.util.HashSet;\n"
            + "import java.util.Set;\n"
            + "public class SphenicNumber {\n"
            + "\n"
            + "static final int MAX = 1000;\n"
            + "//Crea un vector donde almacenar primos\n"
            + "// inicializa todas las entradas en 0\n"
            + "static ArrayList<Integer> least_pf = new ArrayList<>(MAX);\n"
            + "/* Esta función llena valores en least_pf[]\n"
            + "    de tal modod que el valor de least_pf[] almacene\n"
            + "    el factor primo más pequeño de i\n"
            + "    Se encuentra basado en la criba\n"
            + "de Eratostenes*/\n"
            + "    public static void main(String[] args) {\n"
            + "        for (int i = 0; i < 1001; i++) {\n"
            + "            least_pf.add(0);\n"
            + "        }\n"
            + "        Collections.fill(least_pf, 0);\n"
            + "        leastPrimeFactor(MAX);\n"
            + "        for (int i = 1; i < 100; i++) {\n"
            + "            if (isSphenic(i)) {\n"
            + "System.out.println(i + \" \");\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "    } \n"
            + "/*Función que verifica si un número es esfenico*/\n"
            + "static boolean isSphenic(int n) {\n"
            + "/*Almacena tres factores primos de n\n"
            + "        tenemos al menos 3 elementos en s*/ \n"
            + "Set<Integer> s = new HashSet<>();\n"
            + "// Siga encontrando factores primos hasta que n sea 1\n"
            + "        while (n > 1) {\n"
            + "// Encuenta al menos un factor del actual valor de n\n"
            + "int lpf = least_pf.get(n);\n"
            + "// Almacenamos actual tamaño de s para verificar si\n"
            + "//algun factor primo se repite\n"
            + "            int init_size = s.size();\n"
            + "// Inserta un valor primo al actual valor de n\n"
            + "            s.add(lpf);\n"
            + "// si lpf repite un número o se pasa de 3, retorna falso. \n"
            + "            if (s.size() == init_size || s.size() > 3) // El mismo primo divide\n"
            + "// un número más de una vez\n"
            + "            {\n"
            + "                return false;\n"
            + "            }\n"
            + "\n"
            + "// dividir n en lpf\n"
            + "            n /= lpf;\n"
            + "        }\n"
            + "// True si el tamaño es 3\n"
            + "return (s.size() == 3);\n"
            + "    }\n"
            + "\n"
            + "    static void leastPrimeFactor(int n) {\n"
            + "// un factor primo de 1 es 1\n"
            + "        least_pf.set(1, 1);	\n"
            + "// Almacena números primos para todos \n"
            + "// los otros números\n"
            + "        for (int i = 2; i <= n; i++) {\n"
            + "// least_pf[i] == 0 significa que i es primo\n"
            + "if (least_pf.get(i) == 0) {\n"
            + "                least_pf.set(i, i);\n"
            + "                for (int j = 2 * i; j <= n; j += i) {\n"
            + "                    if (least_pf.get(j) == 0) {\n"
            + "                        least_pf.set(j, i);\n"
            + "}\n"
            + "                }\n"
            + "\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "}";
    private String catalannumbers = "//Programa Java que recursivamente encuentra el\n"
            + "// nesimo número Catalan \n"
            + "public class CatalanNumber {\n"
            + "\n"
            + "    public static int catalan(int n) {\n"
            + "        int res = 0;\n"
            + "        // Caso base\n"
            + "        if (n <= 1) {\n"
            + "            return 1;\n"
            + "        }\n"
            + "        for (int i = 0; i < n; i++) {\n"
            + "            res += catalan(i) * catalan(n - i - 1);\n"
            + "        }\n"
            + "        return res;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        for (int i = 0; i < 10; i++) {\n"
            + "            System.out.print(catalan(i) + \" \");\n"
            + "}\n"
            + "    }\n"
            + "}";
    private String charmichaelnumbers = "//Programa java que verifica si un número\n"
            + "// es un número de carmichael\n"
            + "public class CarmichaelNumbers {\n"
            + "\n"
            + "//función que busca el GCD de dos números\n"
            + "static int gcd(int a, int b) {\n"
            + "        if (a < b) {\n"
            + "            return gcd(b, a);\n"
            + "        }\n"
            + "        if (a % b == 0) {\n"
            + "            return b;\n"
            + "        }\n"
            + "        return gcd(b, a % b);\n"
            + "}\n"
            + "//Función que busca el pow(x,y)\n"
            + "// bajo un modulo mod\n"
            + "    static int power(int x, int y, int mod) {\n"
            + "        if (y == 0) {\n"
            + "            return 1;\n"
            + "        }\n"
            + "        int temp = power(x, y / 2, mod) % mod;\n"
            + "        temp = (temp * temp) % mod;\n"
            + "        if (y % 2 == 1) {\n"
            + "            temp = (temp * x) % mod;\n"
            + "        }\n"
            + "        return temp;\n"
            + "}\n"
            + "\n"
            + "//Función que verifica si un número es número de charmichael\n"
            + "static int isCarmichaelNumber(int n) {\n"
            + "        for (int b = 2; b < n; b++) {\n"
            + "// Si 'b' es primo relativo de n\n"
            + "            if (gcd(b, n) == 1) // y pow(b, n-1)%n no es 1,\n"
            + "// retorne falso\n"
            + "            {\n"
            + "                if (power(b, n - 1, n) != 1) {\n"
            + "                    return 0;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "        return 1;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        System.out.println(isCarmichaelNumber(500));\n"
            + "        System.out.println(isCarmichaelNumber(561));\n"
            + "System.out.println(isCarmichaelNumber(1105));\n"
            + "    }\n"
            + "}";
    private String sternbrocotsequence = "// Programa java que imprime   \n"
            + "// La secuencia de Stern Brocot\n"
            + "import java.util.*; \n"
            + "\n"
            + "public class SternBrocotSequence { \n"
            + "\n"
            + "static void SternSequenceFunc(ArrayList<Integer>\n"
            + "BrocotSequence, int n) \n"
            + "{ \n"
            + "// Ciclo que crea la secuencia\n"
            + "for (int i = 1; BrocotSequence.size() < n; i++) \n"
            + "    { \n"
            + "        int considered_element = BrocotSequence.get(i); \n"
            + "        int precedent = BrocotSequence.get(i-1); \n"
            + "//Agregando la suma de los elementos considerados\n"
            + "        // y son precedentes\n"
            + "        BrocotSequence.add(considered_element + precedent); \n"
            + "//  Agregando siguiente elemento considerado \n"
            + "        BrocotSequence.add(considered_element); \n"
            + "    } \n"
            + "// Imprimiendo secuencia\n"
            + "for (int i = 0; i < 15; ++i) \n"
            + "        System.out.print(BrocotSequence.get(i) + \" \"); \n"
            + "} \n"
            + "\n"
            + "    public static void main (String[] args) {   \n"
            + "        int n = 15; \n"
            + "        ArrayList<Integer> BrocotSequence = new ArrayList<Integer>(); \n"
            + "// Agregando primer y segundo valor \n"
            + "        // A la secuencia\n"
            + "BrocotSequence.add(1); \n"
            + "        BrocotSequence.add(1); \n"
            + "        SternSequenceFunc(BrocotSequence, n);    \n"
            + "} \n"
            + "}";
    private String sylvestersequence = "//Implementación java de la secuencia Sylvester  \n"
            + "public class SylvesterSequence { \n"
            + "\n"
            + "    public static void printSequence(int n) \n"
            + "{ \n"
            + "        int a = 1; // Para almacenar el producto\n"
            + "        int ans = 2; // Para almacenar el número actual\n"
            + "int N = 1000000007; \n"
            + "        //Ciclo hasta n\n"
            + "        for (int i = 1; i <= n; i++) { \n"
            + "           System.out.print(ans + \" \"); \n"
            + "            ans = ((a % N) * (ans % N)) % N; \n"
            + "            a = ans; \n"
            + "            ans = (ans + 1) % N; \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args)  \n"
            + "{ \n"
            + "        int n = 6; \n"
            + "        printSequence(n); \n"
            + "\n"
            + "    } \n"
            + "}";
    private String aliquotsequence = "//Implementación java de una apoximación\n"
            + "// de la secuencia Aliquot \n"
            + "import java.util.*; \n"
            + "\n"
            + "public class AliquotSequence  \n"
            + "{ \n"
            + "// Función que calcula suma de \n"
            + "    // los divisores adecuados\n"
            + "static int getSum(int n)  \n"
            + "{ \n"
            + "        int sum = 0; // 1 es un divisor adecuado\n"
            + "for (int i = 1; i <= Math.sqrt(n); i++) \n"
            + "{ \n"
            + "            if (n % i == 0)  \n"
            + "            {   // Si divisores son iguales, solo toma uno \n"
            + "if (n / i == i)  \n"
            + "                { \n"
            + "                    sum = sum + i; \n"
            + "} \n"
            + "                else // Si no tome ambos\n"
            + "                { \n"
            + "sum = sum + i; \n"
            + "                    sum = sum + (n / i); \n"
            + "} \n"
            + "            } \n"
            + "        } \n"
            + "\n"
            + "// Calcula la suma de los divisores adecuados\n"
            + "return sum - n; \n"
            + "    } \n"
            + "\n"
            + "    static void printAliquot(int n)  \n"
            + "{ \n"
            + "\n"
            + "// Imprime el primer termino\n"
            + "        System.out.printf(\"%d \", n);    \n"
            + "TreeSet<Integer> s = new TreeSet<>(); \n"
            + "        s.add(n); \n"
            + "\n"
            + "        int next = 0; \n"
            + "while (n > 0)  \n"
            + "        {   // Calcula siguiente termino desde el anterior\n"
            + "n = getSum(n); \n"
            + "            if (s.contains(n) && n != s.last())  \n"
            + "            { \n"
            + "                System.out.print(\"\\nRepeats with \" + n); \n"
            + "                break; \n"
            + "            } \n"
            + "            //Imprimir siguiente termino\n"
            + "            System.out.print(n + \" \"); \n"
            + "            s.add(n); \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args)  \n"
            + "{ \n"
            + "        printAliquot(12); \n"
            + "    } \n"
            + "}";
    private String jugglersequence = "// Implementación java de la secuenca de Juggler\n"
            + "public class JugglerSequence {\n"
            + "    static void printJuggler(int n) {\n"
            + "int a = n;\n"
            + "// Imprime el primer termino\n"
            + "        System.out.print(a + \" \");\n"
            + "// Calcula terminos hasta que el ultimo no sea 1\n"
            + "        while (a != 1) {\n"
            + "            int b = 0;\n"
            + "// Verifica si los previos terminos son pares o impares\n"
            + "            if (a % 2 == 0) // calcular siguiente termino\n"
            + "            {\n"
            + "b = (int) Math.floor(Math.sqrt(a));\n"
            + "} else // para impar anterior, calcular \n"
            + "// Siguiente termino\n"
            + "{\n"
            + "                b = (int) Math.floor(Math.sqrt(a)\n"
            + "                        * Math.sqrt(a) * Math.sqrt(a));\n"
            + "            }\n"
            + "            System.out.print(b + \" \");\n"
            + "            a = b;\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        printJuggler(3);\n"
            + "        System.out.println();\n"
            + "        printJuggler(9);\n"
            + "}\n"
            + "}";
    private String moserdebrujinsequence = "// Codigo java que genera los primeros n terminos\n"
            + "// de la secuencia de  Moser-de Bruijn \n"
            + "\n"
            + "public class MoserdeBruijnSequence {\n"
            + "\n"
            + "    public static int gen(int n) {\n"
            + "\n"
            + "// S(0) = 0 \n"
            + "        if (n == 0) {\n"
            + "            return 0;\n"
            + "        } // S(1) = 1 \n"
            + "        else if (n == 1) {\n"
            + "            return 1;\n"
            + "        } // S(2 * n) = 4 * S(n) \n"
            + "        else if (n % 2 == 0) {\n"
            + "            return 4 * gen(n / 2);\n"
            + "        } // S(2 * n + 1) = 4 * S(n) + 1 \n"
            + "        else if (n % 2 == 1) {\n"
            + "            return 4 * gen(n / 2) + 1;\n"
            + "        }\n"
            + "        return 0;\n"
            + "    }\n"
            + "\n"
            + "    public static void moserDeBruijn(int n) {\n"
            + "        for (int i = 0; i < n; i++) {\n"
            + "            System.out.print(gen(i) + \" \");\n"
            + "        }\n"
            + "        System.out.println();\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "int n = 15;\n"
            + "        System.out.println(\"Primeros \" + n\n"
            + "                + \" terminos de la secuencia de  \"\n"
            + "                + \"Moser-de Bruijn  : \");\n"
            + "        moserDeBruijn(n);\n"
            + "    }\n"
            + "}";
    private String newmanconwaysequence = "// Programa java que encuentra el nesimo  \n"
            + "// elemento de la secuencia de  Newman-Conway\n"
            + "public class NewmanConwaySequence { \n"
            + "    static int sequence(int n) \n"
            + "    { \n"
            + "        if (n == 1 || n == 2) \n"
            + "            return 1; \n"
            + "        else\n"
            + "            return sequence(sequence(n - 1))  \n"
            + "                  + sequence(n - sequence(n - 1)); \n"
            + "    } \n"
            + "	static intsequenceDP(intn) \n"
            + "{ \n"
            + "    intf[n + 1]; \n"
            + "    inti; \n"
            + "    f[0] = 0; \n"
            + "    f[1] = 1; \n"
            + "    f[2] = 1; \n"
            + "  \n"
            + "    for(i = 3; i <= n; i++)  \n"
            + "        f[i] = f[f[i - 1]] + f[i - f[i - 1]];     \n"
            + "  \n"
            + "    returnf[n]; \n"
            + "} \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        int n = 10; \n"
            + "        System.out.println(sequence(n)); \n"
            + "} \n"
            + "}";
    private String padovansequence = "// Programa JAVA que encuentra el enesimo termino\n"
            + "// de la secuencia de Padovan\n"
            + "// usando programación dinamica  \n"
            + "public class PadovanSequence { \n"
            + "/* Función que calcula el número de Padovan*/\n"
            + "static int pad(int n) \n"
            + "{   //0,1 y 2 número de la serie es 1\n"
            + "int pPrevPrev = 1, pPrev = 1, \n"
            + "            pCurr = 1, pNext = 1; \n"
            + "        for (int i = 3; i <= n; i++) { \n"
            + "            pNext = pPrevPrev + pPrev; \n"
            + "            pPrevPrev = pPrev; \n"
            + "            pPrev = pCurr; \n"
            + "            pCurr = pNext; \n"
            + "        } \n"
            + "        return pNext; \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        int n = 12; \n"
            + "        System.out.println(pad(n)); \n"
            + "} \n"
            + "}";
    private String recamansequence = "// Programa java que imprime el nesimo número\n"
            + "// de la secuencia de Recaman\n"
            + "public class RecamanSequence  { \n"
            + "\n"
            + "static void recaman(int n) \n"
            + "{   //Crea un array que almacenara los terminos\n"
            + "int arr[] = new int[n]; \n"
            + "// Primer termino de la secuencia es siempre 0\n"
            + "arr[0] = 0; \n"
            + "        System.out.print(arr[0]+\" ,\"); \n"
            + "// Llena terminos restantes usando formula recursiva\n"
            + "for (int i = 1; i < n; i++) \n"
            + "        { \n"
            + "            int curr = arr[i - 1] - i; \n"
            + "            int j; \n"
            + "            for (j = 0; j < i; j++) \n"
            + "{   // si arr[i-1] - i es negativo or ya existe \n"
            + "if ((arr[j] == curr) || curr < 0) \n"
            + "                { \n"
            + "                    curr = arr[i - 1] + i; \n"
            + "                    break; \n"
            + "                } \n"
            + "            } \n"
            + "            arr[i] = curr; \n"
            + "            System.out.print(arr[i]+\", \"); \n"
            + "\n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main (String[] args)  \n"
            + "{ \n"
            + "        int n = 17; \n"
            + "        recaman(n); \n"
            + "    } \n"
            + "}";
    private String arclength = "//Programa java que calcula \n"
            + "//la longitud de un arco \n"
            + "\n"
            + "public class ArcLength {\n"
            + "\n"
            + "static double arcLength(double diameter,\n"
            + "            double angle) {\n"
            + "        double pi = 22.0 / 7.0;\n"
            + "        double arc;\n"
            + "        if (angle >= 360) {\n"
            + "            System.out.println(\"Angulo no puede ser fromado\");\n"
            + "            return 0;\n"
            + "        } else {\n"
            + "            arc = (pi * diameter) * (angle / 360.0);\n"
            + "            return arc;\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        double diameter = 25.0;\n"
            + "        double angle = 45.0;\n"
            + "        double arc_len = arcLength(diameter, angle);\n"
            + "        System.out.println(arc_len);\n"
            + "}\n"
            + "}";
    private String areacircularsector = "// Programa java que encuentra el area de un sector circular\n"
            + "\n"
            + "public class AreaCircularSector \n"
            + "{ \n"
            + "    static void SectorArea(double radius,double angle) \n"
            + "    { \n"
            + "        if(angle >= 360) \n"
            + "            System.out.println(\"Angle not possible\"); \n"
            + "\n"
            + "// Calculando el area\n"
            + "        else\n"
            + "        { \n"
            + "            double sector =((22 * radius * radius) / 7)  \n"
            + "                           * (angle / 360); \n"
            + "            System.out.println(sector); \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "    public static void main (String[] args) \n"
            + "    { \n"
            + "        double radius = 9; \n"
            + "        double angle = 60; \n"
            + "        SectorArea(radius, angle); \n"
            + "} \n"
            + "}";
    private String arrangedcointriangle = "// Programa java que encuentra la maxima altura\n"
            + "// de un triángulo de monedas arregladas\n"
            + "public class ArrangedCoinTriangle {\n"
            + "/*Retrorna el la raiz cuadrada de n\n"
            + "    Note como la función lo realiza*/\n"
            + "static float squareRoot(float n) {\n"
            + "/*Usamos n como aproximción inicial*/\n"
            + "        float x = n;\n"
            + "        float y = 1;\n"
            + "// e decide el nivel de precisión\n"
            + "        float e = 0.000001f;\n"
            + "        while (x - y > e) {\n"
            + "            x = (x + y) / 2;\n"
            + "            y = n / x;\n"
            + "        }\n"
            + "        return x;\n"
            + "    }\n"
            + "//Metodo que encuentra la maxima altura\n"
            + "//del arreglo de monedas\n"
            + "    static int findMaximumHeight(int N) {\n"
            + "//Calculando la porción interna\n"
            + "        //de la raiz cuadrada\n"
            + "int n = 1 + 8 * N;\n"
            + "        int maxH = (int) (-1 + squareRoot(n)) / 2;\n"
            + "\n"
            + "        return maxH;\n"
            + "    }\n"
            + "    public static void main(String[] args) {\n"
            + "        int N = 12;\n"
            + "\n"
            + "        System.out.print(findMaximumHeight(N));\n"
            + "}\n"
            + "}";
    private String circlearea = "//Programa java que encuentra el area de un circulo    \n"
            + "public class CircleArea\n"
            + "{ \n"
            + "    static final double PI = Math.PI;       \n"
            + "    static double findArea(int r) \n"
            + "    { \n"
            + "       return PI * Math.pow(r, 2); \n"
            + "    } \n"
            + "    public static void main(String[] args)  \n"
            + "    { \n"
            + "        System.out.println(\"Area is \" +  findArea(5)); \n"
            + "} \n"
            + "}";
    private String circumscribedcircleofequilateral = "// código Java para encontrar el área de\n"
            + "// un círculo curcunscripto a un triángulo equilátero\n"
            + "public class CircumscribedCircleOfEquilateral{ \n"
            + "\n"
            + "    static double PI = 3.14159265; \n"
            + "//Función que encuentra el area\n"
            + "    // del circulo circumscrito\n"
            + "public static double area_cicumscribed(double a) \n"
            + "    { \n"
            + "        return (a * a * (PI / 3)); \n"
            + "    } \n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        double a = 6.0; \n"
            + "        System.out.println(\"Area of circumscribed circle is :\" \n"
            + "+ area_cicumscribed(a)); \n"
            + "    } \n"
            + "}";
    private String convexhull = "// Programa java que halla el casco convexo de un set de puntos\n"
            + "import java.util.*;\n"
            + "\n"
            + "public class ConvexHull {\n"
            + "\n"
            + "  static   class Point {\n"
            + "\n"
            + "        int x, y;\n"
            + "\n"
            + "        Point(int x, int y) {\n"
            + "            this.x = x;\n"
            + "            this.y = y;\n"
            + "}\n"
            + "    }\n"
            + "// Para encontrar la orientación de la tripleta\n"
            + "    //la función retorna lo siguiente \n"
            + "    // 0 --> p, q y r son colineares \n"
            + "    // 1 --> Manecillas de reloj\n"
            + "    // 2 --> en contra de las manecillas\n"
            + "static int orientation(Point p, Point q, Point r) {\n"
            + "        int val = (q.y - p.y) * (r.x - q.x)\n"
            + "                - (q.x - p.x) * (r.y - q.y);\n"
            + "\n"
            + "        if (val == 0) {\n"
            + "            return 0;  // colinear\n"
            + "        }\n"
            + "        return (val > 0) ? 1 : 2; // Manecillas\n"
            + "    }\n"
            + "//Imprime el casco convexo del set de puntos\n"
            + "static void convexHull(Point points[], int n) {\n"
            + "//Debe haber al menos 3 puntos\n"
            + "        if (n < 3) {\n"
            + "return;\n"
            + "        }\n"
            + "// Inicializar resultado\n"
            + "        ArrayList<Point> hull = new ArrayList<>();\n"
            + "// Encuentra el punto de más a la izquierda \n"
            + "int l = 0;\n"
            + "        for (int i = 1; i < n; i++) {\n"
            + "            if (points[i].x < points[l].x) {\n"
            + "l = i;\n"
            + "            }\n"
            + "        }\n"
            + "        // Comienza desde el punto más a la izquierda, sigue moviéndose.\n"
            + "        // en sentido antihorario hasta llegar al punto de inicio\n"
            + "        // otra vez. Este ciclo corre O (h) veces donde h es\n"
            + "        // número de puntos en resultado o salida\n"
            + "        int p = l, q;\n"
            + "        do {\n"
            + "// Agrega el punto actual al resultado\n"
            + "            hull.add(points[p]);\n"
            + "// Buscar un punto 'q' tal que\n"
            + "            // la orientación (p, x, q) es antihorario\n"
            + "            // para todos los puntos 'x'. La idea es mantener\n"
            + "            // pista de los últimos visitados más contra reloj\n"
            + "            // punto en q. Si algún punto 'i' es más\n"
            + "            // en sentido contrario a las agujas del reloj que q, luego 			//actualiza q.\n"
            + "q = (p + 1) % n;\n"
            + "            for (int i = 0; i < n; i++) {\n"
            + "//Si i es más antihorario que el actual q, actualice q\n"
            + "if (orientation(points[p], points[i], points[q])\n"
            + "== 2) {\n"
            + "                    q = i;\n"
            + "                }\n"
            + "            }\n"
            + "//Ahora q es el más antihoriario con respecto\n"
            + "            // a p, ubica p como q para la siguiente iteración\n"
            + "            // asi q es agregado al casco resultado\n"
            + "            p = q;\n"
            + "        } while (p != l);  \n"
            + "        // Mientras no vengamos del primer punto\n"
            + "// Imprima resultado\n"
            + "        for (Point temp : hull) {\n"
            + "            System.out.println(\"(\" + temp.x + \", \"\n"
            + "                    + temp.y + \")\");\n"
            + "        }\n"
            + "    }\n"
            + "    public static void main(String[] args) {\n"
            + "\n"
            + "        Point points[] = new Point[7];\n"
            + "        points[0] = new Point(0, 3);\n"
            + "        points[1] = new Point(2, 3);\n"
            + "        points[2] = new Point(1, 1);\n"
            + "        points[3] = new Point(2, 1);\n"
            + "        points[4] = new Point(3, 0);\n"
            + "        points[5] = new Point(0, 0);\n"
            + "        points[6] = new Point(3, 3);\n"
            + "        int n = points.length;\n"
            + "        convexHull(points, n);\n"
            + "}\n"
            + "}";
    private String cutssumatory = "//Programa que calcula el maximo número\n"
            + "// de piezas de pizza dados el número de cortes\n"
            + "\n"
            + "public class CutsSumatory {\n"
            + "\n"
            + "    static int findMaximumPieces(int n) {\n"
            + "        return 1 + n * (n + 1) / 2;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String arg[]) {\n"
            + "\n"
            + "System.out.print(findMaximumPieces(3));\n"
            + "    }\n"
            + "} ";
    private String heronformula = "//Programa Java que calcula el area\n"
            + "// De un triángulo usando la formula de Herón\n"
            + "\n"
            + "public class HeronFormula {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "	//Enviar las coordenadas de los vertices\n"
            + "        System.out.println(heron(1, 0, -1,0, 0, 2));\n"
            + "    }\n"
            + "//función que usa la formula de Herón\n"
            + "static double heron(double x1, double y1, double x2,\n"
            + "            double y2, double x3, double y3) {\n"
            + "double a = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n"
            + "        double b = Math.sqrt((x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3));\n"
            + "        double c = Math.sqrt((x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2));\n"
            + "double s = (a + b + c) / 2.0;\n"
            + "        double A = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n"
            + "return A;\n"
            + "    }\n"
            + "\n"
            + "}";
    private String radiouscirclethreepoints = "//Programa JAVA que usa la formula de heron\n"
            + "//Para calcular el radio de un circulo dado por \n"
            + "//tres puntos (Circumradio)\n"
            + "\n"
            + "public class RadiousCircleThreePoints {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "//Se envian las coordenadas de los\n"
            + "        // vertices del triángulo\n"
            + "        System.out.println(circumradius(1, 0, -1, 0, 0, 2));\n"
            + "    }\n"
            + "//Función que devuelve el tamaño del radio\n"
            + "static double circumradius(double x1, double y1, double x2,\n"
            + "            double y2, double x3, double y3) {\n"
            + "double a = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n"
            + "        double b = Math.sqrt((x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3));\n"
            + "        double c = Math.sqrt((x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2));\n"
            + "        double A = heron(x1, y1, x2, y2, x3, y3);\n"
            + "double r = (a * b * c) / (4.0 * A);\n"
            + "return r;\n"
            + "    }\n"
            + "//Calcula el area con la formula de Herón\n"
            + "static double heron(double x1, double y1, double x2,\n"
            + "            double y2, double x3, double y3) {\n"
            + "double a = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n"
            + "        double b = Math.sqrt((x1 - x3) * (x1 - x3) + (y1 - y3) * (y1 - y3));\n"
            + "        double c = Math.sqrt((x3 - x2) * (x3 - x2) + (y3 - y2) * (y3 - y2));\n"
            + "double s = (a + b + c) / 2.0;\n"
            + "        double A = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n"
            + "return A;\n"
            + "    }\n"
            + "}";
    private String dimensionrightangledtriangle = "// Codigo java que encuentra las dimensiones\n"
            + "//de un triángulo por medio de altura y area\n"
            + "public class DimensionsRightAngledTriangle { \n"
            + "\n"
            + "// Función que calcula la dimensión\n"
            + "static void findDimen(int H, int A) \n"
            + "    { \n"
            + "\n"
            + "        // P^2+B^2 = H^2 \n"
            + "        // P*B = 2*A \n"
            + "        // (P+B)^2 = P^2+B^2+2*P*B = H^2+4*A \n"
            + "        // (P-B)^2 = P^2+B^2-2*P*B = H^2-4*A \n"
            + "        // P+B = sqrt(H^2+4*A) \n"
            + "        // |P-B| = sqrt(H^2-4*A) \n"
            + "        if (H * H < 4 * A) { \n"
            + "            System.out.println(\"Not Possible\"); \n"
            + "return; \n"
            + "        } \n"
            + "\n"
            + "// Raiz cuadrada valor de H^2 + 4A y H^2- 4A \n"
            + "double apb = Math.sqrt(H * H + 4 * A); \n"
            + "        double asb = Math.sqrt(H * H - 4 * A); \n"
            + "\n"
            + "        System.out.println(\"P = \" + Math.round(((apb - asb) / 2.0) * 100.0) / 100.0); \n"
            + "        System.out.print(\"B = \" + Math.round(((apb + asb) / 2.0) * 100.0) / 100.0); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        int H = 5; \n"
            + "        int A = 6; \n"
            + "        findDimen(H, A); \n"
            + "} \n"
            + "}";
    private String hexagonarea = "//Programa Java que calcula el area de un Hexagono\n"
            + "public class HexagonArea {\n"
            + "    public static double hexagonArea(double s) {\n"
            + "        return ((3 * Math.sqrt(3)\n"
            + "                * (s * s)) / 2);\n"
            + "    }\n"
            + "\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "// Largo de un lado\n"
            + "        double s = 4;\n"
            + "System.out.print(\"Area: \"\n"
            + "                + hexagonArea(s));\n"
            + "System.out.println(\"\");\n"
            + "    }\n"
            + "}";
    private String areaofpolygon = "//Programa Java que calcula el area de un poligono\n"
            + "import java.awt.Point;\n"
            + "import java.awt.Polygon;\n"
            + "import java.util.Arrays;\n"
            + "\n"
            + "public class AreaOfPolygon {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "//Crea el poligono con los puntos dados\n"
            + "Polygon p = new Polygon();\n"
            + "        p.addPoint(0, 2);\n"
            + "        p.addPoint(2, 2);\n"
            + "        p.addPoint(2, 0);\n"
            + "        p.addPoint(0, 0);\n"
            + "        System.out.println(area(p));\n"
            + "}\n"
            + "    //Por medio de triángulos va calculando el area completa\n"
            + "static int signedTriangleArea(Point a, Point b, Point c) {\n"
            + "        return a.x * b.y - a.y * b.x + a.y * c.x - a.x * c.y + b.x * c.y - c.x * b.y;\n"
            + "    }\n"
            + "\n"
            + "    static boolean ccw(Point a, Point b, Point c) {\n"
            + "        return signedTriangleArea(a, b, c) > 0;\n"
            + "}\n"
            + "// Verifica si los puntos son colineares\n"
            + "static boolean collinear(Point a, Point b, Point c) {\n"
            + "        return signedTriangleArea(a, b, c) == 0;\n"
            + "}\n"
            + "//Calcula la distancia entre dos puntos\n"
            + "static double distance(Point p1, Point p2) {\n"
            + "        double dx = p1.x - p2.x;\n"
            + "double dy = p1.y - p2.y;\n"
            + "return Math.sqrt(dx * dx + dy * dy);\n"
            + "}\n"
            + "//Función que calcula el area de cualquier poligono\n"
            + "static double area(Polygon poly) {\n"
            + "        int N = poly.npoints;\n"
            + "        int[] x = poly.xpoints;\n"
            + "        int[] y = poly.ypoints;\n"
            + "        Point[] p = new Point[N];\n"
            + "        for (int i = 0; i < N; ++i) {\n"
            + "            p[i] = new Point(x[i], y[i]);\n"
            + "        }\n"
            + "        final Point first;\n"
            + "        int min = 0;\n"
            + "        for (int i = 1; i < N; i++) {\n"
            + "            if (p[i].y < p[min].y) {\n"
            + "                min = i;\n"
            + "            } else if (p[i].y == p[min].y) {\n"
            + "                if (p[i].x < p[i].x) {\n"
            + "                    min = i;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "        first = p[min];\n"
            + "        p[min] = p[0];\n"
            + "p[0] = first;\n"
            + "//Usar expresion lambda en vez de comparator\n"
            + "Arrays.sort(p, 1, N, (Point p1, Point p2) -> {\n"
            + "            if (collinear(first, p1, p2)) {\n"
            + "                return Double.compare(distance(first, p1), distance(first, p2));\n"
            + "            }\n"
            + "            if (ccw(first, p1, p2)) {\n"
            + "                return -1;\n"
            + "            } else {\n"
            + "                return 1;\n"
            + "            }\n"
            + "        });\n"
            + "        double A = 0.0;\n"
            + "        for (int i = 0; i < N; i++) {\n"
            + "            int j = (i + 1) % N;\n"
            + "            A += p[i].x * p[j].y - p[j].x * p[i].y;\n"
            + "}\n"
            + "        return A / 2.0;\n"
            + "\n"
            + "    }\n"
            + "}";
    private String linelineintersection = "//Implementación Java que encuentra el punto de\n"
            + "//interseccion de dos lineas\n"
            + "\n"
            + "public class LineLineIntersection {\n"
            + "//Clase usada para almacenar las coordenadas X y la Y    \n"
            + "// de un punto respectivo\n"
            + "\n"
            + "    static class Point {\n"
            + "\n"
            + "        double x, y;\n"
            + "\n"
            + "        public Point(double x, double y) {\n"
            + "            this.x = x;\n"
            + "            this.y = y;\n"
            + "}\n"
            + "\n"
            + "// Metodo usado para imprimir las cordenadas\n"
            + "        // X y Y de un punto\n"
            + "static void displayPoint(Point p) {\n"
            + "            System.out.println(\"(\" + p.x + \", \" + p.y + \")\");\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static Point lineLineIntersection(Point A, Point B, Point C, Point D) {\n"
            + "// Linea AB representada como a1x + b1y=c1\n"
            + "double a1 = B.y - A.y;\n"
            + "        double b1 = A.x - B.x;\n"
            + "        double c1 = a1 * (A.x) + b1 * (A.y);\n"
            + "// Linea CD representada como a2x + b2y=c2\n"
            + "double a2 = D.y - C.y;\n"
            + "        double b2 = C.x - D.x;\n"
            + "        double c2 = a2 * (C.x) + b2 * (C.y);\n"
            + "        double determinant = a1 * b2 - a2 * b1;\n"
            + "if (determinant == 0) {\n"
            + "//Las lineas son pararelas, esto es simplificado\n"
            + "            //Retornando un par de FLT_MAX\n"
            + "return new Point(Double.MAX_VALUE, Double.MAX_VALUE);\n"
            + "        } else {\n"
            + "            double x = (b2 * c1 - b1 * c2) / determinant;\n"
            + "            double y = (a1 * c2 - a2 * c1) / determinant;\n"
            + "            return new Point(x, y);\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        Point A = new Point(1, 1);\n"
            + "        Point B = new Point(4, 4);\n"
            + "        Point C = new Point(1, 8);\n"
            + "        Point D = new Point(2, 4);\n"
            + "        Point intersection = lineLineIntersection(A, B, C, D);\n"
            + "        if (intersection.x == Double.MAX_VALUE\n"
            + "&& intersection.y == Double.MAX_VALUE) {\n"
            + "System.out.println(\"la linea AB y CD son paralelas.\");\n"
            + "        } else {\n"
            + "            System.out.print(“La intersección de las lineas AB \"\n"
            + "+ \"y CD es: \");\n"
            + "            Point.displayPoint(intersection);\n"
            + "}\n"
            + "    }\n"
            + "}";
    private String linemidpoint = "//Programa java para buscar\n"
            + "//el punto medio de una linea\n"
            + "public class LineMidPoint  \n"
            + "{ \n"
            + "    static void midpoint(int x1, int x2, \n"
            + "                          int y1, int y2) \n"
            + "    { \n"
            + "        System.out.print((x1 + x2) / 2 + \n"
            + "                        \" , \" + (y1 + y2) / 2) ;  \n"
            + "    } \n"
            + "    public static void main (String[] args)  \n"
            + "{ \n"
            + "        int x1 =-1, y1 = 2 ; \n"
            + "        int x2 = 3, y2 = -6 ;  \n"
            + "        midpoint(x1, x2, y1, y2); \n"
            + "\n"
            + "    } \n"
            + "}";
    private String linethroughtwopoints = "//Implementación Java para encontrar la linea\n"
            + "//que pasa atraves de dos puntos\n"
            + "public class LineThroughTwoPoints {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        Pair P = new Pair(3, 2);\n"
            + "        Pair Q = new Pair(2, 6);\n"
            + "        lineFromPoints(P, Q);\n"
            + "    }\n"
            + "\n"
            + "    static void lineFromPoints(Pair P, Pair Q) {\n"
            + "        double a = Q.second - P.second;\n"
            + "        double b = P.first - Q.first;\n"
            + "        double c = a * (P.first) + b * (P.second);\n"
            + "\n"
            + "if (b < 0) {\n"
            + "            System.out.println(\"La linea que pasa a traves de los puntos P y Q es: \"\n"
            + "                    + a + \"x \" + b + \"y = \" + c);\n"
            + "\n"
            + "        } else {\n"
            + "            System.out.println(\"La linea que pasa a traves de los puntos P y Q es: \"\n"
            + "                    + a + \"x + \" + b + \"y = \" + c);\n"
            + "        }\n"
            + "    }\n"
            + "/* Este par  es usado para almacenar la X y Y\n"
            + "    de un punto respectivamente*/\n"
            + "    static class Pair {\n"
            + "\n"
            + "int first;\n"
            + "        int second;\n"
            + "\n"
            + "        public Pair(int first, int second) {\n"
            + "            this.first = first;\n"
            + "            this.second = second;\n"
            + "}\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "}";
    private String minimumheighttriangle = "//Código java que buscar la altura mínima \n"
            + "//Codigo java que buscar la altura minima \n"
            + "//usando la base y el area\n"
            + "\n"
            + "public class MinimumHeightTriangle {\n"
            + "\n"
            + "    static double minHeight(double base, double area) {\n"
            + "        double d = (2 * area) / base;\n"
            + "        return Math.ceil(d);\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        double base = 4, area = 8;\n"
            + "        System.out.println(\"Minimum height is \"\n"
            + "+ minHeight(base, area));\n"
            + "    }\n"
            + "}";
    private String perimeterusingblocks = "/*Codigo JAVA que permire encontrar el minimo\n"
            + "perimetro usando n bloques*/\n"
            + "public class PerimeterUsingBlocks {\n"
            + "\n"
            + "    public static long minPerimeter(int n) {\n"
            + "        int l = (int) Math.sqrt(n);\n"
            + "int sq = l * l;\n"
            + "//si n es un cudrado perfeto\n"
            + "if (sq == n) {\n"
            + "            return l * 4;\n"
            + "} else {   \n"
            + "            //Número de filas\n"
            + "            long row = n / l;\n"
            + " //Perimetro de la matriz rectangular\n"
            + "            long perimeter\n"
            + "                    = 2 * (l + row);\n"
            + "// Si hay bloques restantes\n"
            + "if (n % l != 0) {\n"
            + "                perimeter += 2;\n"
            + "            }\n"
            + "            return perimeter;\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int n = 10;\n"
            + "        System.out.println(minPerimeter(n));\n"
            + "}\n"
            + "}";
    private String pointinsidetriangle = "//Codigo Java que verifica cuando un punto\n"
            + "//yace dentro de un triángulo o no\n"
            + "public class PointInsideTriangle { \n"
            + "/* Una función de utilidad que calcula el \n"
            + "    area del triángulo formado por (x1, y1) (x2, y2) y (x3, y3)*/\n"
            + "static double area(int x1, int y1, int x2, int y2, \n"
            + "int x3, int y3) \n"
            + "    { \n"
            + "       return Math.abs((x1*(y2-y3) + x2*(y3-y1)+ \n"
            + "                                    x3*(y1-y2))/2.0); \n"
            + "    } \n"
            + "    /* Una función que verifica cu cualquier punto P(x,y)\n"
            + "    yace dentro de un triángulo formado por (x1, y1), \n"
            + "B(x2, y2) and C(x3, y3) */\n"
            + "    static boolean isInside(int x1, int y1, int x2, \n"
            + "                int y2, int x3, int y3, int x, int y) \n"
            + "{    \n"
            + "/* Calcula el area del triángulo ABC */\n"
            + "        double A = area (x1, y1, x2, y2, x3, y3); \n"
            + "\n"
            + "       /* Calcula el area del triángulo PCB */  \n"
            + "        double A1 = area (x, y, x2, y2, x3, y3); \n"
            + "\n"
            + "/* Calcula el area del triángulo PAC */  \n"
            + "        double A2 = area (x1, y1, x, y, x3, y3); \n"
            + "\n"
            + "/* Calcula el area del triángulo PAB */   \n"
            + "        double A3 = area (x1, y1, x2, y2, x, y); \n"
            + "       /* verifica si la suma de A1,A2 y A3 es igual a A*/\n"
            + "return (A == A1 + A2 + A3); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args)  \n"
            + "{   /* Verificamos si el punto P(10,15)\n"
            + "        yace dentro del triángulo formado por\n"
            + "A(0, 0), B(20, 0) and C(10, 30)*/\n"
            + "       if (isInside(0, 0, 20, 0, 10, 30, 10, 15)) \n"
            + "System.out.println(\"Adentro\"); \n"
            + "       else\n"
            + "           System.out.println(\"Por fuera\");   \n"
            + "    } \n"
            + "}";
    private String ratiodivideline = "// Programa java que encuentra el punto que divide una \n"
            + "//linea dada, dado un ratio\n"
            + "public class RatioDivideLine { \n"
            + "static void section(double x1, double x2, \n"
            + "                        double y1, double y2, \n"
            + "                        double m, double n) \n"
            + "{ \n"
            + "//Aplicando la formula de la sección\n"
            + "double x = ((n * x1) + (m * x2)) / \n"
            + "(m + n); \n"
            + "        double y = ((n * y1) + (m * y2)) / \n"
            + "                    (m + n); \n"
            + "// Imprimiendo resultado\n"
            + "        System.out.println(\"(\" + x + \", \" + y + \")\"); \n"
            + "} \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "{ \n"
            + "        double x1 = 2, x2 = 4, y1 = 4, \n"
            + "               y2 = 6, m = 2, n = 3; \n"
            + "        section(x1, x2, y1, y2, m, n); \n"
            + "    } \n"
            + "}";
    private String rectanglesinnxm = "// Codigo Java que cuenta el número\n"
            + "// de rectangulos en una matriz N*M\n"
            + "public class RectanglesInNxM { \n"
            + "\n"
            + "    public static long  rectCount(int n, int m) \n"
            + "    { \n"
            + "        return (m * n * (n + 1) * (m + 1)) / 4; \n"
            + "    } \n"
            + "    public static void main(String[] args)  \n"
            + "    { \n"
            + "        int n = 5, m = 4; \n"
            + "       System.out.println(rectCount(n, m)); \n"
            + "} \n"
            + "}";
    private String squaresintriangle2x2 = "// Programa Java que cuenta el número de cuadros2 \n"
            + "// 2x2 que cabe en un triángulo isoceles\n"
            + "\n"
            + "public class SquaresInTriangle2x2 {\n"
            + "\n"
            + "    public static int numberOfSquares(int base) {\n"
            + "// Removiendo la parte extra  \n"
            + "        // que podamos necesitar\n"
            + "        base = (base - 2);\n"
            + " // Desde cada cuadrado que tenga\n"
            + "        // base de tamaño 2 \n"
            + "        base = base / 2;\n"
            + "return base * (base + 1) / 2;\n"
            + "    }\n"
            + "    public static void main(String args[]) {\n"
            + "\n"
            + "        int base = 8;\n"
            + "        System.out.println(numberOfSquares(base));\n"
            + "}\n"
            + "}";
    private String sumofmanhattan = "/*Programa Java para encontrar la suma de\n"
            + "las distancias de Manhattan entre todos \n"
            + "los pares de puntos dados */\n"
            + "\n"
            + "public class SumOfManhattan { \n"
            + "/*Retorna la suma de la distancia entre todos\n"
            + "    los pares de puntos*/ \n"
            + "    static int distancesum(int x[], int y[], int n) \n"
            + "    { \n"
            + "        int sum = 0; \n"
            + "/* Por cada punto, encuentra la distancia \n"
            + "        al resto de puntos */ \n"
            + "        for (int i = 0; i < n; i++) \n"
            + "for (int j = i + 1; j < n; j++) \n"
            + "                sum += (Math.abs(x[i] - x[j]) +  \n"
            + "Math.abs(y[i] - y[j])); \n"
            + "return sum; \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        int x[] = { -1, 1, 3, 2 }; \n"
            + "        int y[] = { 5, 6, 5, 3 }; \n"
            + "        int n = x.length;     \n"
            + "System.out.println(distancesum(x, y, n)); \n"
            + "    } \n"
            + "}";
    private String threepointscollinear = "/*Programa en java para verificar si\n"
            + "tres puntos son colineares\n"
            + "o no usando el area del triángulo*/\n"
            + "public class ThreePointsCollinear {\n"
            + "//Función que verifica si un punto es colineal o no\n"
            + "static void collinear(int x1, int y1, int x2,\n"
            + "int y2, int x3, int y3) {\n"
            + "/*Calcular el area del triángulo\n"
            + "        Debemos omitir multiplicaciones con 0.5\n"
            + "        para evitar calculos flotantes*/\n"
            + "        int a = x1 * (y2 - y3)\n"
            + "                + x2 * (y3 - y1)\n"
            + "+ x3 * (y1 - y2);\n"
            + "\n"
            + "        if (a == 0) {\n"
            + "            System.out.println(\"Yes\");\n"
            + "        } else {\n"
            + "            System.out.println(\"No\");\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "int x1 = 1, x2 = 1, x3 = 1,\n"
            + "                y1 = 1, y2 = 4, y3 = 5;\n"
            + "\n"
            + "        collinear(x1, y1, x2, y2, x3, y3);\n"
            + "\n"
            + "    }\n"
            + "}";
    private String triangleangles = "/* Codigo JAVA para encontrar todos los angulos\n"
            + "de un triángulos dadas las coordenadas\n"
            + "de los tres vertices*/\n"
            + "import java.awt.Point;\n"
            + "import static java.lang.Math.PI;\n"
            + "import static java.lang.Math.sqrt;\n"
            + "import static java.lang.Math.acos;\n"
            + "\n"
            + "public class TriangleAngles {   // Regresa el cuadrado de la distancia b/w de //dos puntos\n"
            + "\n"
            + "static int lengthSquare(Point p1, Point p2) {\n"
            + "        int xDiff = p1.x - p2.x;\n"
            + "int yDiff = p1.y - p2.y;\n"
            + "return xDiff * xDiff + yDiff * yDiff;\n"
            + "    }\n"
            + "\n"
            + "    static void printAngle(Point A, Point B,\n"
            + "Point C) {\n"
            + "//Cuadrado de los tamaños de a2, b2, c2\n"
            + "int a2 = lengthSquare(B, C);\n"
            + "        int b2 = lengthSquare(A, C);\n"
            + "        int c2 = lengthSquare(A, B);\n"
            + "// Longitus de los lados de a, b, c \n"
            + "float a = (float) sqrt(a2);\n"
            + "        float b = (float) sqrt(b2);\n"
            + "        float c = (float) sqrt(c2);\n"
            + "// De la ley del coseno\n"
            + "        float alfa = (float) acos((b2 + c2 - a2) / (2 * b * c));\n"
            + "float beta = (float) acos((a2 + c2 - b2) / (2 * a * c));\n"
            + "        float gamma = (float) acos((a2 + b2 - c2) / (2 * a * b));\n"
            + "//Conversión a grados\n"
            + "        alfa = (float) (alfa * 180 / PI);\n"
            + "beta = (float) (beta * 180 / PI);\n"
            + "        gamma = (float) (gamma * 180 / PI);\n"
            + "//Imprimiendo los angulos\n"
            + "        // printing all the angles \n"
            + "        System.out.println(\"alfa : \" + alfa);\n"
            + "        System.out.println(\"beta : \" + beta);\n"
            + "        System.out.println(\"gamma : \" + gamma);\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        Point A = new Point(0, 0);\n"
            + "        Point B = new Point(0, 1);\n"
            + "        Point C = new Point(1, 0);\n"
            + "        printAngle(A, B, C);\n"
            + "}\n"
            + "}";
    private String addone = "// Programa Java en donde se agrega uno a\n"
            + "// un número dado\n"
            + "public class AddOne {\n"
            + "\n"
            + "static int addOne(int x) {\n"
            + "int m = 1;\n"
            + "//Voltea todos los sets de bits\n"
            + "        //hasta que encuentre un 0\n"
            + "        while ((int) (x & m) == 1) {\n"
            + "            x = x ^ m;\n"
            + "            m <<= 1;\n"
            + "        }\n"
            + "//Voltea el bit 0 de más de la derecha\n"
            + "x = x ^ m;\n"
            + "        return x;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "System.out.println(addOne(13));\n"
            + "    }\n"
            + "}";
    private String binarypalindromen = "/* Programa Java para buscar el Nesimo número el cual\n"
            + "su binario es un palindromo*/\n"
            + "public class BinaryPalindromeN {\n"
            + "    static int INT_MAX = 2147483647;\n"
            + "/*Busca si el kesimo bit esta \n"
            + "puesto en la representacion binaria*/\n"
            + "static int isKthBitSet(int x, int k) {\n"
            + "return ((x & (1\n"
            + "<< (k - 1))) > 0) ? 1 : 0;\n"
            + "    }\n"
            + "    /*Retorna la posicion de más a la izquierda\n"
            + "    el set de bits en la representacion binaria*/\n"
            + "static int leftmostSetBit(int x) {\n"
            + "        int count = 0;\n"
            + "        while (x > 0) {\n"
            + "            count++;\n"
            + "x = x >> 1;\n"
            + "        }\n"
            + "        return count;\n"
            + "    }\n"
            + "/*Encuentra cuales sean los enteros en binario\n"
            + "    siendo plindromos o no*/\n"
            + "    static int isBinPalindrome(int x) {\n"
            + "int l = leftmostSetBit(x);\n"
            + "        int r = 1;\n"
            + "//Uno a uno se comparan los bits\n"
            + "        while (l > r) {\n"
            + "//Comprara bits de izquierda y derecha\n"
            + "// y converge \n"
            + "            if (isKthBitSet(x, l)\n"
            + "                    != isKthBitSet(x, r)) {\n"
            + "                return 0;\n"
            + "            }\n"
            + "            l--;\n"
            + "            r++;\n"
            + "        }\n"
            + "        return 1;\n"
            + "    }\n"
            + "\n"
            + "    static int findNthPalindrome(int n) {\n"
            + "int pal_count = 0;\n"
            + "/*Comienza desde 1, atravieza por todos los\n"
            + "enteros*/\n"
            + "        int i = 0;\n"
            + "        for (i = 1; i <= INT_MAX; i++) {\n"
            + "            if (isBinPalindrome(i) > 0) {\n"
            + "                pal_count++;\n"
            + "}\n"
            + "/*Si nosotros llegamos n \n"
            + "            rompe el ciclo*/\n"
            + "if (pal_count == n) {\n"
            + "                break;\n"
            + "            }\n"
            + "        }\n"
            + "        return i;\n"
            + "    }\n"
            + "    public static void main(String[] args) {\n"
            + "        int n = 9;\n"
            + "        System.out.println(findNthPalindrome(n));\n"
            + "}\n"
            + "}";
    private String boothmultyply = "//Programa java para multiplicar dos número binarios usando\n"
            + "//el algoritmo de Booth\n"
            + "import java.util.Arrays;\n"
            + "\n"
            + "public class BoothMultiply {\n"
            + "    public static void main(String[] args) {\n"
            + "        int mt[] = new int[10];\n"
            + "        int sc;\n"
            + "int brn, qrn;\n"
            + "// Número de bits del multiplicando \n"
            + "        brn = 4;\n"
            + "// multiplicando \n"
            + "        int br[] = {0, 0, 1, 0};\n"
            + "//Copia multiplicador al arreglo temporal mt[]\n"
            + "for (int i = brn - 1; i >= 0; i--) {\n"
            + "            mt[i] = br[i];\n"
            + "        }\n"
            + "        int[] aux1 = Arrays.copyOf(br, br.length);\n"
            + "        for (int i = aux1.length - 1; i >= 0; i--) {\n"
            + "            br[aux1.length - i - 1] = aux1[i];\n"
            + "}\n"
            + "        complement(mt, brn);\n"
            + "// Número de bits del multiplicador\n"
            + "        qrn = 4;\n"
            + "// Conteo de secuencias\n"
            + "        sc = qrn;\n"
            + "// multiplicador\n"
            + "        int qr[] = {0, 0, 0, 1};\n"
            + "        int[] aux2 = Arrays.copyOf(qr, qr.length);\n"
            + "        for (int i = aux2.length - 1; i >= 0; i--) {\n"
            + "            qr[aux2.length - i - 1] = aux2[i];\n"
            + "        }\n"
            + "        boothAlgorithm(br, qr, mt, qrn, sc);\n"
            + "        System.out.print(\"\\nResult = \");\n"
            + "        for (int i = qrn - 1; i >= 0; i--) {\n"
            + "            System.out.print(qr[i]);\n"
            + "        }\n"
            + "        System.out.println(\"\");\n"
            + "    }\n"
            + "\n"
            + "    static void add(int ac[], int x[], int qrn) {\n"
            + "        int i, c = 0;\n"
            + "        for (i = 0; i < qrn; i++) {\n"
            + "//Actualizando acumulador con A=A+BR\n"
            + "ac[i] = ac[i] + x[i] + c;\n"
            + "            if (ac[i] > 1) {\n"
            + "                ac[i] = ac[i] % 2;\n"
            + "                c = 1;\n"
            + "            } else {\n"
            + "                c = 0;\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static void complement(int a[], int n) {\n"
            + "        int i;\n"
            + "        int x[] = new int[8];\n"
            + "        x[0] = 1;\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            a[i] = (a[i] + 1) % 2;\n"
            + "        }\n"
            + "        add(a, x, n);\n"
            + "    }\n"
            + "\n"
            + "    static void rightShift(int ac[], int qr[], int qn, int qrn) {\n"
            + "        int temp, i;\n"
            + "        temp = ac[0];\n"
            + "        qn = qr[0];\n"
            + "        System.out.print(\"\\t\\trightShift\\t\");\n"
            + "        for (i = 0; i < qrn - 1; i++) {\n"
            + "            ac[i] = ac[i + 1];\n"
            + "            qr[i] = qr[i + 1];\n"
            + "        }\n"
            + "        qr[qrn - 1] = temp;\n"
            + "    }\n"
            + "\n"
            + "    static void display(int ac[], int qr[], int qrn) {\n"
            + "        int i;\n"
            + "        for (i = qrn - 1; i >= 0; i--) {\n"
            + "            System.out.print(ac[i]);\n"
            + "        }\n"
            + "        System.out.print(\"\\t\");\n"
            + "\n"
            + "        for (i = qrn - 1; i >= 0; i--) {\n"
            + "            System.out.print(qr[i]);\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static void boothAlgorithm(int br[], int qr[], int mt[], int qrn, int sc) {\n"
            + "        int qn = 0, ac[] = new int[10];\n"
            + "        int temp = 0;\n"
            + "        System.out.print(\"qn\\tq[n+1]\\t\\tBR\\t\\tAC\\tQR\\t\\tsc\\n\");\n"
            + "        System.out.print(\"\\t\\t\\tinitial\\t\\t\");\n"
            + "        display(ac, qr, qrn);\n"
            + "        System.out.println(\"\\t\\t\" + sc);\n"
            + "        while (sc != 0) {\n"
            + "            System.out.print(qr[0] + \"\\t\" + qn);\n"
            + "// Segunda condición\n"
            + "            if ((qn + qr[0]) == 1) {\n"
            + "                if (temp == 0) {\n"
            + "//Restar BR  del acumulador  \n"
            + "add(ac, mt, qrn);\n"
            + "                    System.out.print(\"\\t\\tA = A - BR\\t\");\n"
            + "                    for (int i = qrn - 1; i >= 0; i--) {\n"
            + "                        System.out.print(ac[i]);\n"
            + "}\n"
            + "                    temp = 1;\n"
            + "                } // Tercera condicion\n"
            + "                else if (temp == 1) {\n"
            + "// Añade BR al acumulador \n"
            + "add(ac, br, qrn);\n"
            + "                    System.out.print(\"\\t\\tA = A + BR\\t\");\n"
            + "                    for (int i = qrn - 1; i >= 0; i--) {\n"
            + "                        System.out.print(ac[i]);\n"
            + "                    }\n"
            + "                    temp = 0;\n"
            + "                }\n"
            + "                System.out.print(\"\\n\\t\");\n"
            + "                rightShift(ac, qr, qn, qrn);\n"
            + "            } //Primera condicion\n"
            + "            else if (qn - qr[0] == 0) {\n"
            + "                rightShift(ac, qr, qn, qrn);\n"
            + "            }\n"
            + "            display(ac, qr, qrn);\n"
            + "            System.out.print(\"\\t\");\n"
            + "// Decrementar contador\n"
            + "            sc--;\n"
            + "            System.out.print(\"\\t\" + sc + \"\\n\");\n"
            + "        }\n"
            + "    }\n"
            + "}";
    private String closestnumberssamebits = "/* Programa JAVA de busqueda del siguiente número con \n"
            + "la misma cantidad de 1 que algun anterior*/\n"
            + "public class ClosestNumbersSamebits {\n"
            + "    static int getNext(int n) {\n"
            + "// Computa c0 y c1\n"
            + "        int c = n;\n"
            + "int c0 = 0;\n"
            + "        int c1 = 0;\n"
            + "        while (((c & 1) == 0)\n"
            + "&& (c != 0)) {\n"
            + "            c0++;\n"
            + "            c >>= 1;\n"
            + "        }\n"
            + "        while ((c & 1) == 1) {\n"
            + "            c1++;\n"
            + "c >>= 1;\n"
            + "        }\n"
            + "/*Si no hay número más grande \n"
            + "        con el número de 1 buscado*/\n"
            + "if (c0 + c1 == 31\n"
            + "                || c0 + c1 == 0) {\n"
            + "            return -1;\n"
            + "}\n"
            + "//Posicion de el más derecho cero \n"
            + "        int p = c0 + c1;\n"
            + "//Voltea el zero más derecho\n"
            + "        n |= (1 << p);\n"
            + "// Despeja todos los bits de la derecha de p\n"
            + "        n &= ~((1 << p) - 1);\n"
            + "//Inserta los (c1-1) a la derecha\n"
            + "n |= (1 << (c1 - 1)) - 1;\n"
            + "        return n;\n"
            + "    }\n"
            + "    public static void main(String[] args) {\n"
            + "        int n = 5; \n"
            + "        System.out.println(getNext(n));\n"
            + "        n = 8; \n"
            + "        System.out.println(getNext(n));\n"
            + "}\n"
            + "}";
    private String codeconversiongraytobinary = "// Programa en java para coversion binario - Gray e inverso\n"
            + "import java.io.*;\n"
            + "\n"
            + "public class CodeConversionGrayToBinary {\n"
            + "\n"
            + "    public static void main(String args[]) throws IOException {\n"
            + "\n"
            + "        String binary = \"01001\";\n"
            + "        System.out.println(\"Codigo gray de \" + binary + \" is \" + binarytoGray(binary));\n"
            + "\n"
            + "        String gray = \"01101\";\n"
            + "        System.out.println(\"Codigo Binaruo de \" + gray + \" is \" + graytoBinary(gray));\n"
            + "    }\n"
            + "\n"
            + "    static char xor_c(char a, char b) {\n"
            + "        return (a == b) ? '0' : '1';\n"
            + "    }\n"
            + "//Funcion para voltear el bit \n"
            + "    static char flip(char c) {\n"
            + "        return (c == '0') ? '1' : '0';\n"
            + "    }\n"
            + "//Funcion binario a gray\n"
            + "    static String binarytoGray(String binary) {\n"
            + "        String gray = \"\";\n"
            + "        gray += binary.charAt(0);\n"
            + "// Coomputa bits restantes, siguiente bit es conmutado haciendole\n"
            + "        // XOR del previo con el actual en binario\n"
            + "for (int i = 1; i < binary.length(); i++) {\n"
            + "/*Comcatena XOR del bit anterior con el actual*/\n"
            + "gray += xor_c(binary.charAt(i - 1),\n"
            + "                    binary.charAt(i));\n"
            + "        }\n"
            + "        return gray;\n"
            + "    }\n"
            + "//Funcion gray a binario\n"
            + "    static String graytoBinary(String gray) {\n"
            + "        String binary = \"\"; \n"
            + "        binary += gray.charAt(0);\n"
            + "// Computa bits restantes,\n"
            + "        for (int i = 1; i < gray.length(); i++) {\n"
            + "//Si el bit actual es 0, concatena el bit anterior\n"
            + "if (gray.charAt(i) == '0') {\n"
            + "binary += binary.charAt(i - 1);\n"
            + "            } \n"
            + "//Sino, concatena invertidamente el bit anterior\n"
            + "else {\n"
            + "                binary += flip(binary.charAt(i - 1));\n"
            + "}\n"
            + "        }\n"
            + "        return binary;\n"
            + "    }\n"
            + "}";
    private String countatob = "//Contar el número de bits que van a ser volteados para convertir A en B  \n"
            + "\n"
            + "public class CountAtoB { \n"
            + "    public static int countSetBits(int n) \n"
            + "    { \n"
            + "        int count = 0; \n"
            + "        while (n != 0) { \n"
            + "            count += n & 1; \n"
            + "            n >>= 1; \n"
            + "        } \n"
            + "        return count; \n"
            + "    } \n"
            + "    public static int FlippedCount(int a, int b) \n"
            + "{   //Retorna el conteo del set de bits en a XOR b \n"
            + "return countSetBits(a ^ b); \n"
            + "    } \n"
            + "    public static void main(String[] args) \n"
            + "    { 	\n"
            + "        int a = 10; \n"
            + "        int b = 20; \n"
            + "        System.out.print(FlippedCount(a, b)); \n"
            + "} \n"
            + "}";
    private String countsetbits = "//Un programa simpre que cuenta el set de bits\n"
            + "//en todos los números de 1 a n.\n"
            + "public class CountSetBits{ \n"
            + "    static int countSetBits( int n) \n"
            + "{ \n"
            + "// Inicializa el resultado\n"
            + "        int bitCount = 0; \n"
            + "for (int i = 1; i <= n; i++) \n"
            + "            bitCount += countSetBitsUtil(i); \n"
            + "        return bitCount; \n"
            + "} \n"
            + "//Funcion que uenta el set de  bits de un número x\n"
            + "static int countSetBitsUtil( int x) \n"
            + "    { \n"
            + "        if (x <= 0) \n"
            + "            return 0; \n"
            + "        return (x % 2 == 0 ? 0 : 1) +  \n"
            + "               countSetBitsUtil(x / 2); \n"
            + "    } \n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        int n = 4; \n"
            + "        System.out.print(\"Conteo total del set de bits es \"); \n"
            + "        System.out.print(countSetBits(n)); \n"
            + "} \n"
            + "} ";
    private String euclidnomodanddivide = "//Programa Java eficiente para realizar maximo comun divisor sin % y /\n"
            + "public class EuclidNoModAndDivide {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        System.out.println(gcd(8, 9));\n"
            + "    }\n"
            + "\n"
            + "    static int gcd(int a, int b) {\n"
            + "// Casos base\n"
            + "        if (b == 0 || a == b) {\n"
            + "            return a;\n"
            + "}\n"
            + "        if (a == 0) {\n"
            + "            return b;\n"
            + "        }\n"
            + "        /*Si ambos a y b son pares, divide ambos por 2\n"
            + "        y multiplica el resultado con 2*/\n"
            + "if ((a & 1) == 0 && (b & 1) == 0) {\n"
            + "            return gcd(a >> 1, b >> 1) << 1;\n"
            + "}\n"
            + "//Si a es par, y b es impar, divide a por 2\n"
            + "if ((a & 1) == 0 && (b & 1) != 0) {\n"
            + "            return gcd(a >> 1, b);\n"
            + "}\n"
            + "        //Si a es impar y b es par, divide b por 2\n"
            + "if ((a & 1) != 0 && (b & 1) == 0) {\n"
            + "            return gcd(a, b >> 1);\n"
            + "}\n"
            + "/*Si ambos son impares, entonces aplica el algoritmode \n"
            + "        resta normal, notese que el casp impar-impar siempre \n"
            + "        convierte casos impar-par  luego de una recursion*/\n"
            + "return (a > b) ? gcd(a - b, b) : gcd(a, b - a);\n"
            + "}\n"
            + "}";
    private String findduplicatesbitarray = "//Programa Java para imprimir todos los duplicados en un arreglo\n"
            + "\n"
            + "public class FindDuplicatesBitArray {\n"
            + "\n"
            + "    static class BitArray {\n"
            + "        int[] arr;\n"
            + "// Constructor \n"
            + "        public BitArray(int n) {\n"
            + "/*Divide por 32, para almacenar n bits, nosotros necesitamos\n"
            + "            n/32 +1 enteros (Asumiendo int esta almacenado usando 32 bits*/\n"
            + "            arr = new int[(n >> 5) + 1];\n"
            + "        }\n"
            + "// Obtener el valor de un bit en una posicion dada\n"
            + "        boolean get(int pos) {\n"
            + "//Divide por 32 para encontrar la posicion del entero\n"
            + "            int index = (pos >> 5);\n"
            + "//Ahora encuentra el bumero de bits en arr[index]\n"
            + "            int bitNo = (pos & 0x1F);\n"
            + "            //Encuentra el valor dado un número bit en arr[index]\n"
            + "            return (arr[index] & (1 << bitNo)) != 0;\n"
            + "        }\n"
            + "// Acomoda un bit en una posicion dada\n"
            + "        void set(int pos) {\n"
            + "// Encuentra indice de una posicion de un bit\n"
            + "            int index = (pos >> 5);\n"
            + "//Acomoda un número bot es arr[index] \n"
            + "int bitNo = (pos & 0x1F);\n"
            + "            arr[index] |= (1 << bitNo);\n"
            + "}\n"
            + "// Funcion de impresion de los duplicados\n"
            + "static void checkDuplicates(int[] arr) {\n"
            + "// Crea un bit con 320000 bits\n"
            + "            BitArray ba = new BitArray(320000);\n"
            + "\n"
            + "// Arreglo transverso de los elementos\n"
            + "            for (int i = 0; i < arr.length; i++) {\n"
            + "// Indice de un arreglo de bits \n"
            + "                int num = arr[i] - 1;\n"
            + "//Si número ya se encuentra presente en el arreglo de bits\n"
            + "if (ba.get(num)) {\n"
            + "                    System.out.print((num + 1) + \" \");\n"
            + "} // Si no inserte el número\n"
            + "                else {\n"
            + "ba.set(num);\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int[] arr = {10, 10, 1, 1, 2, 2, 3, 3};\n"
            + "        BitArray.checkDuplicates(arr);\n"
            + "}\n"
            + "}";
    private String greycodesofn = "//Programa Java para generar codigos de Gray Nesimos  \n"
            + "\n"
            + "import java.util.ArrayList;\n"
            + "\n"
            + "public class GrayCodesOfN {\n"
            + "\n"
            + "    static void generateGrayarr(int n) {\n"
            + "// Caso base\n"
            + "        if (n <= 0) {\n"
            + "            return;\n"
            + "}\n"
            + "        // 'arr' podria almacenar todos los codigos generados \n"
            + "ArrayList<String> arr = new ArrayList<String>();\n"
            + "// Comienza con un patron de un bit \n"
            + "        arr.add(\"0\");\n"
            + "        arr.add(\"1\");\n"
            + "        /* Cada iteracion de este ciclo genera 2*i codigos desde los \n"
            + "        i codigos generados previamente*/\n"
            + "        int i, j;\n"
            + "        for (i = 2; i < (1 << n); i = i << 1) {\n"
            + "/*Entra los previamente generados codigos de nuevo a arr[]\n"
            + "                en orden reverso, arr[] tiene el doble de número de codigos*/\n"
            + "for (j = i - 1; j >= 0; j--) {\n"
            + "                arr.add(arr.get(j));\n"
            + "}\n"
            + "// Concatena 0 a la primera mitad\n"
            + "            for (j = 0; j < i; j++) {\n"
            + "arr.set(j, \"0\" + arr.get(j));\n"
            + "}\n"
            + "// Concatena 1 a la segunda mitad\n"
            + "            for (j = i; j < 2 * i; j++) {\n"
            + "arr.set(j, \"1\" + arr.get(j));\n"
            + "            }\n"
            + "        }\n"
            + "// Imprime el contenido de arr\n"
            + "        for (i = 0; i < arr.size(); i++) {\n"
            + "            System.out.println(arr.get(i));\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "generateGrayarr(3);\n"
            + "    }\n"
            + "}";
    private String karatsubamultiply = "//Programa JAVA que realiza multiplicaciones\n"
            + "//Por medio del algoritmo de Karatsuba\n"
            + "import java.math.BigInteger;\n"
            + "import java.util.Scanner;\n"
            + "\n"
            + "public class KaratsubaMultiply {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        BigInteger x, y;\n"
            + "        Scanner sc = new Scanner(System.in);\n"
            + "x = sc.nextBigInteger();\n"
            + "        y = sc.nextBigInteger();\n"
            + "\n"
            + "BigInteger result = karatsuba(x, y);\n"
            + "        long result2 =karatsuba(x.longValue(), y.longValue());\n"
            + "        System.out.println(result);\n"
            + "        System.out.println(result2);\n"
            + "    }\n"
            + "\n"
            + "    private static long karatsuba(long x, long y) {\n"
            + "        if (x < 10 && y < 10) {\n"
            + "            return x * y;\n"
            + "        }\n"
            + "        int n = Math.max(Long.valueOf(x).toString().length(), (Long.valueOf(y).toString().length()));\n"
            + "        int m = n / 2 + n % 2;\n"
            + "        long a = x / (long) Math.pow(10, m);\n"
            + "        long b = x % (long) Math.pow(10, m);\n"
            + "        long c = y / (long) Math.pow(10, m);\n"
            + "        long d = y % (long) Math.pow(10, m);\n"
            + "        long step1 = karatsuba(a, c);\n"
            + "        long step2 = karatsuba(b, d);\n"
            + "        long step3 = karatsuba(a + b, c + d);\n"
            + "        long step4 = step3 - step2 - step1;\n"
            + "        long step5 = step1 * (long) Math.pow(10, m * 2) + step2 + step4 * (long) Math.pow(10, m);\n"
            + "        return step5;\n"
            + "    }\n"
            + "\n"
            + "    private static BigInteger karatsuba(BigInteger x, BigInteger y) {\n"
            + "        if (x.compareTo(BigInteger.valueOf(10)) < 0 && y.compareTo(BigInteger.valueOf(10)) < 0) {\n"
            + "            return x.multiply(y);\n"
            + "        }\n"
            + "        int n = Math.max(x.toString().length(), y.toString().length());\n"
            + "        int m = n / 2 + n % 2;\n"
            + "        BigInteger[] a_b = x.divideAndRemainder(BigInteger.valueOf(10).pow(m));\n"
            + "        BigInteger a = a_b[0];\n"
            + "        BigInteger b = a_b[1];\n"
            + "        BigInteger[] c_d = y.divideAndRemainder(BigInteger.valueOf(10).pow(m));\n"
            + "        BigInteger c = c_d[0];\n"
            + "        BigInteger d = c_d[1];\n"
            + "        BigInteger step1 = karatsuba(a, c);\n"
            + "        BigInteger step2 = karatsuba(b, d);\n"
            + "        BigInteger step3 = karatsuba(a.add(b), c.add(d));\n"
            + "        BigInteger step4 = step3.subtract(step2).subtract(step1);\n"
            + "        BigInteger step5 = step1.multiply(BigInteger.valueOf(10).pow(m * 2)).add(step2)\n"
            + "                .add(step4.multiply(BigInteger.valueOf(10).pow(m)));\n"
            + "return step5;\n"
            + "    }\n"
            + "}";
    private String maxconsecutiveone = "//Porgrama java para buscar el subset de 1 más largo\n"
            + "public class MaxConsecutiveOne {\n"
            + "\n"
            + "    static int flipBit(int a) {\n"
            + "/*Si todos los bits son 1, la representacion de 'a'\n"
            + "        tiene todos los unos*/\n"
            + "\n"
            + "        if (~a == 0) {\n"
            + "return 8 * sizeof();\n"
            + "        }\n"
            + "\n"
            + "        int currLen = 0, prevLen = 0, maxLen = 0;\n"
            + "while (a != 0) {\n"
            + "/*Si el bit actual es un 1\n"
            + "            entonces incrementa currLen++*/\n"
            + "            if ((a & 1) == 1) {\n"
            + "                currLen++;\n"
            + "            } \n"
            + "/*Si el bit actual es un 0\n"
            + "            revisa el siguiente bit de a*/\n"
            + "            else if ((a & 1) == 0) {\n"
            + "/*Actualiza prevLan a 0 (Si el siguiente bit es 0)\n"
            + "                o currLen (Si el siguiente bit es 1)*/\n"
            + "                prevLen = (a & 2) == 0 ? 0 : currLen;\n"
            + "/*Si dos bits consecutivos son 0\n"
            + "                entonces currLen tambien sera 0*/\n"
            + "                currLen = 0;\n"
            + "            }\n"
            + "// Actualiza maxLen si es requerido \n"
            + "            maxLen = Math.max(prevLen + currLen, maxLen);\n"
            + "\n"
            + "//Remueve el ultimo digito (Right shift) \n"
            + "            a >>= 1;\n"
            + "        }\n"
            + "/*Nosotros siempre podremos tener un secuencia de \n"
            + "        al menos un 1, este es un bit volteado*/\n"
            + "return maxLen + 1;\n"
            + "    }\n"
            + "\n"
            + "    static byte sizeof() {\n"
            + "        byte sizeOfInteger = 8;\n"
            + "        return sizeOfInteger;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        System.out.println(flipBit(13));\n"
            + "        System.out.println(flipBit(1775));\n"
            + "System.out.println(flipBit(15));\n"
            + "    }\n"
            + "}";
    private String massubarrayxor = "// Programa en JAVA para buscar el maximo subarreglo XOR  \n"
            + "public class MaxSubarrayXOR {\n"
            + "\n"
            + "    static int maxSubarrayXOR(int arr[], int n) {\n"
            + "int ans = Integer.MIN_VALUE; // Inicializar resultado \n"
            + "// Escogiendo puntos de inicio para los subarreglos\n"
            + "for (int i = 0; i < n; i++) {\n"
            + "// para guardar XOR del actual subarreglo\n"
            + "            int curr_xor = 0;\n"
            + "// Escojiendo puntos finales de subarreglos empezando por i\n"
            + "for (int j = i; j < n; j++) {\n"
            + "                curr_xor = curr_xor ^ arr[j];\n"
            + "                ans = Math.max(ans, curr_xor);\n"
            + "            }\n"
            + "        }\n"
            + "        return ans;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        int arr[] = {8, 1, 2, 12};\n"
            + "        int n = arr.length;\n"
            + "System.out.println(\"Maximo subarray XOR es \"\n"
            + "                + maxSubarrayXOR(arr, n));\n"
            + "    }\n"
            + "}";
    private String multiplybyseven = "// Programa Java para verificar si es \n"
            + "// multiplo de 7\n"
            + "public class MultiplyBySeven{ \n"
            + "\n"
            + "    static int multiplyBySeven(int n) \n"
            + "    {  \n"
            + "        return ((n << 3) - n); \n"
            + "    } \n"
            + "    public static void main (String arg[])  \n"
            + "    { \n"
            + "        int n = 4; \n"
            + "        System.out.println(multiplyBySeven(n)); \n"
            + "} \n"
            + "}";
    private String nmagicnumber = "// Programa en java para buscar el Nsimo\n"
            + "// número magico, un número magico esta definido como un número el cual puede ser expresado como\n"
            + "// una potencia de 5 o suma de potencias unicas de 5\n"
            + "// Algunos primeros número magicos son: 5, 25, 30(5 + 25), 125, 130(125 + 5), … en adelante\n"
            + "public class NMagicNumber {\n"
            + "    static int nthMagicNo(int n) {\n"
            + "int pow = 1, answer = 0;\n"
            + " // Ir a traves de cada bit de n\n"
            + "        while (n != 0) {\n"
            + "            pow = pow * 5;\n"
            + "// Si el untimo bit de n esta puesto\n"
            + "if ((int) (n & 1) == 1) {\n"
            + "                answer += pow;\n"
            + "}\n"
            + "//Proceder con el siguiente bit \n"
            + "            // 0 n= n/2 \n"
            + "n >>= 1;\n"
            + "        }\n"
            + "        return answer;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "int n = 5;\n"
            + "        System.out.println(\"Enesimo número\"\n"
            + "                + \" magico es \" + nthMagicNo(n));\n"
            + "    }\n"
            + "}";
    private String nsquarenopow = "// Programa en java para calcular el cuadrado\n"
            + "// Sin usar * ni Pow()\n"
            + "\n"
            + "public class NSquareNoPow {\n"
            + "\n"
            + "staticintsquare(intn) \n"
            + "    { \n"
            + "          \n"
            + "        // Caso base\n"
            + "        if(n == 0)  \n"
            + "            return0; \n"
            + "        if(n < 0)  \n"
            + "            n = -n;\n"
            + "        // Obtener floor(n/2) usando\n"
            + "        // right shift \n"
            + "        intx = n >> 1;\n"
            + "        // si n es par\n"
            + "        ; \n"
            + "        if(n % 2!= 0) \n"
            + "            return((square(x) << 2)  \n"
            + "                    + (x << 2) + 1); \n"
            + "        else// si n es impar\n"
            + "            return(square(x) << 2); \n"
            + "    } \n"
            + "  \n"
            + "      \n"
            + "      \n"
            + "    public static void main(String args[])  \n"
            + "    { \n"
            + "        for(intn = 1; n <= 5; n++) \n"
            + "        System.out.println(\"n = \"+ n + \n"
            + "                            \" n^2 = \"+  \n"
            + "                            square(n));  \n"
            + "    } \n"
            + "}";
    private String oddevenswap = "// Programa java para invertir bits pares  \n"
            + "// e impares de un número dado\n"
            + "public class OddEvenSwap {\n"
            + "\n"
            + "    static int swapBits(int x) {\n"
            + "// Obtener todos los bits par de x \n"
            + "int even_bits = x & 0xAAAAAAAA;\n"
            + "\n"
            + "//Obtener todos los bits impar de x \n"
            + "int odd_bits = x & 0x55555555;\n"
            + "\n"
            + "//  Movimiento derecho de bits pares\n"
            + "        even_bits >>= 1;\n"
            + "\n"
            + "// Movimiento izquierdo de bits impares \n"
            + "        odd_bits <<= 1;\n"
            + "\n"
            + "// combinar pares e impares\n"
            + "        return (even_bits | odd_bits);\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "int x = 23; // 00010111 \n"
            + "// La salida es 43 (00101011) \n"
            + "System.out.println(swapBits(x));\n"
            + "}\n"
            + "}";
    private String oddoccurrence = "//Programa JAVA para buscar la ocurrencia de un elemento\n"
            + "// número impar de veces\n"
            + "public class OddOccurrence { \n"
            + "\n"
            + "static int getOddOccurrence(int arr[], int arr_size) \n"
            + "    { \n"
            + "        int i; \n"
            + "        for (i = 0; i < arr_size; i++) { \n"
            + "            int count = 0; \n"
            + "            for (int j = 0; j < arr_size; j++) { \n"
            + "                if (arr[i] == arr[j]) \n"
            + "                    count++; \n"
            + "            } \n"
            + "            if (count % 2 != 0) \n"
            + "                return arr[i]; \n"
            + "        } \n"
            + "        return -1; \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        int arr[] = new int[]{ 2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2 }; \n"
            + "        int n = arr.length; \n"
            + "        System.out.println(getOddOccurrence(arr, n)); \n"
            + "} \n"
            + "}";
    private String oppositesigns = "//Programa Java para detectar si dos enteros\n"
            + "//tienen signos opuestos\n"
            + "\n"
            + "public class OppositeSigns {\n"
            + "\n"
            + "static boolean oppositeSigns(int x, int y) {\n"
            + "        return ((x ^ y) < 0);\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int x = 100, y = -100;\n"
            + "        if (oppositeSigns(x, y) == true) {\n"
            + "System.out.println(\"Signos opuestos\");\n"
            + "        } else {\n"
            + "            System.out.println(\"Signos no opuestos\");\n"
            + "}\n"
            + "        x = 100;\n"
            + "        y = 100;\n"
            + "        if (oppositeSigns(x, y) == true) {\n"
            + "            System.out.println(\"Signos son opuestos\");\n"
            + "        } else {\n"
            + "            System.out.println(\"Signos no son opuestos\");\n"
            + "}\n"
            + "    }\n"
            + "}";
    private String pandigitalconcatenations = "//Programa JAVA para buscar todas las concantenaaciones \n"
            + "//Pandigitales de dos Strings\n"
            + "import java.util.ArrayList;\n"
            + "\n"
            + "public class PandigitalConcatenations {\n"
            + "\n"
            + "    static ArrayList<String> v  = new ArrayList<String>();\n"
            + "\n"
            + "    static int isPanDigital(String s) {\n"
            + "        int digits[] = new int[10];\n"
            + "\n"
            + "        for (int i = 0; i < s.length(); i++) {\n"
            + "            digits[s.charAt(i)\n"
            + "                    - (int) '0'] = 1;\n"
            + "}\n"
            + "\n"
            + "// Digito i no esta presente \n"
            + "        // entones no es pandigital\n"
            + "for (int i = 0; i <= 9; i++) {\n"
            + "            if (digits[i] == 0) {\n"
            + "return 0;\n"
            + "            }\n"
            + "        }\n"
            + "        return 1;\n"
            + "    }\n"
            + "// Retorna el número de pares de strings \n"
            + "    // resultado en las concatenaciones pandigitales\n"
            + "    static int countPandigitalPairs() {\n"
            + "        //Itera sobre todos los pares \n"
            + "        int pairs = 0;\n"
            + "for (int i = 0; i < v.size(); i++) {\n"
            + "            for (int j = i + 1;\n"
            + "                    j < v.size(); j++) {\n"
            + "                if (isPanDigital(v.get(i)\n"
            + "                        + v.get(j)) == 1) {\n"
            + "                    pairs++;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "        return pairs;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        v.add(\"123567\");\n"
            + "        v.add(\"098234\");\n"
            + "        v.add(\"14765\");\n"
            + "        v.add(\"19804\");\n"
            + "        System.out.println(countPandigitalPairs());\n"
            + "}\n"
            + "}";
    private String poweroffour = "// Codigo Java para verificar si un número \n"
            + "// es una potencia de 4 o no\n"
            + "\n"
            + "public class PowerOfFour {\n"
            + "\n"
            + "    static int isPowerOfFour(int n) {\n"
            + "        if (n == 0) {\n"
            + "            return 0;\n"
            + "        }\n"
            + "        while (n != 1) {\n"
            + "            if (n % 4 != 0) {\n"
            + "                return 0;\n"
            + "            }\n"
            + "            n = n / 4;\n"
            + "        }\n"
            + "        return 1;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int test_no = 64;\n"
            + "        if (isPowerOfFour(test_no) == 1) {\n"
            + "System.out.println(test_no\n"
            + "                    + \" es potencia de   4\");\n"
            + "} else {\n"
            + "            System.out.println(test_no\n"
            + "+ \" no es potencia de 4\");\n"
            + "        }\n"
            + "        test_no = 17;\n"
            + "if (isPowerOfFour(test_no) == 1) {\n"
            + "            System.out.println(test_no\n"
            + "+ \" es potencia de  4\");\n"
            + "        } else {\n"
            + "            System.out.println(test_no\n"
            + "                    + \" no es potencia de 4\");\n"
            + "        }\n"
            + "    }\n"
            + "}";
    private String russianpeasantmultiply = "// Programa en java para multiplicar usando el algoritmo de  Russian Peasant  \n"
            + "\n"
            + "public class RussianPeasantMultiply {\n"
            + "// Funcion para multiplicar dos números \n"
            + "\n"
            + "static int russianPeasant(int a, int b) {\n"
            + "// Inicializar resultado\n"
            + "        int res = 0;\n"
            + "//Mientras el segundo no se convierta en 1\n"
            + "        while (b > 0) {\n"
            + "// Si el segundo número es  impar, \n"
            + "// añade el primer número al resultado \n"
            + "	 if ((b & 1) != 0) {\n"
            + "                res = res + a;\n"
            + "	 }\n"
            + "// El doble del primer número\n"
            + "            // y la mitad del segundo número \n"
            + "	 a = a << 1;\n"
            + "            b = b >> 1;\n"
            + "        }\n"
            + "        return res;\n"
            + "    }\n"
            + "    public static void main(String[] args) {\n"
            + "        System.out.println(russianPeasant(18, 1));\n"
            + "        System.out.println(russianPeasant(20, 12));\n"
            + "}\n"
            + "}";
    private String adyacencymatrix = "//Notacion java de una matriz de adyacencia\n"
            + "import java.util.Scanner;\n"
            + "\n"
            + "public class AdyacencyMatrix {\n"
            + "//matriz del grafo\n"
            + "    static int[][] G;\n"
            + "static Scanner sc = new Scanner(System.in);\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "//Vertices y caminos\n"
            + "        int V = 4, E = 8;\n"
            + "G = new int[V][V];\n"
            + "        for (int i = 0; i < V; i++) {\n"
            + "//desde hasta peso\n"
            + "            int aux1, aux2, aux3;\n"
            + "            aux1 = sc.nextInt();\n"
            + "            aux2 = sc.nextInt();\n"
            + "            aux3 = sc.nextInt();\n"
            + "            // solo este si es dirigido\n"
            + "            G[aux1][aux2] = aux3;\n"
            + "            // inverso si es no dirigido\n"
            + "G[aux2][aux1] = aux3;\n"
            + "        }\n"
            + "        print(V);\n"
            + "}\n"
            + "//Función que imprime la matriz de adyacencia\n"
            + "static void print(int V){\n"
            + "        for (int i = 0; i < V; i++) {\n"
            + "            for (int j = 0; j < V; j++) {\n"
            + "                System.out.print(G[i][j]+\" \");\n"
            + "}\n"
            + "            System.out.println(\"\");\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "}";
    private String listadyacency = "//Implementación java de una lista de adyacencia\n"
            + "import java.util.ArrayList;\n"
            + "import java.util.List;\n"
            + "import java.util.Scanner;\n"
            + "\n"
            + "public class ListAdyacency {\n"
            + "\n"
            + "static int N;\n"
            + "//Grafo dado por vertices\n"
            + "static Vertex[] G;\n"
            + "    static Scanner sc = new Scanner(System.in);\n"
            + "    public static void main(String[] args) {\n"
            + "// Vertices y caminos\n"
            + "        int V = 4, E = 8;\n"
            + "G = new Vertex[V];\n"
            + "        for (int i = 0; i < V; i++) {\n"
            + "//Inicializar cada lista de lista\n"
            + "            G[i].adj = new ArrayList<>();\n"
            + "}\n"
            + "        for (int i = 0; i < E; i++) {\n"
            + "// de hasta peso\n"
            + "            int aux1,aux2,aux3;\n"
            + "            aux1=sc.nextInt();\n"
            + "            aux2=sc.nextInt();\n"
            + "aux3=sc.nextInt();\n"
            + "            //Dirijido\n"
            + "            G[aux1].adj.add(new Edge(aux2,aux3));\n"
            + "//No dirigido\n"
            + "            G[aux2].adj.add(new Edge(aux1,aux3));\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static class Vertex {\n"
            + "        List<Edge> adj;\n"
            + "        public Vertex() {\n"
            + "            adj = new ArrayList<>();\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static class Edge {\n"
            + "        int to, w;\n"
            + "        public Edge(int to, int w) {\n"
            + "            this.to = to;\n"
            + "            this.w = w;\n"
            + "}\n"
            + "    }\n"
            + "}";
    private String bfs = "// Programa java que imprime BFS (Busqueda en anchura) transverso\n"
            + "// desde un vertice (nodo) dado como inicio\n"
            + "// BFS(int s) atraviesa vertices alcanzables desde s \n"
            + "import java.util.*;\n"
            + "//Esta clase representa un grafo dirigido usando listas de adyacencia\n"
            + "\n"
            + "public class BFS {\n"
            + "    public static void main(String args[]) {\n"
            + "        Graph g = new Graph(4);\n"
            + "        g.addEdge(0, 1);\n"
            + "        g.addEdge(0, 2);\n"
            + "        g.addEdge(1, 2);\n"
            + "        g.addEdge(2, 0);\n"
            + "g.addEdge(2, 3);\n"
            + "        g.addEdge(3, 3);\n"
            + "        System.out.println(\"Siguiendo su primera busqueda en anchura transverso\"\n"
            + "                + \"(iniciando desde el vertice 2)\");\n"
            + "        //Vertice de inicio\n"
            + "g.BFS(2);\n"
            + "    }\n"
            + "\n"
            + "  static  class Graph {\n"
            + "private final int V;   // número de vertices\n"
            + "        private LinkedList<Integer> adj[]; //lista de ayacencia\n"
            + "// Constructor\n"
            + "        Graph(int v) {\n"
            + "            V = v;\n"
            + "            adj = new LinkedList[v];\n"
            + "            for (int i = 0; i < v; ++i) {\n"
            + "adj[i] = new LinkedList();\n"
            + "            }\n"
            + "        }\n"
            + "// funcion que agrega un camino al grafo\n"
            + "void addEdge(int v, int w) {\n"
            + "            adj[v].add(w);\n"
            + "        }\n"
            + "        void BFS(int s) {\n"
            + "//Marka todos los verticoes como no visitados (Falso)\n"
            + "boolean visited[] = new boolean[V];\n"
            + "//Crea una cola para la BFS\n"
            + "// Create a queue for BFS \n"
            + "            LinkedList<Integer> queue = new LinkedList<>();\n"
            + "//Marca el nodo actual como vistiado y lo encola\n"
            + "visited[s] = true;\n"
            + "            queue.add(s);\n"
            + "while (!queue.isEmpty()) {\n"
            + "//Desencola un vertice de la cola y lo imprime\n"
            + "s = queue.poll();\n"
            + "                System.out.print(s + \" \");\n"
            + "/* Obtiene todos los vertices adyacentes del \n"
            + "                vertice desencolado, si un adyacente no ha \n"
            + "                sido visitado, lo marca lo visita y lo encola*/\n"
            + "Iterator<Integer> i = adj[s].listIterator();\n"
            + "                while (i.hasNext()) {\n"
            + "                    int n = i.next();\n"
            + "                    if (!visited[n]) {\n"
            + "                        visited[n] = true;\n"
            + "queue.add(n);\n"
            + "                    }\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "}";
    private String bfsallpaths = "//Programa java que imprime todos los caminos\n"
            + "// desde un inicio hasta un destino usando BFS\n"
            + "import java.util.ArrayList;\n"
            + "import java.util.List;\n"
            + "//Un grafo dirigido usando lista de adyacencia\n"
            + "public class BFSAllPaths {\n"
            + "// Número de vertices\n"
            + "    // No. of vertices in graph \n"
            + "static int v;\n"
            + "// lista de adyacencia\n"
            + "static ArrayList<Integer>[] adjList;\n"
            + "//Constructor \n"
            + "    static void initGraph(int vertices) {\n"
            + "//Inicializa número de vertices\n"
            + "        v = vertices;\n"
            + "// inicializa lista de adyacencia\n"
            + "        initAdjList();\n"
            + "}\n"
            + "    static void initAdjList() {\n"
            + "        adjList = new ArrayList[v];\n"
            + "        for (int i = 0; i < v; i++) {\n"
            + "            adjList[i] = new ArrayList<>();\n"
            + "        }\n"
            + "    }\n"
            + "//Agrega camino de u a v\n"
            + "    static void addEdge(int u, int v) {\n"
            + "// Agrega v a la lista de u\n"
            + "        adjList[u].add(v);\n"
            + "    }\n"
            + "//Imrpime todos los caminos de \n"
            + "// 's' a 'd' \n"
            + "    static void printAllPaths(int s, int d) {\n"
            + "        boolean[] isVisited = new boolean[v];\n"
            + "        ArrayList<Integer> pathList = new ArrayList<>();\n"
            + "        //Agrega origen al path[]\n"
            + "        pathList.add(s);\n"
            + "        printAllPathsUtil(s, d, isVisited, pathList);\n"
            + "}\n"
            + "//Función recursiva que imprime \n"
            + "    /*Todos los caminos de u a d.\n"
            + "    isVisited[] mantiene rastro de\n"
            + "    los vertices en el camino actual\n"
            + "    localPathList<> almacena vertices actuales\n"
            + "    en el camino actual*/\n"
            + "static void printAllPathsUtil(Integer u, Integer d,\n"
            + "            boolean[] isVisited,\n"
            + "List<Integer> localPathList) {\n"
            + "        // Marca el nodo actual\n"
            + "isVisited[u] = true;\n"
            + "        if (u.equals(d)) {\n"
            + "System.out.println(localPathList);\n"
            + "// Si coincidencia encontrada entonces\n"
            + "            // no se necesita atravesar más profundo\n"
            + "            isVisited[u] = false;\n"
            + "            return;\n"
            + "        }\n"
            + "// Recorre todos los vertices \n"
            + "//adyacentes al actual vertice \n"
            + "        for (Integer i : adjList[u]) {\n"
            + "            if (!isVisited[i]) {\n"
            + "// Almacena el nodo actual\n"
            + "                // en path[]\n"
            + "localPathList.add(i);\n"
            + "                printAllPathsUtil(i, d, isVisited, localPathList);\n"
            + "\n"
            + "localPathList.remove(i);\n"
            + "            }\n"
            + "        }\n"
            + "// MArca el nodo actual\n"
            + "isVisited[u] = false;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "//Crea el grafo\n"
            + "        initGraph(4);\n"
            + "//camino desde hasta\n"
            + "addEdge(0, 1);\n"
            + "        addEdge(0, 2);\n"
            + "        addEdge(0, 3);\n"
            + "        addEdge(2, 0);\n"
            + "        addEdge(2, 1);\n"
            + "addEdge(1, 3);\n"
            + "// inicio arbitrario\n"
            + "        int s = 0;\n"
            + "// destino arbitrario\n"
            + "        int d = 3;\n"
            + "        System.out.println(\"Los siguientes son todos los diferentes\"\n"
            + "                + \"caminos de \" + s + \" a \" + d);\n"
            + "        printAllPaths(s, d);\n"
            + "\n"
            + "    }\n"
            + "}";
    private String binarygraphshortestpath = "//Programa java que implementa el camino más corto\n"
            + "// en un grafo binario\n"
            + "import java.util.ArrayDeque;\n"
            + "import java.util.ArrayList;\n"
            + "import java.util.Deque;\n"
            + "\n"
            + "public class BinaryGraphShortestPath {\n"
            + "//Número de vertices\n"
            + "static int V = 9;\n"
            + "// Lista de listas que almacena los caminos\n"
            + "static ArrayList<ArrayList<node>> edges = new ArrayList<ArrayList<node>>();\n"
            + "    public static void main(String[] args) {\n"
            + "        for (int i = 0; i < V; i++) {\n"
            + "            edges.add(new ArrayList<>());\n"
            + "        }\n"
            + "        addEdge(0, 1, 0);\n"
            + "        addEdge(0, 7, 1);\n"
            + "        addEdge(1, 7, 1);\n"
            + "        addEdge(1, 2, 1);\n"
            + "        addEdge(2, 3, 0);\n"
            + "        addEdge(2, 5, 0);\n"
            + "        addEdge(2, 8, 1);\n"
            + "        addEdge(3, 4, 1);\n"
            + "        addEdge(3, 5, 1);\n"
            + "        addEdge(4, 5, 1);\n"
            + "        addEdge(5, 6, 1);\n"
            + "        addEdge(6, 7, 1);\n"
            + "        addEdge(7, 8, 1);\n"
            + "        int src = 0;//Nodo inicial\n"
            + "        zeroOneBFS(src);\n"
            + "    }\n"
            + "\n"
            + "\n"
            + "   static void zeroOneBFS(int src) {\n"
            + "// Inicializa las distancias desde el nodo inicial\n"
            + "\n"
            + "int dist[] = new int[V];\n"
            + "        for (int i = 0; i < V; i++) {\n"
            + "            dist[i] = Integer.MAX_VALUE;\n"
            + "}\n"
            + "//cola doble para el BFS. \n"
            + "Deque<Integer> Q = new ArrayDeque<>();\n"
            + "        dist[src] = 0;\n"
            + "        Q.add(src);\n"
            + "        while (!Q.isEmpty()) {\n"
            + "            int v = Q.getFirst();\n"
            + "            Q.removeFirst();\n"
            + "            for (int i = 0; i < edges.get(v).size(); i++) {\n"
            + "//Busca la distancia optima\n"
            + "                if (dist[edges.get(v).get(i).to] > dist[v] + edges.get(v).get(i).weight) {\n"
            + "                    dist[edges.get(v).get(i).to] = dist[v] + edges.get(v).get(i).weight;\n"
            + "/* pone peso caminos de peso 0 al frente y 1 atras para \n"
            + "                    que los vertices puedan ser procesados en orden ascendente\n"
            + "por sus pesos*/\n"
            + "                    if (edges.get(v).get(i).weight == 0) {\n"
            + "                        Q.addFirst(edges.get(v).get(i).to);\n"
            + "                    } else {\n"
            + "                        Q.addLast(edges.get(v).get(i).to);\n"
            + "}\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "//imprimiendo los caminos más cortos\n"
            + "        for (int i = 0; i < V; i++) {\n"
            + "System.out.print(dist[i] + \" \");\n"
            + "        }\n"
            + "        System.out.println(\"\");\n"
            + "    }\n"
            + "\n"
            + "    static void addEdge(int u, int v, int wt) {\n"
            + "        edges.get(u).add(new node(v, wt));\n"
            + "        edges.get(v).add(new node(u, wt));\n"
            + "}\n"
            + "\n"
            + "// una estructura que representa los caminos\n"
            + "    static class node {\n"
            + "// Dos variables, una denora el nodo\n"
            + "        // destino y otra el peso\n"
            + "        int to, weight;\n"
            + "public node(int to, int weight) {\n"
            + "            this.to = to;\n"
            + "            this.weight = weight;\n"
            + "}\n"
            + "    }\n"
            + "}";
    private String countallpaths = "// Programa java que cuenta todos los caminos de un\n"
            + "// inicio a un destino. \n"
            + "\n"
            + "import java.util.Arrays;\n"
            + "import java.util.Iterator;\n"
            + "import java.util.LinkedList;\n"
            + "\n"
            + "public class CountAllPaths {\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        Graph g = new Graph(4);\n"
            + "        g.addEdge(0, 1);\n"
            + "        g.addEdge(0, 2);\n"
            + "        g.addEdge(0, 3);\n"
            + "        g.addEdge(2, 0);\n"
            + "        g.addEdge(2, 1);\n"
            + "        g.addEdge(1, 3);\n"
            + "        int s = 2, d = 3;\n"
            + "        System.out.println(g.countPaths(s, d));\n"
            + "    }\n"
            + "\n"
            + "    static class Graph {\n"
            + "\n"
            + "// Número de vertices\n"
            + "private int V;\n"
            + "// array de listas de adyacencia\n"
            + "private LinkedList<Integer> adj[];\n"
            + "\n"
            + "        Graph(int v) {\n"
            + "            V = v;\n"
            + "            adj = new LinkedList[v];\n"
            + "            for (int i = 0; i < v; ++i) {\n"
            + "adj[i] = new LinkedList<>();\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "//agrgar caminos en un grafo\n"
            + "void addEdge(int v, int w) {\n"
            + "//agrega w a las listas de v\n"
            + "            adj[v].add(w);\n"
            + "        }\n"
            + "\n"
            + "// Un metodo recursivo que cuenta\n"
            + "        // todos los caminos de u a d \n"
            + "int countPathsUtil(int u, int d,\n"
            + "boolean visited[],\n"
            + "                int pathCount) {\n"
            + "//Marca el nodo actual como visitado\n"
            + "            //y lo imprime\n"
            + "            visited[u] = true;\n"
            + "// Si el vertice actual es igual\n"
            + "            // al destino, incrementa el conteo\n"
            + "            if (u == d) {\n"
            + "                pathCount++;\n"
            + "            } // Recore todos los vertices  \n"
            + "            // adyacentes a este vertice\n"
            + "else {\n"
            + "                Iterator<Integer> i = adj[u].listIterator();\n"
            + "                while (i.hasNext()) {\n"
            + "                    int n = i.next();\n"
            + "                    if (!visited[n]) {\n"
            + "                        pathCount = countPathsUtil(n, d,\n"
            + "                                visited,\n"
            + "                                pathCount);\n"
            + "                    }\n"
            + "                }\n"
            + "            }\n"
            + "            visited[u] = false;\n"
            + "            return pathCount;\n"
            + "}\n"
            + " // Retorna conteo de caminos desde s a d\n"
            + "int countPaths(int s, int d) {\n"
            + "//Marca todos los vertices como no visitados\n"
            + "boolean visited[] = new boolean[V];\n"
            + "            Arrays.fill(visited, false);\n"
            + "            int pathCount = 0;\n"
            + "            pathCount = countPathsUtil(s, d,\n"
            + "                    visited,\n"
            + "pathCount);\n"
            + "            return pathCount;\n"
            + "        }\n"
            + "    }\n"
            + "}";
    private String cycleinadirectedgraph = "// Programa java que detecta ciclo en un grafo\n"
            + "\n"
            + "import java.util.ArrayList;\n"
            + "import java.util.LinkedList;\n"
            + "import java.util.List;\n"
            + "\n"
            + "public class CycleInADirectedGraph {\n"
            + "\n"
            + "    static class Graph {\n"
            + "\n"
            + "        private final int V;\n"
            + "        private final List<List<Integer>> adj;\n"
            + "\n"
            + "        public Graph(int V) {\n"
            + "            this.V = V;\n"
            + "            adj = new ArrayList<>(V);\n"
            + "            for (int i = 0; i < V; i++) {\n"
            + "                adj.add(new LinkedList<>());\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        private boolean isCyclicUtil(int i, boolean[] visited,\n"
            + "boolean[] recStack) {\n"
            + "/* Marca el nodo actual como visitado \n"
            + "            y parte de la pila de recursión*/\n"
            + "if (recStack[i]) {\n"
            + "                return true;\n"
            + "            }\n"
            + "            if (visited[i]) {\n"
            + "                return false;\n"
            + "            }\n"
            + "            visited[i] = true;\n"
            + "            recStack[i] = true;\n"
            + "            List<Integer> children = adj.get(i);\n"
            + "\n"
            + "            if (children.stream().anyMatch((c) -> (isCyclicUtil(c, visited, recStack)))) {\n"
            + "                return true;\n"
            + "            }\n"
            + "            recStack[i] = false;\n"
            + "            return false;\n"
            + "        }\n"
            + "\n"
            + "        private void addEdge(int source, int dest) {\n"
            + "            adj.get(source).add(dest);\n"
            + "}\n"
            + "\n"
            + " /* Retorna true si el grafo tiene un ciclo, si no falso*/\n"
            + "        private boolean isCyclic() {\n"
            + "//Marca todos los vetices como no visitados\n"
            + "            // y no parte de la pila de recursión\n"
            + "boolean[] visited = new boolean[V];\n"
            + "            boolean[] recStack = new boolean[V];\n"
            + "            for (int i = 0; i < V; i++) {\n"
            + "                if (isCyclicUtil(i, visited, recStack)) {\n"
            + "                    return true;\n"
            + "                }\n"
            + "            }\n"
            + "\n"
            + "            return false;\n"
            + "        }\n"
            + "\n"
            + "        public static void main(String[] args) {\n"
            + "            Graph graph = new Graph(4);\n"
            + "            graph.addEdge(0, 1);\n"
            + "            graph.addEdge(0, 2);\n"
            + "            graph.addEdge(1, 2);\n"
            + "            graph.addEdge(2, 0);\n"
            + "            graph.addEdge(2, 3);\n"
            + "            graph.addEdge(3, 3);\n"
            + "            if (graph.isCyclic()) {\n"
            + "System.out.println(\"El grafo contiene un ciclo\");\n"
            + "            } else {\n"
            + "                System.out.println(\"El grafo no contiene\"\n"
            + "                        + \"un ciclo\");\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "}";
    private String dfs = "// Programa java que imprime DFS transverso en un grafo\n"
            + "import java.util.*; \n"
            + "public class DFS {\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        Graph g = new Graph(4);\n"
            + "        g.addEdge(0, 1);\n"
            + "        g.addEdge(0, 2);\n"
            + "        g.addEdge(1, 2);\n"
            + "        g.addEdge(2, 0);\n"
            + "g.addEdge(2, 3);\n"
            + "        g.addEdge(3, 3);\n"
            + "        System.out.println(\"Siguiendo la primera busqueda en profundidad \"\n"
            + "                + \"(iniciando desde vertice  2)\");\n"
            + "        g.DFS(2);\n"
            + "}\n"
            + "\n"
            + "    static class Graph {\n"
            + "\n"
            + "        private int V;  // número de vertices \n"
            + "// Array de listas de adyacencia\n"
            + "        private LinkedList<Integer> adj[];\n"
            + "Graph(int v) {\n"
            + "            V = v;\n"
            + "            adj = new LinkedList[v];\n"
            + "            for (int i = 0; i < v; ++i) {\n"
            + "                adj[i] = new LinkedList();\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "//Agregando caminos\n"
            + "        void addEdge(int v, int w) {\n"
            + "            adj[v].add(w);  \n"
            + "        }\n"
            + "\n"
            + "        void DFSUtil(int v, boolean visited[]) {\n"
            + "// Marca el nodo actual como visitado y lo imprime\n"
            + "visited[v] = true;\n"
            + "            System.out.print(v + \" \");\n"
            + "// Recorre todos los vertices adyacentes a este vertice\n"
            + "Iterator<Integer> i = adj[v].listIterator();\n"
            + "            while (i.hasNext()) {\n"
            + "                int n = i.next();\n"
            + "                if (!visited[n]) {\n"
            + "                    DFSUtil(n, visited);\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        void DFS(int v) {\n"
            + "//Marca todos los vertices como no visitados (Falso)\n"
            + "boolean visited[] = new boolean[V];\n"
            + "DFSUtil(v, visited);\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "}";
    private String dfstransitiveclosure = "//Programa java que imprime el cerramiento transitivo de un grafo\n"
            + "import java.util.ArrayList;\n"
            + "import java.util.Arrays;\n"
            + "public class DFSTransitiveClosure {\n"
            + "    public static void main(String[] args) {\n"
            + "        Graph g = new Graph(4);\n"
            + "        g.addEdge(0, 1);\n"
            + "        g.addEdge(0, 2);\n"
            + "        g.addEdge(1, 2);\n"
            + "        g.addEdge(2, 0);\n"
            + "g.addEdge(2, 3);\n"
            + "        g.addEdge(3, 3);\n"
            + "        System.out.println(\"Matriz de cerramiento transitivo es \");\n"
            + "g.transitiveClosure();\n"
            + "    }\n"
            + "    static class Graph {\n"
            + "// número de vertices\n"
            + "        private int vertices;\n"
            + "// lista de adyacencia \n"
            + "        private ArrayList<Integer>[] adjList;\n"
            + "// para almacenar el cerramiento transitivo\n"
            + "        private int[][] tc;\n"
            + "// Constructor \n"
            + "        public Graph(int vertices) {\n"
            + "// inicializa el conteo de vertices\n"
            + "            this.vertices = vertices;\n"
            + "this.tc = new int[this.vertices][this.vertices];\n"
            + "// initializa lista de adyacencia\n"
            + "            initAdjList();\n"
            + "}\n"
            + "        private void initAdjList() {\n"
            + "            adjList = new ArrayList[vertices];\n"
            + "            for (int i = 0; i < vertices; i++) {\n"
            + "                adjList[i] = new ArrayList<>();\n"
            + "            }\n"
            + "        }\n"
            + "// Agregar caminos\n"
            + "        public void addEdge(int u, int v) {\n"
            + "adjList[u].add(v);\n"
            + "        }\n"
            + "// buscando cerramiento transitivo\n"
            + "public void transitiveClosure() {\n"
            + "            for (int i = 0; i < vertices; i++) {\n"
            + "                dfsUtil(i, i);\n"
            + "            }\n"
            + "            for (int i = 0; i < vertices; i++) {\n"
            + "                System.out.println(Arrays.toString(tc[i]));\n"
            + "            }\n"
            + "        }\n"
            + "        private void dfsUtil(int s, int v) {\n"
            + "// Marca alcance desde s a v como true\n"
            + "            tc[s][v] = 1;\n"
            + "// Encuentra todos los vertices alcanzables \n"
            + "// atraves de v\n"
            + "            for (int adj : adjList[v]) {\n"
            + "                if (tc[s][adj] == 0) {\n"
            + "dfsUtil(s, adj);\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "}";
    private String disconnectedgraphbfs = "// Implementación de BFS modificado\n"
            + "import java.util.*;\n"
            + "\n"
            + "public class DisconnectedGraphBFS {\n"
            + "// Implementando grafo usando HashMap \n"
            + "static HashMap<Integer, LinkedList<Integer>> graph = new HashMap<>();\n"
            + "// Agregar caminos al grafo\n"
            + "    public static void addEdge(int a, int b) {\n"
            + "        if (graph.containsKey(a)) {\n"
            + "            LinkedList<Integer> l = graph.get(a);\n"
            + "            l.add(b);\n"
            + "            graph.put(a, l);\n"
            + "        } else {\n"
            + "            LinkedList<Integer> l = new LinkedList<>();\n"
            + "            l.add(b);\n"
            + "            graph.put(a, l);\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void bfshelp(int s, ArrayList<Boolean> visited) {\n"
            + "// Crea una cola para el BFS\n"
            + "LinkedList<Integer> q = new LinkedList<>();\n"
            + "//Marca el nodo actual como visitado y lo encola\n"
            + "q.add(s);\n"
            + "        visited.set(s, true);\n"
            + "while (!q.isEmpty()) {\n"
            + "// Desencola un vertice de la cola y la imprime\n"
            + "int f = q.poll();\n"
            + "            System.out.print(f + \" \");\n"
            + "// Verifica cuando el nodo actual esta conectado\n"
            + "// a otro nodo o no\n"
            + "            if (graph.containsKey(f)) {\n"
            + "                Iterator<Integer> i = graph.get(f).listIterator();\n"
            + "// Obtiene todos los nodos adyacentes \n"
            + "                // del nodo desencolado f, si no ha sido visitado\n"
            + "                // lo marca y lo encola\n"
            + "                while (i.hasNext()) {\n"
            + "int n = i.next();\n"
            + "                    if (!visited.get(n)) {\n"
            + "                        visited.set(n, true);\n"
            + "                        q.add(n);\n"
            + "}\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "//Fución BFS que verifica cada nodo\n"
            + "public static void bfs(int vertex) {\n"
            + "        ArrayList<Boolean> visited = new ArrayList<>();\n"
            + "//Marcando cada nodo como no visitado\n"
            + "for (int i = 0; i < vertex; i++) {\n"
            + "            visited.add(i, false);\n"
            + "        }\n"
            + "        for (int i = 0; i < vertex; i++) {\n"
            + "//Verificando cuantos nodos no han sido visitados\n"
            + "if (!visited.get(i)) {\n"
            + "                bfshelp(i, visited);\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int v = 5;\n"
            + "        addEdge(0, 4);\n"
            + "        addEdge(1, 2);\n"
            + "        addEdge(1, 3);\n"
            + "        addEdge(1, 4);\n"
            + "        addEdge(2, 3);\n"
            + "        addEdge(3, 4);\n"
            + "        bfs(v);\n"
            + "}\n"
            + "}";
    private String euleriancycledirectedgraph = "// Programa java que verifica si un grafo es Euleriano\n"
            + "import java.util.*;\n"
            + "import java.util.LinkedList;\n"
            + "\n"
            + "public class EulerianCycleDirectedGraph {\n"
            + "\n"
            + "    public static void main(String[] args) throws java.lang.Exception {\n"
            + "        Graph g = new Graph(5);\n"
            + "        g.addEdge(1, 0);\n"
            + "        g.addEdge(0, 2);\n"
            + "        g.addEdge(2, 1);\n"
            + "        g.addEdge(0, 3);\n"
            + "        g.addEdge(3, 4);\n"
            + "        g.addEdge(4, 0);\n"
            + "        if (g.isEulerianCycle()) {\n"
            + "System.out.println(\"El grafo dado es euleriano \");\n"
            + "        } else {\n"
            + "            System.out.println(\"El grafo dado no es euleriano \");\n"
            + "}\n"
            + "    }\n"
            + "\n"
            + "\n"
            + "    static class Graph {\n"
            + "\n"
            + "        private int V;   // Número de vertices\n"
            + "private LinkedList<Integer> adj[];//Lista de adyacencia\n"
            + "        private int in[];            //Manteniendo los grados\n"
            + "//Constructor \n"
            + "        Graph(int v) {\n"
            + "            V = v;\n"
            + "            adj = new LinkedList[v];\n"
            + "            in = new int[V];\n"
            + "            for (int i = 0; i < v; ++i) {\n"
            + "                adj[i] = new LinkedList();\n"
            + "                in[i] = 0;\n"
            + "            }\n"
            + "        }\n"
            + "//Agregar caminos \n"
            + "        void addEdge(int v, int w) {\n"
            + "            adj[v].add(w);\n"
            + "            in[w]++;\n"
            + "        }\n"
            + "        void DFSUtil(int v, Boolean visited[]) {\n"
            + "// Marca nodo actual como visitado\n"
            + "            visited[v] = true;\n"
            + "            int n;\n"
            + "//  recorre todos los nodos adyacentes a este vertice \n"
            + "Iterator<Integer> i = adj[v].iterator();\n"
            + "            while (i.hasNext()) {\n"
            + "                n = i.next();\n"
            + "                if (!visited[n]) {\n"
            + "                    DFSUtil(n, visited);\n"
            + "}\n"
            + "            }\n"
            + "        }\n"
            + "// Retornar el transpuesto de este grafo \n"
            + "Graph getTranspose() {\n"
            + "            Graph g = new Graph(V);\n"
            + "            for (int v = 0; v < V; v++) {\n"
            + "                Iterator<Integer> i = adj[v].listIterator();\n"
            + "                while (i.hasNext()) {\n"
            + "                    g.adj[i.next()].add(v);\n"
            + "                    (g.in[v])++;\n"
            + "                }\n"
            + "            }\n"
            + "            return g;\n"
            + "}\n"
            + "// Verifica si el grafo esta fuertemente conectado\n"
            + "        Boolean isSC() {\n"
            + "/*Paso 1: Marca todos los vertices como \n"
            + "no visitados (Primer DFS)*/\n"
            + "            Boolean visited[] = new Boolean[V];\n"
            + "            for (int i = 0; i < V; i++) {\n"
            + "visited[i] = false;\n"
            + "            }\n"
            + "/* Paso 2: Hace DFS transverso \n"
            + "            iniciando del primer vertice*/\n"
            + "            DFSUtil(0, visited);\n"
            + "//  Si DFS no visita todos los nodos, retorna falso \n"
            + "for (int i = 0; i < V; i++) {\n"
            + "                if (visited[i] == false) {\n"
            + "                    return false;\n"
            + "}\n"
            + "            }\n"
            + " /* Paso 3: Crea un grafo reversado*/\n"
            + "            Graph gr = getTranspose();\n"
            + "/* Paso 4: marca todos los vertices \n"
            + "            como no visitados (Segundo dfs)*/\n"
            + "for (int i = 0; i < V; i++) {\n"
            + "visited[i] = false;\n"
            + "            }\n"
            + "/* Paso 5: hacer DFS para el grafo reverso \n"
            + "            iniciando desde el vertice primero\n"
            + "            debe ser el mismo que el primer DFS*/ \n"
            + "            gr.DFSUtil(0, visited);\n"
            + "// Si todos los vertices no son visitados en el segund\n"
            + "// DFS retorna falso\n"
            + "            for (int i = 0; i < V; i++) {\n"
            + "                if (visited[i] == false) {\n"
            + "                    return false;\n"
            + "}\n"
            + "            }\n"
            + "            return true;\n"
            + "        }\n"
            + "/* Esta función retorna true si encuentra un \n"
            + "        ciclo de euler, falso si no*/\n"
            + "        Boolean isEulerianCycle() {\n"
            + "// verifica si todos los vertices con grado no cero\n"
            + "            // viendo si estan conectados\n"
            + "            if (isSC() == false) {\n"
            + "                return false;\n"
            + "            }\n"
            + "// Verifica si en grado de entrada y \n"
            + "// salida cada vertice es igual \n"
            + "            for (int i = 0; i < V; i++) {\n"
            + "                if (adj[i].size() != in[i]) {\n"
            + "return false;\n"
            + "                }\n"
            + "            }\n"
            + "            return true;\n"
            + "        }\n"
            + "    }\n"
            + "}";
    private String eulerianpathundirectedgraph = "// Programa java que busca camino euleriano\n"
            + "// de un grafo\n"
            + "import java.util.*;\n"
            + "import java.util.LinkedList;\n"
            + "\n"
            + "public class EulerianPathUndirectedGraph {\n"
            + "    public static void main(String args[]) {\n"
            + "// Creamos varios ejemplos de grafos para probar\n"
            + "Graph g1 = new Graph(5);\n"
            + "        g1.addEdge(1, 0);\n"
            + "        g1.addEdge(0, 2);\n"
            + "        g1.addEdge(2, 1);\n"
            + "        g1.addEdge(0, 3);\n"
            + "        g1.addEdge(3, 4);\n"
            + "        g1.test();\n"
            + "        Graph g2 = new Graph(5);\n"
            + "        g2.addEdge(1, 0);\n"
            + "        g2.addEdge(0, 2);\n"
            + "        g2.addEdge(2, 1);\n"
            + "        g2.addEdge(0, 3);\n"
            + "        g2.addEdge(3, 4);\n"
            + "        g2.addEdge(4, 0);\n"
            + "        g2.test();\n"
            + "        Graph g3 = new Graph(5);\n"
            + "        g3.addEdge(1, 0);\n"
            + "        g3.addEdge(0, 2);\n"
            + "        g3.addEdge(2, 1);\n"
            + "        g3.addEdge(0, 3);\n"
            + "        g3.addEdge(3, 4);\n"
            + "        g3.addEdge(1, 3);\n"
            + "g3.test();\n"
            + "/* Crearemos un grafo con tres vertices\n"
            + "        conectados en forma de ciclo*/\n"
            + "Graph g4 = new Graph(3);\n"
            + "        g4.addEdge(0, 1);\n"
            + "        g4.addEdge(1, 2);\n"
            + "        g4.addEdge(2, 0);\n"
            + "        g4.test();\n"
            + "/* Creamos un grafo con vertices con grado cero*/\n"
            + "Graph g5 = new Graph(3);\n"
            + "        g5.test();\n"
            + "    }\n"
            + "\n"
            + "   static  class Graph {\n"
            + "        private int V; \n"
            + "        private LinkedList<Integer> adj[];\n"
            + "// Constructor \n"
            + "        Graph(int v) {\n"
            + "            V = v;\n"
            + "            adj = new LinkedList[v];\n"
            + "            for (int i = 0; i < v; ++i) {\n"
            + "                adj[i] = new LinkedList();\n"
            + "            }\n"
            + "        }\n"
            + "//Agregar caminos\n"
            + "        void addEdge(int v, int w) {\n"
            + "adj[v].add(w);\n"
            + "            adj[w].add(v); //El grafo es no dirigido\n"
            + "}\n"
            + "        void DFSUtil(int v, boolean visited[]) {\n"
            + "            visited[v] = true;\n"
            + "            Iterator<Integer> i = adj[v].listIterator();\n"
            + "            while (i.hasNext()) {\n"
            + "                int n = i.next();\n"
            + "                if (!visited[n]) {\n"
            + "                    DFSUtil(n, visited);\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "        boolean isConnected() {\n"
            + "            boolean visited[] = new boolean[V];\n"
            + "            int i;\n"
            + "            for (i = 0; i < V; i++) {\n"
            + "                visited[i] = false;\n"
            + "            }\n"
            + "            for (i = 0; i < V; i++) {\n"
            + "                if (!adj[i].isEmpty()) {\n"
            + "                    break;\n"
            + "}\n"
            + "            }\n"
            + "//Si no hay caminos en el grafo, retorna true\n"
            + "if (i == V) {\n"
            + "                return true;\n"
            + "            }\n"
            + "            DFSUtil(i, visited);\n"
            + "            for (i = 0; i < V; i++) {\n"
            + "                if (visited[i] == false && adj[i].size() > 0) {\n"
            + "                    return false;\n"
            + "                }\n"
            + "            }\n"
            + "            return true;\n"
            + "        }\n"
            + "\n"
            + "\n"
            + "        int isEulerian() {\n"
            + "            if (isConnected() == false) {\n"
            + "                return 0;\n"
            + "            }\n"
            + "            // Cuenta vertices con grado impar \n"
            + "            int odd = 0;\n"
            + "            for (int i = 0; i < V; i++) {\n"
            + "                if (adj[i].size() % 2 != 0) {\n"
            + "                    odd++;\n"
            + "}\n"
            + "            }\n"
            + "// Si cuenta es más de 2, el grafo no es euleriano\n"
            + "            if (odd > 2) {\n"
            + "                return 0;\n"
            + "            }\n"
            + "//si odd es 2, es semieuleriano\n"
            + "            //Si odd es 0, es eulerian0 \n"
            + "return (odd == 2) ? 1 : 2;\n"
            + "        }\n"
            + "\n"
            + "        void test() {\n"
            + "            int res = isEulerian();\n"
            + "            switch (res) {\n"
            + "                case 0:\n"
            + "                    System.out.println(\"Grafo no es euleriano\");\n"
            + "break;\n"
            + "                case 1:\n"
            + "                    System.out.println(\"Grafo tiene un camino de euler\");\n"
            + "                    break;\n"
            + "                default:\n"
            + "                    System.out.println(\"Grafo tiene ciclo de euler\");\n"
            + "                    break;\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "}";
    private String floydwarshall = "// Programa java que busca todos los caminos más cortos\n"
            + "// en un grafo\n"
            + "\n"
            + "import java.util.Scanner;\n"
            + "\n"
            + "public class FloydWarshal {\n"
            + "\n"
            + "    static int INF = 9999;\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        Scanner sc = new Scanner(System.in);\n"
            + "        int[][] graph;\n"
            + "        int N = sc.nextInt();\n"
            + "        graph = new int[N][N];\n"
            + "int E = sc.nextInt();\n"
            + "        //Inicializa todo en infinito\n"
            + "for (int i = 0; i < N; i++) {\n"
            + "            for (int j = 0; j < N; j++) {\n"
            + "graph[i][j] = INF;\n"
            + "            }\n"
            + "        }\n"
            + "// De un nodo al mismo nodo es 0\n"
            + "for (int i = 0; i < N; i++) {\n"
            + "            graph[i][i] = 0;\n"
            + "        }\n"
            + "        for (int i = 0; i < E; i++) {\n"
            + "            graph[sc.nextInt()][sc.nextInt()] = sc.nextInt();\n"
            + "        }\n"
            + "        AllPairShortestPath a = new AllPairShortestPath();\n"
            + "        a.floydWarshall(graph);\n"
            + "    }\n"
            + "\n"
            + "    static class AllPairShortestPath {\n"
            + "\n"
            + "        final static int INF = 9999, V = 4;\n"
            + "\n"
            + "        void floydWarshall(int graph[][]) {\n"
            + "            int dist[][] = new int[V][V];\n"
            + "int i, j, k;\n"
            + "/*Inicialice la matriz de solución igual que \n"
            + "            la matriz del gráfico de entrada. O podemos \n"
            + "            decir que los valores iniciales de las distancias \n"
            + "            más cortas se basan en las rutas más cortas, \n"
            + "            considerando que no hay vértice intermedio. */\n"
            + "            for (i = 0; i < V; i++) {\n"
            + "                for (j = 0; j < V; j++) {\n"
            + "                    dist[i][j] = graph[i][j];\n"
            + "}\n"
            + "            }\n"
            + "\n"
            + "/*Agregue todos los vértices uno por uno al conjunto \n"
            + "            de vértices intermedios.\n"
            + "            ---> Antes del inicio de una iteración, tenemos \n"
            + "            distancias más cortas entre todos los pares de vértices, \n"
            + "            de modo que las distancias más cortas consideran solo\n"
            + "            los vértices en el conjunto {0, 1, 2, .. k-1} como \n"
            + "            vértices intermedios.\n"
            + "            ----> Después del final de una iteración, el vértice \n"
            + "            número k se agrega al conjunto de vértices intermedios \n"
            + "            y el conjunto se convierte en {0, 1, 2, ... k} */\n"
            + "            for (k = 0; k < V; k++) {\n"
            + "//Toma todos los vertices como inicio uno por uno\n"
            + "                for (i = 0; i < V; i++) {\n"
            + "/* Toma todos los vertices como destino del\n"
            + "                    incio del origen seleccionado*/\n"
            + "                    for (j = 0; j < V; j++) {\n"
            + "// Si vertice k esa en el camino más corto\n"
            + "                        // desde i a j, actualiza el valor de dist[i][j]\n"
            + "if (dist[i][k] + dist[k][j] < dist[i][j]) {\n"
            + "                            dist[i][j] = dist[i][k] + dist[k][j];\n"
            + "}\n"
            + "                    }\n"
            + "                }\n"
            + "            }\n"
            + "//Imprime la matriz de distancias cortas\n"
            + "printSolution(dist);\n"
            + "        }\n"
            + "\n"
            + "        void printSolution(int dist[][]) {\n"
            + "System.out.println(\"La siguiente matriz muestra las distancias \"\n"
            + "                    + \"más cortas entre cada par de vertices\");\n"
            + "for (int i = 0; i < V; ++i) {\n"
            + "                for (int j = 0; j < V; ++j) {\n"
            + "                    if (dist[i][j] == FloydWarshal.INF) {\n"
            + "                        System.out.print(\"INF \");\n"
            + "                    } else {\n"
            + "                        System.out.print(dist[i][j] + \" \");\n"
            + "}\n"
            + "                }\n"
            + "                System.out.println();\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "}";
    private String hamiltonniancycle = "/* Programa java que soluciona el ciclo de Hamilton\n"
            + "usando backtracking*/\n"
            + "\n"
            + "public class HamiltonianCycle {\n"
            + "    static final int V = 5;\n"
            + "    static int path[];\n"
            + "\n"
            + "/* Una función de utilidad para comprobar si el vértice v puede ser\n"
            + "       añadido en el índice 'pos'en el ciclo hamiltoniano\n"
            + "       construido hasta ahora (almacenado en 'path[]')*/\n"
            + "static boolean isSafe(int v, int graph[][], int path[], int pos) {\n"
            + "/*Verifica si este vertice es adyacente del \n"
            + "anterior vertice */\n"
            + "        if (graph[path[pos - 1]][v] == 0) {\n"
            + "return false;\n"
            + "        }\n"
            + "        /* Verifica si el vertice ya esta incluido*/\n"
            + "for (int i = 0; i < pos; i++) {\n"
            + "            if (path[i] == v) {\n"
            + "                return false;\n"
            + "            }\n"
            + "        }\n"
            + "        return true;\n"
            + "    }\n"
            + "    static boolean hamCycleUtil(int graph[][], int path[], int pos) {\n"
            + "/* Caso base:Si todos los vertices estan incluidos en  \n"
            + "           el ciclo hamiltoniano*/\n"
            + "        if (pos == V) {\n"
            + "            // Y si hay un camino de el ultimo al primer vertice\n"
            + "return graph[path[pos - 1]][path[0]] == 1;\n"
            + "}\n"
            + "/*Prueba diferentes vértices como próximo candidato\n"
            + "        en el ciclo hamiltoniano. No intentamos con 0, \n"
            + "        ya que incluimos 0 como punto de partida en hamCycle ()*/\n"
            + "for (int v = 1; v < V; v++) {\n"
            + "/* Verifica si este vertice puede ser añadido al\n"
            + "ciclo hamiltoniano*/\n"
            + "            if (isSafe(v, graph, path, pos)) {\n"
            + "path[pos] = v;\n"
            + "/* Recorre hasta construir el camino*/\n"
            + "if (hamCycleUtil(graph, path, pos + 1) == true) {\n"
            + "return true;\n"
            + "                }\n"
            + "                path[pos] = -1;\n"
            + "            }\n"
            + "        }\n"
            + "/* Si no hay vertice para añadir al ciclo\n"
            + "        retorna falso*/\n"
            + "        return false;\n"
            + "    }\n"
            + "/* Esta función resuelve el problema del ciclo hamiltoniano usando\n"
            + "       backtracking. Utiliza principalmente hamCycleUtil () para resolver el\n"
            + "       problema. Devuelve falso si no hay ciclo hamiltoniano.\n"
            + "       posible, de lo contrario devuelve verdadero e imprime la ruta.\n"
            + "       Tenga en cuenta que puede haber más de una solución,\n"
            + "       Esta función imprime una de las soluciones factibles.*/\n"
            + "static int hamCycle(int graph[][]) {\n"
            + "        path = new int[V];\n"
            + "        for (int i = 0; i < V; i++) {\n"
            + "path[i] = -1;\n"
            + "        }\n"
            + "/* Pongamos el vértice 0 como el primer vértice en el camino.\n"
            + "           Si hay un ciclo hamiltoniano, entonces el camino puede ser\n"
            + "           Comenzó desde cualquier punto del ciclo ya que la gráfica es\n"
            + "           no dirigido*/\n"
            + "        path[0] = 0;\n"
            + "        if (hamCycleUtil(graph, path, 1) == false) {\n"
            + "System.out.println(\"\\nNo existe solución\");\n"
            + "return 0;\n"
            + "        }\n"
            + "        printSolution(path);\n"
            + "        return 1;\n"
            + "    }\n"
            + "\n"
            + "   // Imprimir solución\n"
            + "    static void printSolution(int path[]) {\n"
            + "System.out.println(\"Solución existe: Este\"\n"
            + "                + \" es uno de los ciclos hamiltoniano\");\n"
            + "for (int i = 0; i < V; i++) {\n"
            + "            System.out.print(\" \" + path[i] + \" \");\n"
            + "        }\n"
            + "        System.out.println(\" \" + path[0] + \" \");\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "\n"
            + "/*Tenemos el siguiente grafo \n"
            + "           (0)--(1)--(2) \n"
            + "            |   / \\   | \n"
            + "            |  /   \\  | \n"
            + "            | /     \\ | \n"
            + "           (3)-------(4)    */\n"
            + "        int graph1[][] = {{0, 1, 0, 1, 0},\n"
            + "        {1, 0, 1, 1, 1},\n"
            + "        {0, 1, 0, 0, 1},\n"
            + "        {1, 1, 0, 0, 1},\n"
            + "        {0, 1, 1, 1, 0},};\n"
            + "// Imprimir solución\n"
            + "        hamCycle(graph1);\n"
            + "\n"
            + "/*Tenemos el siguiente grafo \n"
            + "           (0)--(1)--(2) \n"
            + "            |   / \\   | \n"
            + "            |  /   \\  | \n"
            + "            | /     \\ | \n"
            + "           (3)       (4)    */\n"
            + "        int graph2[][] = {{0, 1, 0, 1, 0},\n"
            + "        {1, 0, 1, 1, 1},\n"
            + "        {0, 1, 0, 0, 1},\n"
            + "        {1, 1, 0, 0, 0},\n"
            + "        {0, 1, 1, 0, 0},};\n"
            + "// Imprimir solución\n"
            + "        hamCycle(graph2);\n"
            + "    }\n"
            + "}";
    private String kahnalgorithmtopologicalsorting = "// Programa java que imprime el ordenamiento topologico\n"
            + "// de un grafo  \n"
            + "import java.util.*;\n"
            + "\n"
            + "public class KahnAlgorithmTopologicalSorting {\n"
            + "\n"
            + "    public static void main(String args[]) { \n"
            + "        Graph g = new Graph(6);\n"
            + "        g.addEdge(5, 2);\n"
            + "        g.addEdge(5, 0);\n"
            + "        g.addEdge(4, 0);\n"
            + "        g.addEdge(4, 1);\n"
            + "        g.addEdge(2, 3);\n"
            + "        g.addEdge(3, 1);\n"
            + "        System.out.println(\"Siguiendo su ordenamiento topologico \");\n"
            + "        g.topologicalSort();\n"
            + "    }\n"
            + "\n"
            + "    static class Graph {\n"
            + "        int V;\n"
            + "        List<Integer> adj[];\n"
            + "        public Graph(int V)// Constructor \n"
            + "        {\n"
            + "            this.V = V;\n"
            + "            adj = new ArrayList[V];\n"
            + "            for (int i = 0; i < V; i++) {\n"
            + "                adj[i] = new ArrayList<>();\n"
            + "            }\n"
            + "        }\n"
            + "// Agregar caminos\n"
            + "        public void addEdge(int u, int v) {\n"
            + "            adj[u].add(v);\n"
            + "        } \n"
            + "\n"
            + "        public void topologicalSort() {\n"
            + "// Crea un array para almaccenar los indegrees\n"
            + "            // de todos los vertices e inicializa en 0\n"
            + "int indegree[] = new int[V];\n"
            + "// Atraviesa las listas de adyacencia para llenar\n"
            + "// grados de los vertices       \n"
            + "            for (int i = 0; i < V; i++) {\n"
            + "                ArrayList<Integer> temp = (ArrayList<Integer>) adj[i];\n"
            + "                temp.forEach((node) -> {\n"
            + "                    indegree[node]++;\n"
            + "});\n"
            + "            }\n"
            + "/* Crea una cola y encola todos los vertices\n"
            + "con grado 0*/\n"
            + "            Queue<Integer> q = new LinkedList<>();\n"
            + "            for (int i = 0; i < V; i++) {\n"
            + "                if (indegree[i] == 0) {\n"
            + "                    q.add(i);\n"
            + "}\n"
            + "            }\n"
            + "// Inicializa el conteo de vertices visitados\n"
            + "            int cnt = 0;\n"
            + "// Crea un vector que almacena el resultado\n"
            + "ArrayList<Integer> topOrder = new ArrayList<Integer>();\n"
            + "            while (!q.isEmpty()) {\n"
            + "                int u = q.poll();\n"
            + "                topOrder.add(u);\n"
            + "                adj[u].stream().filter((node) -> (--indegree[node] == 0)).forEachOrdered((node) -> {\n"
            + "q.add(node);\n"
            + "                }); \n"
            + "                cnt++;\n"
            + "            }\n"
            + "// Verifica si hay ciclo       \n"
            + "if (cnt != V) {\n"
            + "                System.out.println(\"There exists a cycle in the graph\");\n"
            + "                return;\n"
            + "            }\n"
            + "//Imprime el ordenamiento topologico             \n"
            + "            for (int i : topOrder) {\n"
            + "                System.out.print(i + \" \");\n"
            + "}\n"
            + "        }\n"
            + "    }\n"
            + "}";
    private String knighttourbacktracking = "Programa java para el problema del tour del caballo\n"
            + "public class KnightTourBacktracking {\n"
            + "    static int N = 8;\n"
            + "/* Una función que verifica si i.j es\n"
            + "    indice valido para un tablero n*n*/\n"
            + "static boolean isSafe(int x, int y, int sol[][]) {\n"
            + "        return (x >= 0 && x < N && y >= 0\n"
            + "&& y < N && sol[x][y] == -1);\n"
            + "    }\n"
            + "/* Imprimir la solución*/\n"
            + "static void printSolution(int sol[][]) {\n"
            + "        for (int x = 0; x < N; x++) {\n"
            + "for (int y = 0; y < N; y++) {\n"
            + "System.out.print(sol[x][y] + \"\\t\");\n"
            + "}\n"
            + "            System.out.println();\n"
            + "        }\n"
            + "    }\n"
            + "/*Esta función resuelve el problema de Knight Tour.\n"
            + "       utilizando Backtracking. Esta función principalmente\n"
            + "       utiliza solveKTUtil () para resolver el problema. Eso\n"
            + "       devuelve falso si no es posible realizar un recorrido completo,\n"
            + "       De lo contrario, devuelve true e imprime el recorrido.\n"
            + "       Tenga en cuenta que puede haber más de una\n"
            + "       soluciones, esta función imprime una de las\n"
            + "       soluciones viables.*/\n"
            + "    static boolean solveKT() {\n"
            + "        int sol[][] = new int[8][8];\n"
            + "/* Inicializando la matriz de solución*/\n"
            + "for (int x = 0; x < N; x++) {\n"
            + "for (int y = 0; y < N; y++) {\n"
            + "                sol[x][y] = -1;\n"
            + "            }\n"
            + "        }\n"
            + "        /* xMove[] y yMove[] define el siguiente movimiento del caballo \n"
            + "          xMove[] para siguiente valor en x\n"
            + "          yMove[] para siguiente valor en y */\n"
            + "        int xMove[] = {2, 1, -1, -2, -2, -1, 1, 2};\n"
            + "        int yMove[] = {1, 2, 2, 1, -1, -2, -2, -1};\n"
            + "        //Desde que el caballero inicie en el primer bloque\n"
            + "sol[0][0] = 0;\n"
            + "        if (!solveKTUtil(0, 0, 1, sol, xMove, yMove)) {\n"
            + "System.out.println(\"No existe la solución\");\n"
            + "return false;\n"
            + "        } else {\n"
            + "            printSolution(sol);\n"
            + "        }\n"
            + "        return true;\n"
            + "    }\n"
            + "    static boolean solveKTUtil(int x, int y, int movei,\n"
            + "            int sol[][], int xMove[],\n"
            + "            int yMove[]) {\n"
            + "        int k, next_x, next_y;\n"
            + "        if (movei == N * N) {\n"
            + "            return true;\n"
            + "}\n"
            + "/* Intenta todos los movimientos desde la coordenada\n"
            + "x y y*/\n"
            + "        for (k = 0; k < 8; k++) {\n"
            + "            next_x = x + xMove[k];\n"
            + "            next_y = y + yMove[k];\n"
            + "            if (isSafe(next_x, next_y, sol)) {\n"
            + "                sol[next_x][next_y] = movei;\n"
            + "                if (solveKTUtil(next_x, next_y, movei + 1,\n"
            + "                        sol, xMove, yMove)) {\n"
            + "                    return true;\n"
            + "                } else {\n"
            + "                    sol[next_x][next_y] = -1;// backtracking \n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "        return false;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "solveKT();\n"
            + "    }\n"
            + "}";
    private String kosarajudfsstronglyconnected = "// Programa java que verifica si un grafo es \n"
            + "// fuertemente conectado\n"
            + "import java.util.*;\n"
            + "import java.util.LinkedList;\n"
            + "\n"
            + "public class KosarajuDFSStronglyConnected {\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        Graph g1 = new Graph(5);\n"
            + "        g1.addEdge(0, 1);\n"
            + "        g1.addEdge(1, 2);\n"
            + "        g1.addEdge(2, 3);\n"
            + "        g1.addEdge(3, 0);\n"
            + "        g1.addEdge(2, 4);\n"
            + "        g1.addEdge(4, 2);\n"
            + "        if (g1.isSC()) {\n"
            + "            System.out.println(\"Si\");\n"
            + "        } else {\n"
            + "            System.out.println(\"No\");\n"
            + "        }\n"
            + "        Graph g2 = new Graph(4);\n"
            + "        g2.addEdge(0, 1);\n"
            + "        g2.addEdge(1, 2);\n"
            + "        g2.addEdge(2, 3);\n"
            + "        if (g2.isSC()) {\n"
            + "            System.out.println(\"Si\");\n"
            + "        } else {\n"
            + "            System.out.println(\"No\");\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static class Graph {\n"
            + "        private int V;   \n"
            + "        private LinkedList<Integer> adj[];  \n"
            + "        Graph(int v) {\n"
            + "            V = v;\n"
            + "            adj = new LinkedList[v];\n"
            + "            for (int i = 0; i < v; ++i) {\n"
            + "                adj[i] = new LinkedList();\n"
            + "            }\n"
            + "        }\n"
            + "        void addEdge(int v, int w) {\n"
            + "            adj[v].add(w);\n"
            + "        }\n"
            + "        void DFSUtil(int v, Boolean visited[]) {\n"
            + "            visited[v] = true;\n"
            + "            int n;\n"
            + "            Iterator<Integer> i = adj[v].iterator();\n"
            + "            while (i.hasNext()) {\n"
            + "                n = i.next();\n"
            + "                if (!visited[n]) {\n"
            + "                    DFSUtil(n, visited);\n"
            + "}\n"
            + "            }\n"
            + "        }\n"
            + "        // Obtiene el transpuesto de un grafo\n"
            + "Graph getTranspose() {\n"
            + "            Graph g = new Graph(V);\n"
            + "            for (int v = 0; v < V; v++) {\n"
            + "                Iterator<Integer> i = adj[v].listIterator();\n"
            + "                while (i.hasNext()) {\n"
            + "                    g.adj[i.next()].add(v);\n"
            + "}\n"
            + "            }\n"
            + "            return g;\n"
            + "        }\n"
            + "//Verifica si el grafo esta fuertemente conectado\n"
            + "        Boolean isSC() {\n"
            + "/*Paso 1: marcar todos los vertices como no visitados\n"
            + "(primer DFS)*/\n"
            + "            Boolean visited[] = new Boolean[V];\n"
            + "            for (int i = 0; i < V; i++) {\n"
            + "visited[i] = false;\n"
            + "            }\n"
            + "//Paso 2: DFS transverso desde el primer vertice\n"
            + "            DFSUtil(0, visited);\n"
            + "// si no visita todos, retorna falso\n"
            + "for (int i = 0; i < V; i++) {\n"
            + "                if (visited[i] == false) {\n"
            + "                    return false;\n"
            + "}\n"
            + "            }\n"
            + "            // Paso 3: crear grafo transpuesto\n"
            + "            Graph gr = getTranspose();\n"
            + "// Paso 4: marcar todos los vertices como no visitados\n"
            + "// (Segundo DFS)\n"
            + "            for (int i = 0; i < V; i++) {\n"
            + "visited[i] = false;\n"
            + "            }\n"
            + "            /* Paso 5: hacer DFS en el grafo reversado*/\n"
            + "            gr.DFSUtil(0, visited);\n"
            + "/* Si todos los vertices no son visitados, retorne falso*/\n"
            + "for (int i = 0; i < V; i++) {\n"
            + "                if (visited[i] == false) {\n"
            + "                    return false;\n"
            + "}\n"
            + "            }\n"
            + "            return true;\n"
            + "        }\n"
            + "    }\n"
            + "}";
    private String kruskalmst = "//Implementación java de busqueda del \n"
            + "// arbol de expansión minima usando el algoritmo de Kruskal\n"
            + "/*\n"
            + " EJEMPLO DE INPUT\n"
            + " 9 14\n"
            + " 1 2 4\n"
            + " 1 8 9\n"
            + " 2 3 9\n"
            + " 2 8 11\n"
            + " 3 4 7\n"
            + " 3 9 2\n"
            + " 3 6 4\n"
            + " 4 5 10\n"
            + " 4 6 15\n"
            + " 5 6 11\n"
            + " 6 7 2\n"
            + " 7 8 1\n"
            + " 7 9 6\n"
            + " 8 9 7\n"
            + "\n"
            + " EJEMPLO VERIFICACION DE MST\n"
            + "9 11\n"
            + " 1 2 4\n"
            + " 1 8 9\n"
            + " 2 3 9\n"
            + " 2 8 11\n"
            + " 3 9 2\n"
            + " 7 8 1\n"
            + " 7 9 6\n"
            + " 8 9 7\n"
            + " 4 5 10\n"
            + " 4 6 15\n"
            + " 5 6 11\n"
            + " */\n"
            + "import java.util.Arrays;\n"
            + "import java.util.Comparator;\n"
            + "import java.util.Scanner;\n"
            + "\n"
            + "public class KruskalMST {\n"
            + "\n"
            + "static final int MAX = 1005; //maximo número de vértices\n"
            + "\n"
            + "    ///UNION-FIND\n"
            + "    static int padre[] = new int[MAX]; //Este arreglo contiene el padre del i-esimo nodo\n"
            + "\n"
            + "//Método de inicialización\n"
            + "static void MakeSet(int n) {\n"
            + "        for (int i = 1; i <= n; ++i) {\n"
            + "padre[i] = i;\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "//Método para encontrar la raiz del vértice actual X\n"
            + "static int Find(int x) {\n"
            + "return (x == padre[x]) ? x : (padre[x] = Find(padre[x]));\n"
            + "    }\n"
            + "\n"
            + "//Método para unir 2 componentes conexas\n"
            + "static void Union(int x, int y) {\n"
            + "        padre[Find(x)] = Find(y);\n"
            + "}\n"
            + "\n"
            + "//Método que me determina si 2 vértices estan o no en la misma componente conexa\n"
            + "static boolean sameComponent(int x, int y) {\n"
            + "        if (Find(x) == Find(y)) {\n"
            + "            return true;\n"
            + "        }\n"
            + "        return false;\n"
            + "    }\n"
            + "    ///FIN UNION-FIND\n"
            + "\n"
            + "static int V, E; //número de vertices y aristas\n"
            + "//Estructura arista( edge )\n"
            + "\n"
            + "    static class Edge implements Comparator<Edge> {\n"
            + "\n"
            + "int origen; //Vértice origen\n"
            + "        int destino; //Vértice destino\n"
            + "        int peso; //Peso entre el vértice origen y destino\n"
            + "\n"
            + "        Edge() {\n"
            + "        }\n"
            + "//Comparador por peso, me servira al momento de ordenar lo realizara en orden ascendente\n"
            + "        //Ordenar de forma descendente para obtener el arbol de expansion maxima\n"
            + "\n"
            + "@Override\n"
            + "        public int compare(Edge e1, Edge e2) {\n"
            + "//return e2.peso - e1.peso; //Arbol de expansion maxima\n"
            + "            return e1.peso - e2.peso; //Arbol de expansion minima\n"
            + "        }\n"
            + "    };\n"
            + "\n"
            + "    static Edge arista[] = new Edge[MAX]; //Arreglo de aristas para el uso en kruskal\n"
            + "static Edge MST[] = new Edge[MAX]; //Arreglo de aristas del MST encontrado\n"
            + "\n"
            + "    static void KruskalMST() {\n"
            + "int origen, destino, peso;\n"
            + "        int total = 0; //Peso total del MST\n"
            + "        int numAristas = 0; //Número de Aristas del MST\n"
            + "\n"
            + "        MakeSet(V); //Inicializamos cada componente\n"
            + "        Arrays.sort(arista, 0, E, new Edge()); //Ordenamos las aristas por su comparador\n"
            + "for (int i = 0; i < E; ++i) {\n"
            + "origen = arista[i].origen; //Vértice origen de la arista actual\n"
            + "            destino = arista[i].destino; //Vértice destino de la arista actual\n"
            + "            peso = arista[i].peso; //Peso de la arista actual\n"
            + "\n"
            + "//Verificamos si estan o no en la misma componente conexa\n"
            + "            if (!sameComponent(origen, destino)) { //Evito ciclos\n"
            + "                total += peso; //Incremento el peso total del MST\n"
            + "                MST[numAristas++] = arista[i]; //Agrego al MST la arista actual\n"
            + "                Union(origen, destino); //Union de ambas componentes en una sola\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "//Si el MST encontrado no posee todos los vértices mostramos mensaje de error\n"
            + "        //Para saber si contiene o no todos los vértices basta con que el número\n"
            + "        //de aristas sea igual al número de vertices - 1\n"
            + "        if (V - 1 != numAristas) {\n"
            + "            System.out.println(\"No existe MST valido para el grafo ingresado, el grafo debe ser conexo.\");\n"
            + "            return;\n"
            + "        }\n"
            + "        System.out.println(\"-----El MST encontrado contiene las siguientes aristas-----\");\n"
            + "for (int i = 0; i < numAristas; ++i) {\n"
            + "            System.out.printf(\"( %d , %d ) : %d\\n\", MST[i].origen, MST[i].destino, MST[i].peso);\n"
            + "}\n"
            + "        System.out.printf(\"El costo minimo de todas las aristas del MST es : %d\\n\", total);\n"
            + "}\n"
            + "\n"
            + "//( vertice u , vertice v ) : peso\n"
            + "    public static void main(String[] args) {\n"
            + "Scanner sc = new Scanner(System.in); //para lectura de datos\n"
            + "        V = sc.nextInt();\n"
            + "        E = sc.nextInt();\n"
            + "\n"
            + "//Realizamos el ingreso del grafo, almacenando las aristas en un arreglo con los datos respectivos\n"
            + "for (int i = 0; i < E; ++i) {\n"
            + "            arista[i] = new Edge();\n"
            + "            arista[i].origen = sc.nextInt();\n"
            + "arista[i].destino = sc.nextInt();\n"
            + "            arista[i].peso = sc.nextInt();\n"
            + "//arista[ i ] = new Arista( sc.nextInt() , );\n"
            + "}\n"
            + "        KruskalMST();\n"
            + "    }\n"
            + "}";
    private String minimummovesknight = "//Programa java que encuentra la minima cantidad de pasos\n"
            + "// para alcanzar una celda especifica con un caballo\n"
            + "import java.util.Vector;\n"
            + "\n"
            + "public class MinimumMovesKnight {\n"
            + "/*Clase que almacena los datos de una celda*/\n"
            + "static class cell {\n"
            + "        int x, y;\n"
            + "        int dis;\n"
            + "        public cell(int x, int y, int dis) {\n"
            + "            this.x = x;\n"
            + "            this.y = y;\n"
            + "this.dis = dis;\n"
            + "        }\n"
            + "    }\n"
            + "/* Utilidad que retorna s (x,y) yace dentro del tablero*/\n"
            + "static boolean isInside(int x, int y, int N) {\n"
            + "return x >= 1 && x <= N && y >= 1 && y <= N;\n"
            + "    }\n"
            + "/* Retorna los minimos pasos para llegar al objetivo*/ \n"
            + "static int minStepToReachTarget(int knightPos[], int targetPos[],\n"
            + "int N) {\n"
            + "// dirección x y y, donde el caballo puede llegar \n"
            + "        int dx[] = {-2, -1, 1, 2, -2, -1, 1, 2};\n"
            + "        int dy[] = {-1, -2, -2, -1, 1, 2, 2, 1};\n"
            + "// Vector para almacenar los estados del caballo\n"
            + "Vector<cell> q = new Vector<>();\n"
            + "// Agrega la posicion inicial con distancia 0\n"
            + "q.add(new cell(knightPos[0], knightPos[1], 0));\n"
            + "        cell t;\n"
            + "        int x, y;\n"
            + "        boolean visit[][] = new boolean[N + 1][N + 1];\n"
            + "//Hacer todas las celdas sin visitar\n"
            + "for (int i = 1; i <= N; i++) {\n"
            + "            for (int j = 1; j <= N; j++) {\n"
            + "visit[i][j] = false;\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        // visitar estado inicial\n"
            + "        visit[knightPos[0]][knightPos[1]] = true;\n"
            + "// ciclo hasta que quede solo un valor \n"
            + "while (!q.isEmpty()) {\n"
            + "            t = q.firstElement();\n"
            + "q.remove(0);\n"
            + "            /* Si la celda actual es igual al objetivo\n"
            + "            retorne su distancia*/\n"
            + "            if (t.x == targetPos[0] && t.y == targetPos[1]) {\n"
            + "                return t.dis;\n"
            + "            }\n"
            + "// Ciclo de todos los estados alcancables\n"
            + "for (int i = 0; i < 8; i++) {\n"
            + "                x = t.x + dx[i];\n"
            + "                y = t.y + dy[i]; \n"
            + "                if (isInside(x, y, N) && !visit[x][y]) {\n"
            + "                    visit[x][y] = true;\n"
            + "                    q.add(new cell(x, y, t.dis + 1));\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "        return Integer.MAX_VALUE;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int N = 30;\n"
            + "        int knightPos[] = {1, 1};\n"
            + "        int targetPos[] = {30, 30};\n"
            + "        System.out.println(minStepToReachTarget(knightPos, targetPos, N));\n"
            + "}\n"
            + "}";
    private String nqueenproblem = "/* Programa JAVA que resuelve el problema de las N reinas\n"
            + "usando backtracking*/\n"
            + "public class NQueenProblem {\n"
            + "    final int N = 4;\n"
            + "/* A utility function to print solution */\n"
            + "    void printSolution(int board[][]) {\n"
            + "        for (int i = 0; i < N; i++) {\n"
            + "            for (int j = 0; j < N; j++) {\n"
            + "                System.out.print(\" \" + board[i][j]\n"
            + "+ \" \");\n"
            + "            }\n"
            + "            System.out.println();\n"
            + "        }\n"
            + "    }/*Una función de utilidad para comprobar si una reina puede\n"
            + "       colocarse en board[row][col]. Tenga en cuenta que \n"
            + "       La función se llama cuando \"col\" reinas ya están\n"
            + "       Colocadas en columnas de 0 a col -1. Así que necesitamos\n"
            + "       para comprobar sólo el lado izquierdo para las reinas atacantes*/\n"
            + "boolean isSafe(int board[][], int row, int col) {\n"
            + "int i, j;\n"
            + "/*Verifica esta fila en el lado izquierdo*/\n"
            + "for (i = 0; i < col; i++) {\n"
            + "            if (board[row][i] == 1) {\n"
            + "return false;\n"
            + "            }\n"
            + "        }\n"
            + "/*Verifica la diagonal superior de la izquierda*/\n"
            + "for (i = row, j = col; i >= 0 && j >= 0; i--, j--) {\n"
            + "            if (board[i][j] == 1) {\n"
            + "                return false;\n"
            + "}\n"
            + "        }\n"
            + "        /*Diagonal baja desde la izquierda*/\n"
            + "for (i = row, j = col; j >= 0 && i < N; i++, j--) {\n"
            + "            if (board[i][j] == 1) {\n"
            + "                return false;\n"
            + "            }\n"
            + "        }\n"
            + "        return true;\n"
            + "    }\n"
            + "    boolean solveNQUtil(int board[][], int col) {\n"
            + "/* Caso base: Si todas las reinas estan\n"
            + "puestas, retorne true*/\n"
            + "        if (col >= N) {\n"
            + "return true;\n"
            + "        }\n"
            + "/*Considere esta columna e intente colocando esta \n"
            + "        reina en todas las filas una por una*/\n"
            + "for (int i = 0; i < N; i++) {\n"
            + "/* Verifica si la reina puede ser puesta\n"
            + "en board[i][col] */\n"
            + "            if (isSafe(board, i, col)) {\n"
            + "board[i][col] = 1;\n"
            + "/*Recursivamente pone todas las reinas*/\n"
            + "if (solveNQUtil(board, col + 1) == true) {\n"
            + "                    return true;\n"
            + "                }\n"
            + "                board[i][col] = 0; // BACKTRACK \n"
            + "}\n"
            + "        }\n"
            + "/*Si la reina no puede ser puesta en \n"
            + "        ninguna fila en esta columna,r retorna falso*/\n"
            + "        return false;\n"
            + "    }\n"
            + "/*Esta función resuelve el problema de N Queen usando\n"
            + "    Backtracking. Utiliza principalmente solveNQUtil() \n"
            + "    para resolver el problema. Devuelve false si no se \n"
            + "    pueden colocar las reinas; de lo contrario, devuelve \n"
            + "    true e imprime la ubicación de las reinas en forma de \n"
            + "    1s. Tenga en cuenta que puede haber más de una solución,\n"
            + "    esta función imprime una de las soluciones posibles.*/\n"
            + "boolean solveNQ() {\n"
            + "        int board[][] = {{0, 0, 0, 0},\n"
            + "        {0, 0, 0, 0},\n"
            + "        {0, 0, 0, 0},\n"
            + "        {0, 0, 0, 0}\n"
            + "        };\n"
            + "        if (solveNQUtil(board, 0) == false) {\n"
            + "System.out.print(\"Solución no existe\");\n"
            + "return false;\n"
            + "        }\n"
            + "        printSolution(board);\n"
            + "        return true;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        NQueenProblem Queen = new NQueenProblem();\n"
            + "        Queen.solveNQ();\n"
            + "}\n"
            + "}";
    private String primmstfull = "//Programa java que calcula el MST de un grafo\n"
            + "import java.util.LinkedList;\n"
            + "import java.util.PriorityQueue;\n"
            + "import java.util.Comparator;\n"
            + "\n"
            + "public class PrimMSTFULL {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int V = 9;\n"
            + "        Graph graph = new Graph(V);\n"
            + "        addEdge(graph, 0, 1, 4);\n"
            + "        addEdge(graph, 0, 7, 8);\n"
            + "        addEdge(graph, 1, 2, 8);\n"
            + "        addEdge(graph, 1, 7, 11);\n"
            + "        addEdge(graph, 2, 3, 7);\n"
            + "        addEdge(graph, 2, 8, 2);\n"
            + "        addEdge(graph, 2, 5, 4);\n"
            + "        addEdge(graph, 3, 4, 9);\n"
            + "        addEdge(graph, 3, 5, 14);\n"
            + "        addEdge(graph, 4, 5, 10);\n"
            + "        addEdge(graph, 5, 6, 2);\n"
            + "        addEdge(graph, 6, 7, 1);\n"
            + "        addEdge(graph, 6, 8, 6);\n"
            + "        addEdge(graph, 7, 8, 7);\n"
            + "        prims_mst(graph);\n"
            + "    }\n"
            + "\n"
            + "    static class node1 {\n"
            + "        int dest;     \n"
            + "        int weight;\n"
            + "        node1(int a, int b) {\n"
            + "            dest = a;\n"
            + "            weight = b;\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static class Graph {\n"
            + "        int V;\n"
            + "        LinkedList<node1>[] adj;\n"
            + "Graph(int e) {\n"
            + "            V = e;\n"
            + "adj = new LinkedList[V];\n"
            + "            for (int o = 0; o < V; o++) {\n"
            + "                adj[o] = new LinkedList<>();\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static class node {\n"
            + "int vertex;\n"
            + "        int key;\n"
            + "    }\n"
            + "/* Comparador de la priorityQueue\n"
            + "     retorna 1 si node0.key > node1.key \n"
            + "     retorna 0 si node0.key < node1.key y\n"
            + "retorna -1 otherwise */\n"
            + "    static class comparator implements Comparator<node> {\n"
            + "        @Override\n"
            + "        public int compare(node node0, node node1) {\n"
            + "            return node0.key - node1.key;\n"
            + "        }\n"
            + "    }\n"
            + "    static void addEdge(Graph graph, int src, int dest, int weight) {\n"
            + "        node1 node0 = new node1(dest, weight);\n"
            + "        node1 node = new node1(src, weight);\n"
            + "        graph.adj[src].addLast(node0);\n"
            + "        graph.adj[dest].addLast(node);\n"
            + "    }\n"
            + "\n"
            + "// Buscar MST\n"
            + "    static void prims_mst(Graph graph) {\n"
            + "        Boolean[] mstset = new Boolean[graph.V];\n"
            + "        node[] e = new node[graph.V];\n"
            + "        int[] parent = new int[graph.V];\n"
            + "for (int o = 0; o < graph.V; o++) {\n"
            + "            e[o] = new node();\n"
            + "        }\n"
            + "        for (int o = 0; o < graph.V; o++) {\n"
            + "//inicializar en falso\n"
            + "            mstset[o] = false;\n"
            + "// Inicial valores key en infinito\n"
            + "            e[o].key = Integer.MAX_VALUE;\n"
            + "            e[o].vertex = o;\n"
            + "            parent[o] = -1;\n"
            + "        }\n"
            + "\n"
            + "// incluir el vertice inicial en el MST\n"
            + "mstset[0] = true;\n"
            + "        e[0].key = 0;\n"
            + "        PriorityQueue<node> queue = new PriorityQueue<>\n"
            + "        (graph.V, new comparator());\n"
            + "        for (int o = 0; o < graph.V; o++) {\n"
            + "queue.add(e[o]);\n"
            + "        } \n"
            + "        while (!queue.isEmpty()) {\n"
            + "node node0 = queue.poll();\n"
            + "            mstset[node0.vertex] = true;\n"
            + "            for (node1 iterator : graph.adj[node0.vertex]) {\n"
            + "                if (mstset[iterator.dest] == false) {\n"
            + "                    if (e[iterator.dest].key > iterator.weight) {\n"
            + "queue.remove(e[iterator.dest]);\n"
            + "e[iterator.dest].key = iterator.weight;\n"
            + "queue.add(e[iterator.dest]);\n"
            + "parent[iterator.dest] = node0.vertex;\n"
            + "}\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "// Imprimir el par de vertices del mst \n"
            + "        for (int o = 1; o < graph.V; o++) {\n"
            + "System.out.println(parent[o] + \" \"\n"
            + "+ \"-\"\n"
            + "                    + \" \" + o);\n"
            + "        }\n"
            + "    }\n"
            + "}\n"
            + "//Porgrama java que busca el arbol de expansión \n"
            + "// minima de minimo costo\n"
            + "import java.util.ArrayList;\n"
            + "import java.util.List;\n"
            + "import java.util.PriorityQueue;\n"
            + "import java.util.Scanner;\n"
            + "\n"
            + "public class PrimMSTMinValue {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        Scanner sc = new Scanner(System.in);\n"
            + "        N = sc.nextInt();\n"
            + "        G = new Vertex[N];\n"
            + "        for (int i = 0; i < G.length; i++) {\n"
            + "            G[i] = new Vertex();\n"
            + "        }\n"
            + "        E = sc.nextInt();\n"
            + "        for (int i = 0; i < E; i++) {\n"
            + "            int from, to, w;\n"
            + "            from = sc.nextInt();\n"
            + "            to = sc.nextInt();\n"
            + "            w = sc.nextInt();\n"
            + "            G[from].adj.add(new Edge(to, w));\n"
            + "            G[to].adj.add(new Edge(from, w));\n"
            + "        }\n"
            + "        System.out.println(prim());\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    static PriorityQueue<QueueItem> Q;\n"
            + "    static int E;\n"
            + "    static boolean[] intree;\n"
            + "    static int N;\n"
            + "    static Vertex[] G;\n"
            + "\n"
            + "    static class QueueItem implements Comparable<QueueItem> {\n"
            + "\n"
            + "        int v, w;\n"
            + "\n"
            + "        public QueueItem(int v, int w) {\n"
            + "            this.v = v;\n"
            + "            this.w = w;\n"
            + "        }\n"
            + "\n"
            + "        @Override\n"
            + "        public int compareTo(QueueItem q) {\n"
            + "            if (this.w != q.w) {\n"
            + "                return this.w - q.w;\n"
            + "            }\n"
            + "            return this.v - q.v;\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static void process(int u) {\n"
            + "intree[u] = true;\n"
            + "        G[u].adj.forEach((e) -> {\n"
            + "int v = e.to, w = e.w;\n"
            + "            if (!intree[v]) {\n"
            + "                Q.offer(new QueueItem(v, w));\n"
            + "            }\n"
            + "        });\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    static int prim() {\n"
            + "        intree = new boolean[N];\n"
            + "        Q = new PriorityQueue<>();\n"
            + "        int cost = 0;\n"
            + "        process(0);\n"
            + "        while (!Q.isEmpty()) {\n"
            + "            QueueItem qi = Q.poll();\n"
            + "            int v = qi.v, w = qi.w;\n"
            + "            if (!intree[v]) {\n"
            + "                cost += w;\n"
            + "                process(v);\n"
            + "\n"
            + "            }\n"
            + "        }\n"
            + "        return cost;\n"
            + "    }\n"
            + "\n"
            + "    static class Vertex {\n"
            + "\n"
            + "        List<Edge> adj;\n"
            + "\n"
            + "        public Vertex() {\n"
            + "            adj = new ArrayList<>();\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    static class Edge {\n"
            + "\n"
            + "        int to, w;\n"
            + "\n"
            + "        public Edge(int to, int w) {\n"
            + "            this.to = to;\n"
            + "            this.w = w;\n"
            + "}\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "}";
    private String topologicalsorting = "// Programa java que imprime el ordenamiendo topologico\n"
            + "// de un grafo dirigido\n"
            + "import java.util.*;\n"
            + "\n"
            + "public class TopologicalSorting {\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "// Create a graph given in the above diagram \n"
            + "        Graph g = new Graph(6);\n"
            + "        g.addEdge(5, 2);\n"
            + "        g.addEdge(5, 0);\n"
            + "        g.addEdge(4, 0);\n"
            + "        g.addEdge(4, 1);\n"
            + "g.addEdge(2, 3);\n"
            + "        g.addEdge(3, 1);\n"
            + "        System.out.println(\"Siguiendo el ordenamiento topologico \"\n"
            + "                + \"del grafo dado \");\n"
            + "g.topologicalSort();\n"
            + "    }\n"
            + "\n"
            + "   static class Graph {\n"
            + "        private int V;  \n"
            + "        private LinkedList<Integer> adj[];\n"
            + "        Graph(int v) {\n"
            + "            V = v;\n"
            + "            adj = new LinkedList[v];\n"
            + "            for (int i = 0; i < v; ++i) {\n"
            + "                adj[i] = new LinkedList();\n"
            + "            }\n"
            + "        }\n"
            + "        void addEdge(int v, int w) {\n"
            + "            adj[v].add(w);\n"
            + "        }\n"
            + "        void topologicalSortUtil(int v, boolean visited[],\n"
            + "                Stack stack) {\n"
            + "            visited[v] = true;\n"
            + "            Integer i;\n"
            + "            Iterator<Integer> it = adj[v].iterator();\n"
            + "            while (it.hasNext()) {\n"
            + "                i = it.next();\n"
            + "                if (!visited[i]) {\n"
            + "                    topologicalSortUtil(i, visited, stack);\n"
            + "                }\n"
            + "            }\n"
            + "            stack.push(new Integer(v));\n"
            + "        }\n"
            + "        void topologicalSort() {\n"
            + "            Stack stack = new Stack();\n"
            + "            boolean visited[] = new boolean[V];\n"
            + "            for (int i = 0; i < V; i++) {\n"
            + "                visited[i] = false;\n"
            + "            }\n"
            + "            for (int i = 0; i < V; i++) {\n"
            + "                if (visited[i] == false) {\n"
            + "                    topologicalSortUtil(i, visited, stack);\n"
            + "}\n"
            + "            }\n"
            + "// Imprime el contenido de la pila\n"
            + "while (stack.empty() == false) {\n"
            + "                System.out.print(stack.pop() + \" \");\n"
            + "}\n"
            + "        }\n"
            + "    }\n"
            + "}";
    private String unionfind = "//Programa java que usa el algoritmo UNION FIND \n"
            + "// para verificar componentes conexas\n"
            + "/*\n"
            + " INPUT\n"
            + " 9 7\n"
            + "2 0\n"
            + " 7 0\n"
            + " 3 1\n"
            + " 1 0\n"
            + " 6 4\n"
            + " 8 5\n"
            + " 4 5\n"
            + " */\n"
            + "import java.util.*;\n"
            + "\n"
            + "public class UnionFind {\n"
            + "\n"
            + "static final int MAX = 10005; //maximo número de vértices\n"
            + "    static int padre[] = new int[MAX]; //Este arreglo contiene el padre del i-esimo nodo\n"
            + "    static int rango[] = new int[MAX]; //profundidad de cada vértice\n"
            + "\n"
            + "    //Método de inicialización\n"
            + "static void MakeSet(int n) {\n"
            + "        for (int i = 0; i < n; ++i) {\n"
            + "padre[i] = i; //Inicialmente el padre de cada vértice es el mismo vértice\n"
            + "            rango[i] = 0; //Altura o rango de cada vértice es 0\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "//Método para encontrar la raiz del vértice actual X\n"
            + "static int Find(int x) {\n"
            + "if (x == padre[x]) { //Si estoy en la raiz\n"
            + "            return x; //Retorno la raiz\n"
            + "        } //else return Find( padre[ x ] ); //De otro modo busco el padre del vértice actual, hasta llegar a la raiz.\n"
            + "        else {\n"
            + "            return padre[x] = Find(padre[x]); //Compresion de caminos\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "//Método para unir 2 componentes conexas\n"
            + "    static void Union(int x, int y) {\n"
            + "        int xRoot = Find(x); //Obtengo la raiz de la componente del vértice X\n"
            + "        int yRoot = Find(y); //Obtengo la raiz de la componente del vértice Y\n"
            + "        padre[xRoot] = yRoot; //Mezclo ambos arboles o conjuntos, actualizando su padre de alguno de ellos como la raiz de otro\n"
            + "    }\n"
            + "\n"
            + "    //Método para unir 2 componentes conexas usando sus alturas (rangos)\n"
            + "static void UnionbyRank(int x, int y) {\n"
            + "int xRoot = Find(x); //Obtengo la raiz de la componente del vértice X\n"
            + "        int yRoot = Find(y); //Obtengo la raiz de la componente del vértice Y\n"
            + "        if (rango[xRoot] > rango[yRoot]) { //en este caso la altura de la componente del vértice X es\n"
            + "//mayor que la altura de la componente del vértice Y.\n"
            + "            padre[yRoot] = xRoot; //el padre de ambas componentes será el de mayor altura\n"
            + "        } else { //en este caso la altura de la componente del vértice Y es mayor o igual que la de X\n"
            + "            padre[xRoot] = yRoot; //el padre de ambas componentes será el de mayor altura\n"
            + "            if (rango[xRoot] == rango[yRoot]) { //si poseen la misma altura\n"
            + "                rango[yRoot]++; //incremento el rango de la nueva raíz\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static int root[] = new int[MAX]; //tendra las raices de las componentes conexas luego de aplicar el método\n"
            + "    static int numComponentes; //variable para el número total de componentes conexas\n"
            + "//Método para obtener el número de componentes conexas luego de realizar las conexiones respectivas\n"
            + "\n"
            + "static int getNumberConnectedComponents(int n) {\n"
            + "        numComponentes = 0;\n"
            + "        for (int i = 0; i < n; ++i) {\n"
            + "if (padre[i] == i) { //Si el padre del vértice i es el mismo vértice entonces es raíz\n"
            + "                //if( Find( i ) == i ){ //podemos usamos find para el mismo proposito y\n"
            + "//para que se realice compresion de caminos\n"
            + "                root[numComponentes++] = i; //almaceno la raiz de cada nueva componente\n"
            + "                // numComponentes++;\n"
            + "            }\n"
            + "        }\n"
            + "        return numComponentes;\n"
            + "    }\n"
            + "\n"
            + "    static int numVertices[] = new int[MAX]; //almacenara la cantidad de vértices para la i-esima raiz.\n"
            + "//Método para obtener la raiz y el número de vértices de cada componente conexa\n"
            + "    //será necesario primero tener la cantidad de componentes conexas\n"
            + "    //podemos llamar 1ero al metodo getNumberConnectedComponents o incluir porcion de su codigo en este\n"
            + "\n"
            + "static void getNumberNodes(int n) {\n"
            + "Arrays.fill(numVertices, 0); //inicializo mi contador de vértices\n"
            + "for (int i = 0; i < n; ++i) {\n"
            + "            numVertices[Find(i)]++; //incremento la raíz del vértice i\n"
            + "        }\n"
            + "        for (int i = 0; i < numComponentes; ++i) {\n"
            + "            System.out.printf(\"Componente %d: Raiz = %d , Nro nodos = %d.\\n\", i + 1, root[i], numVertices[root[i]]);\n"
            + "}\n"
            + "    }\n"
            + "\n"
            + "//Método que me determina si 2 vértices estan o no en la misma componente conexa\n"
            + "static boolean sameComponent(int x, int y) {\n"
            + "        if (Find(x) == Find(y)) {\n"
            + "return true; //si poseen la misma raíz\n"
            + "}\n"
            + "        return false;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "int V, E, origen, destino;\n"
            + "Scanner sc = new Scanner(System.in);\n"
            + "V = sc.nextInt();\n"
            + "        E = sc.nextInt(); //tengamos número de vertices y aristas\n"
            + "        MakeSet(V); //inicializamos los conjuntos\n"
            + "        for (int i = 0; i < E; ++i) {\n"
            + "            origen = sc.nextInt();\n"
            + "            destino = sc.nextInt();\n"
            + "            UnionbyRank(origen, destino); //union de elementos\n"
            + "        }\n"
            + "        System.out.printf(\"El número de componentes conexas es: %d\\n\", getNumberConnectedComponents(V));\n"
            + "        getNumberNodes(V);\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "}";
    private String dominodfs = "//Programa java que usando DFS busca cuantos dominos\n"
            + "// caen desde un origen\n"
            + "import java.util.ArrayList;\n"
            + "import java.util.Arrays;\n"
            + "import java.util.Scanner;\n"
            + "\n"
            + "/* EJEMPLO DE INGRESO\n"
            + "9 6 3\n"
            + "1 2\n"
            + "2 5\n"
            + "5 3\n"
            + "4 3\n"
            + "6 7\n"
            + "7 8\n"
            + "1\n"
            + "6\n"
            + "4*/\n"
            + "public class DominoDFS {\n"
            + "\n"
            + "static final int MAX = 10001;\n"
            + "    static ArrayList<ArrayList<Integer>> ady =\n"
            + "            new ArrayList<ArrayList<Integer>>(MAX);\n"
            + "    static Scanner sc = new Scanner(System.in);\n"
            + "//la cantidad total de dominos que caerán\n"
            + "    static int total; \n"
            + "//arreglo de domino caido\n"
            + "static boolean visitado[] = new boolean[MAX]; \n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "//número de dominos, cantidad de enlaces, consultas\n"
            + "        int V, M, Q, x, y, origen; \n"
            + "V = sc.nextInt();\n"
            + "        M = sc.nextInt();\n"
            + "        Q = sc.nextInt();\n"
            + "        for (int i = 0; i < V; i++) {\n"
            + "            ady.add(new ArrayList<>());\n"
            + "        }\n"
            + "        while (M > 0) {\n"
            + "//domino x hace caer a domino y\n"
            + "x = sc.nextInt();\n"
            + "            y = sc.nextInt();\n"
            + "            ady.get(x).add(y);\n"
            + "M--;\n"
            + "        }\n"
            + "        while (Q > 0) {\n"
            + "//domino origen\n"
            + "            origen = sc.nextInt(); \n"
            + "            total = 0;\n"
            + "            Arrays.fill(visitado, false);\n"
            + "            dfs(origen);\n"
            + "System.out.printf(\"%d\\n\", total);\n"
            + "Q--;\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    static void dfs(int u) { //domino origen\n"
            + "        //aumento en mi respuesta la caida de un domino\n"
            + "        total++; \n"
            + "//domino \"u\" cayo\n"
            + "        visitado[u] = true; \n"
            + "//verifico los demás posibles \n"
            + "         //domino que caeran si impulso \"u\"\n"
            + "for (int v = 0; v < ady.get(u).size(); ++v) {\n"
            + "//si el domino adyacente no \n"
            + "            //cayó entonces es elsiguiente a evaluar\n"
            + "            if (!visitado[ady.get(u).get(v)]) { \n"
            + "//recursivamente veo que dominos \n"
            + "                //caeran a partir del adyacente de \"u\"\n"
            + "dfs(ady.get(u).get(v)); \n"
            + "}\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "}";
    private String exitthemazebfs = "// Programa java que realiza laberintos con BFS\n"
            + "import java.util.Arrays;\n"
            + "import java.util.LinkedList;\n"
            + "import java.util.Queue;\n"
            + "import java.util.Scanner;\n"
            + "\n"
            + "public class ExitTheMazeBFS {\n"
            + "/* Ejemplo de ingreso\n"
            + "8 8\n"
            + ".......I\n"
            + ".#######\n"
            + ".#......\n"
            + ".#.S...S\n"
            + ".###.#.#\n"
            + ".#...#.#\n"
            + ".#.###.#\n"
            + "........\n"
            + "*/\n"
            + "    //máximo número de filas y columnas del laberinto\n"
            + "static final int MAX = 100; \n"
            + "    static Scanner sc = new Scanner(System.in);\n"
            + "//laberinto\n"
            + "    static char ady[][] = new char[MAX][MAX]; \n"
            + "//arreglo de estados visitados\n"
            + "    static boolean visitado[][] = new boolean[MAX][MAX]; \n"
            + "//incremento en coordenada x\n"
            + "    static int dx[] = {0, 0, 1, -1}; \n"
            + "//incremento en coordanada y\n"
            + "    static int dy[] = {1, -1, 0, 0}; \n"
            + "//altura y ancho del laberinto\n"
            + "    static int h, w; \n"
            + "    //Arreglo para mostrar la ruta que se siguio\n"
            + "static Estado prev[][] = new Estado[MAX][MAX]; \n"
            + "    static class Estado {\n"
            + "int x; // Fila del estado\n"
            + "        int y; // Columna del estado\n"
            + "        int d; // Distancia del estado\n"
            + "// Constructor\n"
            + "        Estado(int x1, int y1, int d1) {\n"
            + "this.x = x1;\n"
            + "            this.y = y1;\n"
            + "            this.d = d1;\n"
            + "        }\n"
            + "        Estado() {\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "int x=0, y=0;\n"
            + "        System.out.println(\"Ingrese altura del laberinto: \");\n"
            + "h = sc.nextInt();\n"
            + "        System.out.println(\"Ingrese ancho del laberinto: \");\n"
            + "        w = sc.nextInt();\n"
            + "sc.nextLine();\n"
            + "        System.out.printf(\"\\nIngrese el laberinto, con un solo \"\n"
            + "                + \"valor inicial I, valor final sera S: \\n\");\n"
            + "for (int i = 0; i < h; ++i) {\n"
            + "            String aux = sc.nextLine();\n"
            + "            for (int j = 0; j < w; ++j) {\n"
            + "                ady[i][j] = aux.charAt(j);\n"
            + "//obtengo coordenada de valor inicial\n"
            + "                if (ady[i][j] == 'I') { \n"
            + "                    x = i;\n"
            + "                    y = j;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "//MOSTRAMOS LABERINTO\n"
            + "for (int i = 0; i < h; ++i) {\n"
            + "            for (int j = 0; j < w; ++j) {\n"
            + "                System.out.printf(\"%c\", ady[i][j]);\n"
            + "            }\n"
            + "            System.out.printf(\"\\n\");\n"
            + "        }\n"
            + "        int min = BFS(x, y, h, w);\n"
            + "if (min != -1) {\n"
            + "            System.out.printf(\"Menor número de pasos: %d\\n\", min);\n"
            + "        } else {\n"
            + "            System.out.println(\"No se pudo llegar al destino\");\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "//Funcion para imprimir la ruta encontrada\n"
            + "    //Ingresan las coordenadas del nodo final\n"
            + "\n"
            + "static void print(int x, int y) {\n"
            + "//El arreglo prev posee las coordenadas del nodo \n"
            + "        //anterior, por ello empezamos desde el final\n"
            + "        //El proceso termina al momento de preguntar \n"
            + "        //por el anterior del nodo inicial, como pusimos -1\n"
            + "        //Preguntamos hasta que nuestro anterior sea diferente de -1\n"
            + "for (int i = x, j = y; prev[i][j].d != -1; i =\n"
            + "prev[x][y].x, j = prev[x][y].y) {\n"
            + "ady[i][j] = '*';\n"
            + "            x = i;\n"
            + "            y = j;\n"
            + "}\n"
            + "\n"
            + "        System.out.printf(\"Camino con menor número de pasos\\n\");\n"
            + "for (int i = 0; i < h; ++i) {\n"
            + "            for (int j = 0; j < w; ++j) {\n"
            + "                System.out.printf(\"%c\", ady[i][j]);\n"
            + "}\n"
            + "            System.out.printf(\"\\n\");\n"
            + "        }\n"
            + "    }\n"
            + "//coordenadas de inicial \"I\" y dimensiones de laberinto\n"
            + "static int BFS(int x, int y, int h, int w) { \n"
            + "//Estado inicial, distancia = 0\n"
            + "        Estado inicial = new Estado(x, y, 0); \n"
            + "//Cola de todos los posibles Estados por\n"
            + "         //los que se pase para llegar al destino\n"
            + "Queue<Estado> Q = new LinkedList<>();\n"
            + "//Insertamos el estado inicial en la Cola.\n"
            + "        //marcamos como no visitado\n"
            + "        Q.offer(inicial); \n"
            + "for (int i = 0; i < MAX; i++) {\n"
            + "Arrays.fill(visitado[i], false);\n"
            + "        }\n"
            + "//el inicial no tiene una ruta anterior puesto que es  primero\n"
            + "        prev[x][y] = new Estado(-1, -1, -1); \n"
            + "//Mientras cola no este vacia\n"
            + "        while (!Q.isEmpty()) { \n"
            + "//Obtengo de la cola el estado actual, \n"
            + "            //en un comienzo será el inicial\n"
            + "            Estado actual = Q.peek(); \n"
            + "//Saco el elemento de la cola\n"
            + "            Q.poll(); \n"
            + "//Si se llego al destino (punto final)\n"
            + "if (ady[actual.x][actual.y] == 'S') {\n"
            + "//imprimo la ruta del camino más corto\n"
            + "print(actual.x, actual.y); \n"
            + "//Retornamos distancia recorrida hasta ese momento\n"
            + "                return actual.d; \n"
            + "            }\n"
            + "//Marco como visitado dicho estado para no volver a recorrerlo\n"
            + "            visitado[actual.x][actual.y] = true; \n"
            + "//Recorremos hasta 4 porque tenemos 4 posibles adyacentes\n"
            + "            for (int i = 0; i < 4; ++i) { \n"
            + "//nx y ny tendran la coordenada adyacente\n"
            + "                int nx = dx[i] + actual.x; \n"
            + "//ejemplo en i=0 y actual \n"
            + "                //(3,4) -> 3+dx[0]=3+0=3, \n"
            + "                //4+dy[0]=4+1=5, nueva coordenada (3,5)\n"
            + "                int ny = dy[i] + actual.y; \n"
            + "//aqui comprobamos que la coordenada \n"
            + "                //adyacente no sobrepase las dimensiones del laberinto\n"
            + "                //además comprobamos que no sea \n"
            + "                //pared \"#\" y no este visitado\n"
            + "if (nx >= 0 && nx < h && ny >= 0 &&\n"
            + "                        ny < w && ady[nx][ny] != '#' && !visitado[nx][ny]) {\n"
            + "//Creamos estado adyacente aumento en \n"
            + "                    //1 la distancia recorrida\n"
            + "                    Estado adyacente = new Estado(nx, ny, actual.d + 1);\n"
            + "//Agregamos adyacente a la cola\n"
            + "                    Q.offer(adyacente); \n"
            + "//El previo del nuevo nodo es el actual.\n"
            + "prev[nx][ny] = actual; \n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "        return -1;\n"
            + "}\n"
            + "}";
    private String bellmanfordsp = "// Implementación java del algoritmo de BellmanFord\n"
            + "// para la busqueda del camino más corto de un vertice al\n"
            + "// resto y con capacidad de detección de ciclo negativo\n"
            + "import java.util.ArrayList;\n"
            + "import java.util.List;\n"
            + "import java.util.Scanner;\n"
            + "\n"
            + "public class BellmanFordSP {\n"
            + "\n"
            + "    static final int MAX = 105;\n"
            + "    static final int INF = 1 << 30;\n"
            + "    static int[] previo = new int[MAX];\n"
            + "    static int[] distancia = new int[MAX];\n"
            + "    static int vertices;\n"
            + "    static List<List<Node>> adyacencia = new ArrayList<List<Node>>();\n"
            + "    static Scanner sc = new Scanner(System.in);\n"
            + "    static void inicializacion() {\n"
            + "        for (int i = 0; i <= vertices; i++) {\n"
            + "            distancia[i] = INF;\n"
            + "            previo[i] = -1;\n"
            + "        }\n"
            + "    }\n"
            + "    static class Node {\n"
            + "        int first, second;\n"
            + "        public Node(int destino, int peso) {\n"
            + "            this.first = destino;\n"
            + "            this.second = peso;\n"
            + "        }\n"
            + "    }\n"
            + "    static void print(int destino) {\n"
            + "if (previo[destino] != -1) {\n"
            + "            print(previo[destino]);\n"
            + "}\n"
            + "        System.out.printf(\"%d \", destino);\n"
            + "    }\n"
            + "    static boolean relajacion(int actual, int adyacente, int peso) {\n"
            + "if (distancia[actual] + peso < distancia[adyacente]) {\n"
            + "            distancia[adyacente] = distancia[actual] + peso;\n"
            + "            previo[adyacente] = actual;\n"
            + "return true;\n"
            + "        }\n"
            + "        return false;\n"
            + "    }\n"
            + "    static void bellmanFord(int inicial) {\n"
            + "        inicializacion();\n"
            + "        distancia[inicial] = 0;\n"
            + "        for (int i = 0; i <= vertices - 1; i++) {\n"
            + "            for (int actual = 0; actual <= vertices; actual++) {\n"
            + "                for (int j = 0; j < adyacencia.get(actual).size(); j++) {\n"
            + "                    int adyacente = adyacencia.get(actual).get(j).first;\n"
            + "                    int peso = adyacencia.get(actual).get(j).second;\n"
            + "relajacion(actual, adyacente, peso);\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "        for (int actual = 0; actual <= vertices; actual++) {\n"
            + "for (int j = 0; j < adyacencia.get(actual).size(); j++) {\n"
            + "                int adyacente = adyacencia.get(actual).get(j).first;\n"
            + "                int peso = adyacencia.get(actual).get(j).second;\n"
            + "if (relajacion(actual, adyacente, peso)) {\n"
            + "                    System.out.println(\"Existe ciclo negativo\");\n"
            + "                    return;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "        System.out.println(\"No esiste ciclo negativo\");\n"
            + "        System.out.printf(\"Distancias más corteas iniciando en el nodo %d\\n\", inicial);\n"
            + "for (int i = 0; i <= vertices; i++) {\n"
            + "System.out.printf(\"Nodo %d , distancia más corta = %d\\n\", i, distancia[i]);\n"
            + "        }\n"
            + "        System.out.println(\"\\n ________Camino más corto____\");\n"
            + "System.out.println(\"Ingrese vertice destino: \");\n"
            + "        int destino = sc.nextInt();\n"
            + "        print(destino);\n"
            + "        System.out.println(\"\");\n"
            + "    }\n"
            + "    public static void main(String[] args) {\n"
            + "int E, origen, destino, peso, inicial;\n"
            + "vertices = sc.nextInt();\n"
            + "        E = sc.nextInt();\n"
            + "        for (int i = 0; i < 10; i++) {\n"
            + "            adyacencia.add(new ArrayList<>());\n"
            + "        }\n"
            + "        for (int i = 0; i < E; i++) {\n"
            + "            origen = sc.nextInt();\n"
            + "            destino = sc.nextInt();\n"
            + "            peso = sc.nextInt();\n"
            + "            adyacencia.get(origen).add(new Node(destino, peso));\n"
            + "        }\n"
            + "System.out.printf(\"Ingrese el nodo inicial: \");\n"
            + "inicial = sc.nextInt();\n"
            + "        bellmanFord(inicial);\n"
            + "}\n"
            + "}";
    private String dijkstrasp = "// Implementación java del algoritmo de Dijkstra que\n"
            + "// busca el camino más corto de un nodo al resto\n"
            + "/*\n"
            + " EJEMPLO DE INPUT\n"
            + " 5 9\n"
            + " 1 2 7\n"
            + " 1 4 2\n"
            + " 2 3 1\n"
            + " 2 4 2\n"
            + " 3 5 4\n"
            + " 4 2 3\n"
            + " 4 3 8\n"
            + " 4 5 5\n"
            + " 5 3 5\n"
            + " 1\n"
            + " */\n"
            + "import java.util.*;\n"
            + "\n"
            + "public class DijkstraSP {\n"
            + "\n"
            + "//similar a los defines de C++\n"
            + "    static final int MAX = 10005; //maximo número de vértices\n"
            + "    static final int INF = 1 << 30; //definimos un valor \n"
            + "    //grande que represente la distancia infinita\n"
            + "    //inicial, basta conque sea superior al maximo \n"
            + "    //valor del peso en alguna de las aristas\n"
            + "    //En el caso de java usamos una clase que \n"
            + "    //representara el pair de C++\n"
            + "\n"
            + "static class Node implements Comparable<Node> {\n"
            + "\n"
            + "        int first, second;\n"
            + "\n"
            + "        Node(int d, int p) { //constructor\n"
            + "            this.first = d;\n"
            + "            this.second = p;\n"
            + "}\n"
            + "\n"
            + "        @Override\n"
            + "        public int compareTo(Node other) { //es necesario \n"
            + "            //definir un comparador para el\n"
            + "//correcto funcionamiento del PriorityQueue\n"
            + "            if (second > other.second) {\n"
            + "                return 1;\n"
            + "            }\n"
            + "            if (second == other.second) {\n"
            + "                return 0;\n"
            + "            }\n"
            + "            return -1;\n"
            + "        }\n"
            + "    };\n"
            + "\n"
            + "    static Scanner sc = new Scanner(System.in); //para lectura de datos\n"
            + "    static List< List< Node>> ady = new ArrayList< List< Node>>(); //lista de adyacencia\n"
            + "    static int distancia[] = new int[MAX]; // distancia de vértice inicial\n"
            + "//vértice con ID = u\n"
            + "    static boolean visitado[] = new boolean[MAX]; //para vértices visitados\n"
            + "    static PriorityQueue< Node> Q = new PriorityQueue<Node>();\n"
            + "//usamos el comparador definido para \n"
            + "    //que el de menor valor este en el tope\n"
            + "    static int V; //número de vertices\n"
            + "    static int previo[] = new int[MAX]; //para la impresion de caminos\n"
            + "\n"
            + "    //función de inicialización\n"
            + "static void init() {\n"
            + "        for (int i = 0; i <= V; ++i) {\n"
            + "distancia[i] = INF; //inicializamos todas \n"
            + "//las distancias con valor infinito\n"
            + "            visitado[i] = false; //inicializamos todos \n"
            + "            //los vértices como no visitados\n"
            + "            previo[i] = -1; //inicializamos el previo \n"
            + "            //del vertice i con -1\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "//Paso de relajacion\n"
            + "    static void relajacion(int actual, int adyacente, int peso) {\n"
            + "//Si la distancia del origen al vertice actual + \n"
            + "        //peso de su arista es menor a la distancia del\n"
            + "        //origen al vertice adyacente\n"
            + "        if (distancia[actual] + peso < distancia[adyacente]) {\n"
            + "//relajamos el vertice actualizando\n"
            + "            //la distancia\n"
            + "            distancia[adyacente] = distancia[actual] + peso; \n"
            + "//a su vez actualizamos el vertice\n"
            + "            //previo\n"
            + "            previo[adyacente] = actual; \n"
            + "//agregamos adyacente a la cola\n"
            + "            //de prioridad\n"
            + "            Q.add(new Node(adyacente, distancia[adyacente])); \n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "//Impresion del camino más corto desde el vertice inicial y final ingresados\n"
            + "static void print(int destino) {\n"
            + "if (previo[destino] != -1) //si aun poseo un vertice previo\n"
            + "        {\n"
            + "            print(previo[destino]); //recursivamente sigo explorando\n"
            + "        }\n"
            + "//terminada la recursion imprimo los vertices\n"
            + "        //recorridos\n"
            + "        System.out.printf(\"%d \", destino); \n"
            + "}\n"
            + "\n"
            + "    static void dijkstra(int inicial) {\n"
            + "init(); //inicializamos nuestros arreglos\n"
            + "        //Insertamos el vértice inicial en la Cola de Prioridad\n"
            + "Q.add(new Node(inicial, 0)); \n"
            + "//Este paso es importante, inicializamos la distancia del\n"
            + "        //inicial como 0\n"
            + "        distancia[inicial] = 0; \n"
            + "        int actual, adyacente, peso;\n"
            + "        while (!Q.isEmpty()) { //Mientras cola no este vacia\n"
            + "            //Obtengo de la cola el nodo con menor peso, en un\n"
            + "            //comienzo será el inicial\n"
            + "            actual = Q.element().first; \n"
            + "            Q.remove(); //Sacamos el elemento de la cola\n"
            + "            if (visitado[actual]) {\n"
            + "                continue; //Si el vértice actual ya fue visitado entonces sigo\n"
            + "            }//sacando elementos de la cola\n"
            + "            visitado[actual] = true; //Marco como visitado el vértice actual\n"
            + "            //reviso sus adyacentes del\n"
            + "            //vertice actual\n"
            + "for (int i = 0; i < ady.get(actual).size(); ++i) { \n"
            + "                adyacente = ady.get(actual).get(i).first; //id del vertice adyacente\n"
            + "//peso de la arista que une actual\n"
            + "                //con adyacente ( actual , adyacente )\n"
            + "                peso = ady.get(actual).get(i).second; \n"
            + "                //si el vertice adyacente no fue visitado\n"
            + "                if (!visitado[adyacente]) { \n"
            + "                    //realizamos el paso de relajacion\n"
            + "                    relajacion(actual, adyacente, peso); \n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        System.out.printf(\"Distancias más cortas iniciando en vertice %d\\n\", inicial);\n"
            + "for (int i = 1; i <= V; ++i) {\n"
            + "System.out.printf(\"Vertice %d , distancia más corta = %d\\n\", i, distancia[i]);\n"
            + "        }\n"
            + "\n"
            + "        System.out.println(\"\\n**************Impresion de camino más corto**************\");\n"
            + "System.out.printf(\"Ingrese vertice destino: \");\n"
            + "        int destino;\n"
            + "        destino = sc.nextInt();\n"
            + "        print(destino);\n"
            + "        System.out.printf(\"\\n\");\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "int E, origen, destino, peso, inicial;\n"
            + "\n"
            + "V = sc.nextInt();\n"
            + "        E = sc.nextInt();\n"
            + "        for (int i = 0; i <= V; ++i) {\n"
            + "ady.add(new ArrayList<Node>()); //inicializamos lista de\n"
            + "}//adyacencia\n"
            + "        for (int i = 0; i < E; ++i) {\n"
            + "origen = sc.nextInt();\n"
            + "            destino = sc.nextInt();\n"
            + "            peso = sc.nextInt();\n"
            + "            ady.get(origen).add(new Node(destino, peso)); //grafo diridigo\n"
            + "//ady.get( destino ).add( new Node( origen , peso ) ); //no dirigido\n"
            + "        }\n"
            + "        System.out.print(\"Ingrese el vertice inicial: \");\n"
            + "        inicial = sc.nextInt();\n"
            + "        dijkstra(inicial);\n"
            + "    }\n"
            + "}";
    private String bipartitegraph = "//Programa java que encuentra si un grafo es \n"
            + "//bipartito o no\n"
            + "import java.util.*;\n"
            + "\n"
            + "public class BipartiteGraph {\n"
            + "    final static int V = 4; \n"
            + "    static boolean isBipartite(int G[][], int src) {\n"
            + "/*Crear una matriz de colores para almacenar los \n"
            + "        colores asignados a todas las verificaciones. \n"
            + "        El número de vértice se utiliza como índice en \n"
            + "        esta matriz. El valor '-1' de colorArr [i] se \n"
            + "        usa para indicar que no se asigna ningún color \n"
            + "        al vértice 'i'. El valor 1 se utiliza para indicar \n"
            + "        que el primer color está asignado y el valor 0 \n"
            + "        indica que el segundo color está asignado.*/\n"
            + "int colorArr[] = new int[V];\n"
            + "        for (int i = 0; i < V; ++i) {\n"
            + "colorArr[i] = -1;\n"
            + "        }\n"
            + "        //Asigna primer color al origen\n"
            + "        colorArr[src] = 1;\n"
            + "//Crea una cola de número de vertices\n"
            + "        // y encola el vertice origen \n"
            + "        LinkedList<Integer> q = new LinkedList<>();\n"
            + "        q.add(src);\n"
            + "        while (!q.isEmpty()) {\n"
            + "// Descola un vertice de la cola\n"
            + "            int u = q.poll();\n"
            + "//Retorna falso si hay un autociclo\n"
            + "if (G[u][u] == 1) {\n"
            + "                return false;\n"
            + "}\n"
            + "//Encuentra todos los vertoces adyacentes sin color \n"
            + "for (int v = 0; v < V; ++v) {\n"
            + "// Un camino de u a v existe\n"
            + "                // y destino v no esta coloreado\n"
            + "                if (G[u][v] == 1 && colorArr[v] == -1) {\n"
            + "//Asigna color alternativo para esta adyacencia\n"
            + "                    colorArr[v] = 1 - colorArr[u];\n"
            + "                    q.add(v);\n"
            + "                } \n"
            + "/*Un camino de u a v existe y el destino \n"
            + "                esta del mismo color que u*/\n"
            + "else if (G[u][v] == 1 && colorArr[v] == colorArr[u]) {\n"
            + "                    return false;\n"
            + "}\n"
            + "            }\n"
            + "        }\n"
            + "// Si llegamos aqui, todos los vertoces adyacentes pueden\n"
            + "        // ser coloreados con color alternativo\n"
            + "        return true;\n"
            + "}\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int G[][] = {{0, 1, 0, 1},\n"
            + "        {1, 0, 1, 0},\n"
            + "        {0, 1, 0, 1},\n"
            + "        {1, 0, 1, 0}\n"
            + "        };\n"
            + "        if (isBipartite(G, 0)) {\n"
            + "            System.out.println(\"Si\");\n"
            + "        } else {\n"
            + "System.out.println(\"No\");\n"
            + "        }\n"
            + "    }\n"
            + "}";
    private String knapsackrecursive = "/*Implementación java del problema 0-1 Knapsack */\n"
            + "public class KnapsackRecursive { \n"
            + "//Función de utilidad que retorna el mayor de dos números\n"
            + "static int max(int a, int b) { return (a > b) ? a : b; } \n"
            + "// Retorna el maximo valor que puede ser \n"
            + "    //Puesto en una knapsack de capacidad w\n"
            + "static int knapSack(int W, int wt[], int val[], int n) \n"
            + "    { \n"
            + "// Caso base\n"
            + "        if (n == 0 || W == 0) \n"
            + "return 0; \n"
            + "/*Si el peso de el nesimo item es más\n"
            + "        que la capacidad el knapsack, entonces\n"
            + "        este item no puede ser icluido en una \n"
            + "        solución optima*/\n"
            + "        if (wt[n - 1] > W) \n"
            + "return knapSack(W, wt, val, n - 1); \n"
            + "// Retorna el maximo de dos casos:\n"
            + "        //1) nesimo termino incluido\n"
            + "        //2) no incluido\n"
            + "        else\n"
            + "return max(val[n - 1] + knapSack(W - wt[n - 1], wt, val, n - 1), \n"
            + "                       knapSack(W, wt, val, n - 1)); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        int val[] = new int[] { 60, 100, 120 }; \n"
            + "        int wt[] = new int[] { 10, 20, 30 }; \n"
            + "        int W = 50; \n"
            + "        int n = val.length; \n"
            + "        System.out.println(knapSack(W, wt, val, n)); \n"
            + "} \n"
            + "}\n"
            + "// Implementación java que usa programación dinamica\n"
            + "// para solucionar el problema de 0-1 Knapsack\n"
            + "public class KnapsackDP {\n"
            + "//Función de utilidad que retorna el maximo de dos enteros\n"
            + "static int max(int a, int b) {\n"
            + "        return (a > b) ? a : b;\n"
            + "}\n"
            + "// Retorna el maximo valor que puede ser puesto en un\n"
            + "//knapsack de capacidad w\n"
            + "    static int knapSack(int W, int wt[], int val[], int n) {\n"
            + "        int i, w;\n"
            + "        int K[][] = new int[n + 1][W + 1];\n"
            + "// Construye la tabla K[][]de abajo hacia arriba\n"
            + "for (i = 0; i <= n; i++) {\n"
            + "            for (w = 0; w <= W; w++) {\n"
            + "                if (i == 0 || w == 0) {\n"
            + "                    K[i][w] = 0;\n"
            + "                } else if (wt[i - 1] <= w) {\n"
            + "                    K[i][w] = max(val[i - 1] + \n"
            + "                            K[i - 1][w - wt[i - 1]], K[i - 1][w]);\n"
            + "                } else {\n"
            + "                    K[i][w] = K[i - 1][w];\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        return K[n][W];\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        int val[] = new int[]{60, 100, 120};\n"
            + "        int wt[] = new int[]{10, 20, 30};\n"
            + "        int W = 50;\n"
            + "        int n = val.length;\n"
            + "        System.out.println(knapSack(W, wt, val, n));\n"
            + "}\n"
            + "}";
    private String coinexchange = "// Programa java que resuelve el problema\n"
            + "// del cambio de monedas\n"
            + "public class CoinExchange { \n"
            + "// Retorna el conteo de formás que podemos\n"
            + "    // sumar S[0...m-1] monedas para obtener n \n"
            + "static int count( int S[], int m, int n ) \n"
            + "{ \n"
            + "// Si n es 0 entonces 1 es la solución \n"
            + "        // (No incluir ninguna moneda \n"
            + "        if (n == 0) \n"
            + "            return 1;\n"
            + "        // Si n es menos que 0 entonces no hay solución\n"
            + "        if (n < 0) \n"
            + "            return 0; \n"
            + "/*Si no hay monedas y n es mayor que 0, no existe solución*/\n"
            + "        if (m <=0 && n >= 1) \n"
            + "            return 0; \n"
            + "// count es la suma de las soluciónes (i) \n"
            + "        // incluyendo S[m-1] (ii) excluyendo S[m-1] \n"
            + "return count( S, m - 1, n ) + \n"
            + "               count( S, m, n-S[m-1] ); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        int arr[] = {1, 2, 3}; \n"
            + "        int m = arr.length; \n"
            + "        System.out.println( count(arr, m, 4));        \n"
            + "}   \n"
            + "}";
    private String longestincreasingsubsequence = "//Programa java que implementa la LIS\n"
            + "\n"
            + "public class LongestIncreasingSubsequence {\n"
            + "\n"
            + "    static int max_ref; \n"
            + "/* Para hacer uso de llamadas recursivas, esta función debe devolver.\n"
            + "   dos cosas:\n"
            + "   1) Longitud de LIS que termina con el elemento arr [n-1]. Usamos\n"
            + "      max_ending_here para este propósito\n"
            + "   2) Máximo global ya que el LIS puede terminar con un elemento\n"
            + "      antes de arr [n-1] max_ref se usa para este propósito.\n"
            + "   El valor de LIS de la matriz completa de tamaño n se almacena en\n"
            + "   * max_ref cual es nuestro resultado final*/\n"
            + "static int _lis(int arr[], int n) {\n"
            + "// Caso base\n"
            + "        if (n == 1) {\n"
            + "            return 1;\n"
            + "}\n"
            + "// 'max_ending_here' es el tamaño de LIS \n"
            + "// terminando con arr[n-1] \n"
            + "        int res, max_ending_here = 1;\n"
            + "        for (int i = 1; i < n; i++) {\n"
            + "            res = _lis(arr, i);\n"
            + "            if (arr[i - 1] < arr[n - 1] && res + 1 > max_ending_here) {\n"
            + "                max_ending_here = res + 1;\n"
            + "            }\n"
            + "        }\n"
            + "        if (max_ref < max_ending_here) {\n"
            + "            max_ref = max_ending_here;\n"
            + "        }\n"
            + "        return max_ending_here;\n"
            + "    }\n"
            + "\n"
            + "    static int lis(int arr[], int n) {\n"
            + "// Guarda el resultado \n"
            + "        max_ref = 1;\n"
            + "//Almacena su resultado en max \n"
            + "        _lis(arr, n);\n"
            + "//Retorna el maximo\n"
            + "        return max_ref;\n"
            + "}\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        int arr[] = {10, 22, 9, 33, 21, 50, 41, 60};\n"
            + "        int n = arr.length;\n"
            + "System.out.println(\"Tamaño de la subsecuencia incremental más larga\"\n"
            + "                + \" es \" + lis(arr, n) + \"\\n\");\n"
            + "    }\n"
            + "}";
    private String longestcommonsubstring = "/* Implementación java que encuentra el substring comun más \n"
            + "largo usando programación dinamica*/\n"
            + "public class LongestCommonSubString\n"
            + "{ \n"
            + "    static int LCSubStr(char X[], char Y[], int m, int n)  \n"
            + "    { \n"
            + "\n"
            + "        int LCStuff[][] = new int[m + 1][n + 1]; \n"
            + "int result = 0;  //Para almacenar el tamaño del substring \n"
            + "for (int i = 0; i <= m; i++)  \n"
            + "        { \n"
            + "            for (int j = 0; j <= n; j++)  \n"
            + "            { \n"
            + "                if (i == 0 || j == 0) \n"
            + "                    LCStuff[i][j] = 0; \n"
            + "                else if (X[i - 1] == Y[j - 1]) \n"
            + "                { \n"
            + "                    LCStuff[i][j] = LCStuff[i - 1][j - 1] + 1; \n"
            + "                    result = Integer.max(result, LCStuff[i][j]); \n"
            + "                }  \n"
            + "                else\n"
            + "                    LCStuff[i][j] = 0; \n"
            + "            } \n"
            + "        } \n"
            + "        return result; \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args)  \n"
            + "{ \n"
            + "        String X = \"hola mundo\"; \n"
            + "        String Y = \"mundo\";\n"
            + "int m = X.length(); \n"
            + "        int n = Y.length(); \n"
            + "System.out.println(\"El tamaño del substring cómun más largo es \"\n"
            + "+ LCSubStr(X.toCharArray(), Y.toCharArray(), m, n)); \n"
            + "} \n"
            + "}";
    private String pascaltriangle = "//Código java que realiza el triángulo de Pascal\n"
            + "public class PascalTriangle {\n"
            + "\n"
            + "    static void printPascal(int n) {\n"
            + "/* Itera atraves de cada linea y la imprime\n"
            + "con sus entradas*/\n"
            + "\n"
            + "        for (int line = 0; line < n; line++) {\n"
            + "// Cada linea tiene u número de enteror\n"
            + "//igual al número de linea\n"
            + "            for (int i = 0; i <= line; i++) {\n"
            + "                System.out.print(binomialCoeff(line, i) + \" \");\n"
            + "            }\n"
            + "            System.out.println();\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static int binomialCoeff(int n, int k) {\n"
            + "        int res = 1;\n"
            + "        if (k > n - k) {\n"
            + "            k = n - k;\n"
            + "        }\n"
            + "        for (int i = 0; i < k; ++i) {\n"
            + "            res *= (n - i);\n"
            + "            res /= (i + 1);\n"
            + "        }\n"
            + "        return res;\n"
            + "    }\n"
            + "\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "int n = 7;\n"
            + "        printPascal(n);\n"
            + "    }\n"
            + "}";

    private String cicloscpp = "#include<bits/stdc++.h>\n"
            + "#include<cstdlib>\n"
            + "using namespace std;\n"
            + "\n"
            + "int main (int argc, char *argv[]) {\n"
            + "	\n"
            + "	int número;\n"
            + "	cin>>número;\n"
            + "	//Estructura de un condicional\n"
            + "	//Dentro el parentesis va la condicion a revisar\n"
            + "	//Si se cumple se realiza las siguientes lineas\n"
            + "	//En caso contrario pasa al else \n"
            + "	//y se realiza las lineas siguientes del else\n"
            + "	if (número % 2 == 0) {\n"
            + "		cout<<\"Es par\"<<endl;\n"
            + "	} else {\n"
            + "		cout<<\"Es impar\"<<endl;\n"
            + "	}\n"
            + "	cout<<endl;\n"
            + "	cout<<\"Ciclo for \"<<endl;\n"
            + "	// variable iteradora, condicion , acumulador\n"
            + "	for (int i = 0; i < 10; i++) {\n"
            + "		cout<<i<<endl;\n"
            + "	}\n"
            + "	cout<<\"Ciclo while\"<<endl;\n"
            + "	//Variable, condicion, al final acumulador\n"
            + "	int acumulador = 0;\n"
            + "	while (acumulador < 10) {\n"
            + "		cout<<acumulador<<endl;;\n"
            + "		acumulador++;\n"
            + "		\n"
            + "	}\n"
            + "	cout<<\"Ciclo do while\"<<endl;\n"
            + "	//Haga hasta que una condición se cumpla\n"
            + "	acumulador = 0;\n"
            + "	do {\n"
            + "		cout<<acumulador<<endl;\n"
            + "		acumulador++;\n"
            + "	} while (acumulador < 10);\n"
            + "	cout<<\"Ciclo for each\"<<endl;\n"
            + "	//Iterar entre todos los elementos que tenga una estructura\n"
            + "	//Sin importar el tamaño \n"
            + "	int números[] = {1,2,3,4,5,6,7,8,9,0};\n"
            + "	for (int o : números) {\n"
            + "		cout<<o<<endl;\n"
            + "	}\n"
            + "	return 0;\n"
            + "}	";
    private String ciclospy = "numero=0;\n"
            + "numero =int(input())\n"
            + "#Estructura de un condicional\n"
            + "#Dentro el parentesis va la condicion a revisar\n"
            + "#Si se cumple se realiza las siguientes lineas\n"
            + "#En caso contrario pasa al else \n"
            + "#y se realiza las lineas siguientes del else\n"
            + "if (numero % 2 == 0):\n"
            + "    print(\"Es par\")\n"
            + "else: \n"
            + "    print(\"Es impar\")\n"
            + "print(\"Ciclo for \")\n"
            + "#variable iteradora, rango inicio,final\n"
            + "for i in range (0,10):\n"
            + "    print(i)\n"
            + "print(\"Ciclo while\")\n"
            + "#Variable, condicion, al final acumulador\n"
            + "acumulador = 0;\n"
            + "while (acumulador < 10):\n"
            + "    print(acumulador)\n"
            + "    acumulador=acumulador+1;\n"
            + "print(\"Ciclo for each\")\n"
            + "#Iterar entre todos los elementos que tenga una estructura\n"
            + "#Sin importar el tamaño \n"
            + "numeros =[1,2,3,4,5,6,7,8,9,0]\n"
            + "for o in numeros:\n"
            + "    print(o)\n"
            + "";

    public String getCiclosjava() {
        return ciclosjava;
    }

    public void setCiclosjava(String ciclosjava) {
        this.ciclosjava = ciclosjava;
    }

    public String getLecturajava() {
        return lecturajava;
    }

    public void setLecturajava(String lecturajava) {
        this.lecturajava = lecturajava;
    }

    public String getLecturacpp() {
        return lecturacpp;
    }

    public void setLecturacpp(String lecturacpp) {
        this.lecturacpp = lecturacpp;
    }

    public String getLecturapy() {
        return lecturapy;
    }

    public void setLecturapy(String lecturapy) {
        this.lecturapy = lecturapy;
    }

    public String getCondicionalesjava() {
        return condicionalesjava;
    }

    public void setCondicionalesjava(String condicionalesjava) {
        this.condicionalesjava = condicionalesjava;
    }

    public String getCondicionalescpp() {
        return condicionalescpp;
    }

    public void setCondicionalescpp(String condicionalescpp) {
        this.condicionalescpp = condicionalescpp;
    }

    public String getCondicionalespy() {
        return condicionalespy;
    }

    public void setCondicionalespy(String condicionalespy) {
        this.condicionalespy = condicionalespy;
    }

    public String getExcepcionesjava() {
        return excepcionesjava;
    }

    public void setExcepcionesjava(String excepcionesjava) {
        this.excepcionesjava = excepcionesjava;
    }

    public String getExcepcionespy() {
        return excepcionespy;
    }

    public void setExcepcionespy(String excepcionespy) {
        this.excepcionespy = excepcionespy;
    }

    public String getTiempoejecucion() {
        return tiempoejecucion;
    }

    public void setTiempoejecucion(String tiempoejecucion) {
        this.tiempoejecucion = tiempoejecucion;
    }

    public String getEstructurasjava() {
        return estructurasjava;
    }

    public void setEstructurasjava(String estructurasjava) {
        this.estructurasjava = estructurasjava;
    }

    public String getEstructurascpp() {
        return estructurascpp;
    }

    public void setEstructurascpp(String estructurascpp) {
        this.estructurascpp = estructurascpp;
    }

    public String getEstructuraspy() {
        return estructuraspy;
    }

    public void setEstructuraspy(String estructuraspy) {
        this.estructuraspy = estructuraspy;
    }

    public String getBinarysearch() {
        return binarysearch;
    }

    public void setBinarysearch(String binarysearch) {
        this.binarysearch = binarysearch;
    }

    public String getExponentialsearch() {
        return exponentialsearch;
    }

    public void setExponentialsearch(String exponentialsearch) {
        this.exponentialsearch = exponentialsearch;
    }

    public String getArraymaxminsearch() {
        return arraymaxminsearch;
    }

    public void setArraymaxminsearch(String arraymaxminsearch) {
        this.arraymaxminsearch = arraymaxminsearch;
    }

    public String getFibonaccisearch() {
        return fibonaccisearch;
    }

    public void setFibonaccisearch(String fibonaccisearch) {
        this.fibonaccisearch = fibonaccisearch;
    }

    public String getJumpsearch() {
        return jumpsearch;
    }

    public void setJumpsearch(String jumpsearch) {
        this.jumpsearch = jumpsearch;
    }

    public String getMinabssumpair() {
        return minabssumpair;
    }

    public void setMinabssumpair(String minabssumpair) {
        this.minabssumpair = minabssumpair;
    }

    public String getMissingnosearch() {
        return missingnosearch;
    }

    public void setMissingnosearch(String missingnosearch) {
        this.missingnosearch = missingnosearch;
    }

    public String getPairdifferrencesearch() {
        return pairdifferrencesearch;
    }

    public void setPairdifferrencesearch(String pairdifferrencesearch) {
        this.pairdifferrencesearch = pairdifferrencesearch;
    }

    public String getTernarysearch() {
        return ternarysearch;
    }

    public void setTernarysearch(String ternarysearch) {
        this.ternarysearch = ternarysearch;
    }

    public String getRecursivebubblesort() {
        return recursivebubblesort;
    }

    public void setRecursivebubblesort(String recursivebubblesort) {
        this.recursivebubblesort = recursivebubblesort;
    }

    public String getQuicksort() {
        return quicksort;
    }

    public void setQuicksort(String quicksort) {
        this.quicksort = quicksort;
    }

    public String getRadixsort() {
        return radixsort;
    }

    public void setRadixsort(String radixsort) {
        this.radixsort = radixsort;
    }

    public String getShellsort() {
        return shellsort;
    }

    public void setShellsort(String shellsort) {
        this.shellsort = shellsort;
    }

    public String getTimsort() {
        return timsort;
    }

    public void setTimsort(String timsort) {
        this.timsort = timsort;
    }

    public String getTreesort() {
        return treesort;
    }

    public void setTreesort(String treesort) {
        this.treesort = treesort;
    }

    public String getMergesort() {
        return mergesort;
    }

    public void setMergesort(String mergesort) {
        this.mergesort = mergesort;
    }

    public String getBinaryinsertionsort() {
        return binaryinsertionsort;
    }

    public void setBinaryinsertionsort(String binaryinsertionsort) {
        this.binaryinsertionsort = binaryinsertionsort;
    }

    public String getBitonicsort() {
        return bitonicsort;
    }

    public void setBitonicsort(String bitonicsort) {
        this.bitonicsort = bitonicsort;
    }

    public String getCocktailsort() {
        return cocktailsort;
    }

    public void setCocktailsort(String cocktailsort) {
        this.cocktailsort = cocktailsort;
    }

    public String getCombsort() {
        return combsort;
    }

    public void setCombsort(String combsort) {
        this.combsort = combsort;
    }

    public String getCountingsort() {
        return countingsort;
    }

    public void setCountingsort(String countingsort) {
        this.countingsort = countingsort;
    }

    public String getCyclesort() {
        return cyclesort;
    }

    public void setCyclesort(String cyclesort) {
        this.cyclesort = cyclesort;
    }

    public String getMergesort3way() {
        return mergesort3way;
    }

    public void setMergesort3way(String mergesort3way) {
        this.mergesort3way = mergesort3way;
    }

    public String getPigeonholesort() {
        return pigeonholesort;
    }

    public void setPigeonholesort(String pigeonholesort) {
        this.pigeonholesort = pigeonholesort;
    }

    public String getAhocorasick() {
        return ahocorasick;
    }

    public void setAhocorasick(String ahocorasick) {
        this.ahocorasick = ahocorasick;
    }

    public String getAnagramspattern() {
        return anagramspattern;
    }

    public void setAnagramspattern(String anagramspattern) {
        this.anagramspattern = anagramspattern;
    }

    public String getBoyermoore() {
        return boyermoore;
    }

    public void setBoyermoore(String boyermoore) {
        this.boyermoore = boyermoore;
    }

    public String getFiniteautomata() {
        return finiteautomata;
    }

    public void setFiniteautomata(String finiteautomata) {
        this.finiteautomata = finiteautomata;
    }

    public String getKmpstringmatching() {
        return kmpstringmatching;
    }

    public void setKmpstringmatching(String kmpstringmatching) {
        this.kmpstringmatching = kmpstringmatching;
    }

    public String getManacheralgorithm() {
        return manacheralgorithm;
    }

    public void setManacheralgorithm(String manacheralgorithm) {
        this.manacheralgorithm = manacheralgorithm;
    }

    public String getRabinkarp() {
        return rabinkarp;
    }

    public void setRabinkarp(String rabinkarp) {
        this.rabinkarp = rabinkarp;
    }

    public String getWildcardpattern() {
        return wildcardpattern;
    }

    public void setWildcardpattern(String wildcardpattern) {
        this.wildcardpattern = wildcardpattern;
    }

    public String getGcdlcm() {
        return gcdlcm;
    }

    public void setGcdlcm(String gcdlcm) {
        this.gcdlcm = gcdlcm;
    }

    public String getPrimalitytest() {
        return primalitytest;
    }

    public void setPrimalitytest(String primalitytest) {
        this.primalitytest = primalitytest;
    }

    public String getPrimefactors() {
        return primefactors;
    }

    public void setPrimefactors(String primefactors) {
        this.primefactors = primefactors;
    }

    public String getDivisibilitybysmallnumbers() {
        return divisibilitybysmallnumbers;
    }

    public void setDivisibilitybysmallnumbers(String divisibilitybysmallnumbers) {
        this.divisibilitybysmallnumbers = divisibilitybysmallnumbers;
    }

    public String getNumberofdivisors() {
        return numberofdivisors;
    }

    public void setNumberofdivisors(String numberofdivisors) {
        this.numberofdivisors = numberofdivisors;
    }

    public String getPrimenumbers() {
        return primenumbers;
    }

    public void setPrimenumbers(String primenumbers) {
        this.primenumbers = primenumbers;
    }

    public String getFibonaccilastdigit() {
        return fibonaccilastdigit;
    }

    public void setFibonaccilastdigit(String fibonaccilastdigit) {
        this.fibonaccilastdigit = fibonaccilastdigit;
    }

    public String getLongfibonacci() {
        return longfibonacci;
    }

    public void setLongfibonacci(String longfibonacci) {
        this.longfibonacci = longfibonacci;
    }

    public String getIsfibonumber() {
        return isfibonumber;
    }

    public void setIsfibonumber(String isfibonumber) {
        this.isfibonumber = isfibonumber;
    }

    public String getAllpermutations() {
        return allpermutations;
    }

    public void setAllpermutations(String allpermutations) {
        this.allpermutations = allpermutations;
    }

    public String getCombination() {
        return combination;
    }

    public void setCombination(String combination) {
        this.combination = combination;
    }

    public String getCombinationscompose() {
        return combinationscompose;
    }

    public void setCombinationscompose(String combinationscompose) {
        this.combinationscompose = combinationscompose;
    }

    public String getAllsets() {
        return allsets;
    }

    public void setAllsets(String allsets) {
        this.allsets = allsets;
    }

    public String getHanoitowels() {
        return hanoitowels;
    }

    public void setHanoitowels(String hanoitowels) {
        this.hanoitowels = hanoitowels;
    }

    public String getAxplusbyequalsn() {
        return axplusbyequalsn;
    }

    public void setAxplusbyequalsn(String axplusbyequalsn) {
        this.axplusbyequalsn = axplusbyequalsn;
    }

    public String getAmodxequalb() {
        return amodxequalb;
    }

    public void setAmodxequalb(String amodxequalb) {
        this.amodxequalb = amodxequalb;
    }

    public String getFactorial() {
        return factorial;
    }

    public void setFactorial(String factorial) {
        this.factorial = factorial;
    }

    public String getBigfactorial() {
        return bigfactorial;
    }

    public void setBigfactorial(String bigfactorial) {
        this.bigfactorial = bigfactorial;
    }

    public String getBinomialcoefficients() {
        return binomialcoefficients;
    }

    public void setBinomialcoefficients(String binomialcoefficients) {
        this.binomialcoefficients = binomialcoefficients;
    }

    public String getCassiniidentity() {
        return cassiniidentity;
    }

    public void setCassiniidentity(String cassiniidentity) {
        this.cassiniidentity = cassiniidentity;
    }

    public String getEpowx() {
        return epowx;
    }

    public void setEpowx(String epowx) {
        this.epowx = epowx;
    }

    public String getEuclideulertheorem() {
        return euclideulertheorem;
    }

    public void setEuclideulertheorem(String euclideulertheorem) {
        this.euclideulertheorem = euclideulertheorem;
    }

    public String getEuclideanalgorithm() {
        return euclideanalgorithm;
    }

    public void setEuclideanalgorithm(String euclideanalgorithm) {
        this.euclideanalgorithm = euclideanalgorithm;
    }

    public String getEulertotient() {
        return eulertotient;
    }

    public void setEulertotient(String eulertotient) {
        this.eulertotient = eulertotient;
    }

    public String getFactorialnumdigits() {
        return factorialnumdigits;
    }

    public void setFactorialnumdigits(String factorialnumdigits) {
        this.factorialnumdigits = factorialnumdigits;
    }

    public String getFactorialnumdigitsop() {
        return factorialnumdigitsop;
    }

    public void setFactorialnumdigitsop(String factorialnumdigitsop) {
        this.factorialnumdigitsop = factorialnumdigitsop;
    }

    public String getFermatlittletheorem() {
        return fermatlittletheorem;
    }

    public void setFermatlittletheorem(String fermatlittletheorem) {
        this.fermatlittletheorem = fermatlittletheorem;
    }

    public String getFibonaccigoldenratio() {
        return fibonaccigoldenratio;
    }

    public void setFibonaccigoldenratio(String fibonaccigoldenratio) {
        this.fibonaccigoldenratio = fibonaccigoldenratio;
    }

    public String getFloatgcd() {
        return floatgcd;
    }

    public void setFloatgcd(String floatgcd) {
        this.floatgcd = floatgcd;
    }

    public String getFractionsproduct() {
        return fractionsproduct;
    }

    public void setFractionsproduct(String fractionsproduct) {
        this.fractionsproduct = fractionsproduct;
    }

    public String getJosephus() {
        return josephus;
    }

    public void setJosephus(String josephus) {
        this.josephus = josephus;
    }

    public String getCardinalnumbers() {
        return cardinalnumbers;
    }

    public void setCardinalnumbers(String cardinalnumbers) {
        this.cardinalnumbers = cardinalnumbers;
    }

    public String getRomannumbers() {
        return romannumbers;
    }

    public void setRomannumbers(String romannumbers) {
        this.romannumbers = romannumbers;
    }

    public String getGcdmultiple() {
        return gcdmultiple;
    }

    public void setGcdmultiple(String gcdmultiple) {
        this.gcdmultiple = gcdmultiple;
    }

    public String getHardyramanujantheorem() {
        return hardyramanujantheorem;
    }

    public void setHardyramanujantheorem(String hardyramanujantheorem) {
        this.hardyramanujantheorem = hardyramanujantheorem;
    }

    public String getHoaxnumber() {
        return hoaxnumber;
    }

    public void setHoaxnumber(String hoaxnumber) {
        this.hoaxnumber = hoaxnumber;
    }

    public String getLargestpowdividesfactorial() {
        return largestpowdividesfactorial;
    }

    public void setLargestpowdividesfactorial(String largestpowdividesfactorial) {
        this.largestpowdividesfactorial = largestpowdividesfactorial;
    }

    public String getLcmofarrayelements() {
        return lcmofarrayelements;
    }

    public void setLcmofarrayelements(String lcmofarrayelements) {
        this.lcmofarrayelements = lcmofarrayelements;
    }

    public String getLeonardonumber() {
        return leonardonumber;
    }

    public void setLeonardonumber(String leonardonumber) {
        this.leonardonumber = leonardonumber;
    }

    public String getModularexponentiation() {
        return modularexponentiation;
    }

    public void setModularexponentiation(String modularexponentiation) {
        this.modularexponentiation = modularexponentiation;
    }

    public String getMultipleeulertotient() {
        return multipleeulertotient;
    }

    public void setMultipleeulertotient(String multipleeulertotient) {
        this.multipleeulertotient = multipleeulertotient;
    }

    public String getNaturalcoprimesum() {
        return naturalcoprimesum;
    }

    public void setNaturalcoprimesum(String naturalcoprimesum) {
        this.naturalcoprimesum = naturalcoprimesum;
    }

    public String getZeckendorftheorem() {
        return zeckendorftheorem;
    }

    public void setZeckendorftheorem(String zeckendorftheorem) {
        this.zeckendorftheorem = zeckendorftheorem;
    }

    public String getRossertheorem() {
        return rossertheorem;
    }

    public void setRossertheorem(String rossertheorem) {
        this.rossertheorem = rossertheorem;
    }

    public String getSieveoderathosthenesoptimizated() {
        return sieveoderathosthenesoptimizated;
    }

    public void setSieveoderathosthenesoptimizated(String sieveoderathosthenesoptimizated) {
        this.sieveoderathosthenesoptimizated = sieveoderathosthenesoptimizated;
    }

    public String getSmithnumber() {
        return smithnumber;
    }

    public void setSmithnumber(String smithnumber) {
        this.smithnumber = smithnumber;
    }

    public String getSphenicnumber() {
        return sphenicnumber;
    }

    public void setSphenicnumber(String sphenicnumber) {
        this.sphenicnumber = sphenicnumber;
    }

    public String getCatalannumbers() {
        return catalannumbers;
    }

    public void setCatalannumbers(String catalannumbers) {
        this.catalannumbers = catalannumbers;
    }

    public String getCharmichaelnumbers() {
        return charmichaelnumbers;
    }

    public void setCharmichaelnumbers(String charmichaelnumbers) {
        this.charmichaelnumbers = charmichaelnumbers;
    }

    public String getSternbrocotsequence() {
        return sternbrocotsequence;
    }

    public void setSternbrocotsequence(String sternbrocotsequence) {
        this.sternbrocotsequence = sternbrocotsequence;
    }

    public String getSylvestersequence() {
        return sylvestersequence;
    }

    public void setSylvestersequence(String sylvestersequence) {
        this.sylvestersequence = sylvestersequence;
    }

    public String getAliquotsequence() {
        return aliquotsequence;
    }

    public void setAliquotsequence(String aliquotsequence) {
        this.aliquotsequence = aliquotsequence;
    }

    public String getJugglersequence() {
        return jugglersequence;
    }

    public void setJugglersequence(String jugglersequence) {
        this.jugglersequence = jugglersequence;
    }

    public String getMoserdebrujinsequence() {
        return moserdebrujinsequence;
    }

    public void setMoserdebrujinsequence(String moserdebrujinsequence) {
        this.moserdebrujinsequence = moserdebrujinsequence;
    }

    public String getNewmanconwaysequence() {
        return newmanconwaysequence;
    }

    public void setNewmanconwaysequence(String newmanconwaysequence) {
        this.newmanconwaysequence = newmanconwaysequence;
    }

    public String getPadovansequence() {
        return padovansequence;
    }

    public void setPadovansequence(String padovansequence) {
        this.padovansequence = padovansequence;
    }

    public String getRecamansequence() {
        return recamansequence;
    }

    public void setRecamansequence(String recamansequence) {
        this.recamansequence = recamansequence;
    }

    public String getArclength() {
        return arclength;
    }

    public void setArclength(String arclength) {
        this.arclength = arclength;
    }

    public String getAreacircularsector() {
        return areacircularsector;
    }

    public void setAreacircularsector(String areacircularsector) {
        this.areacircularsector = areacircularsector;
    }

    public String getArrangedcointriangle() {
        return arrangedcointriangle;
    }

    public void setArrangedcointriangle(String arrangedcointriangle) {
        this.arrangedcointriangle = arrangedcointriangle;
    }

    public String getCirclearea() {
        return circlearea;
    }

    public void setCirclearea(String circlearea) {
        this.circlearea = circlearea;
    }

    public String getCircumscribedcircleofequilateral() {
        return circumscribedcircleofequilateral;
    }

    public void setCircumscribedcircleofequilateral(String circumscribedcircleofequilateral) {
        this.circumscribedcircleofequilateral = circumscribedcircleofequilateral;
    }

    public String getConvexhull() {
        return convexhull;
    }

    public void setConvexhull(String convexhull) {
        this.convexhull = convexhull;
    }

    public String getCutssumatory() {
        return cutssumatory;
    }

    public void setCutssumatory(String cutssumatory) {
        this.cutssumatory = cutssumatory;
    }

    public String getHeronformula() {
        return heronformula;
    }

    public void setHeronformula(String heronformula) {
        this.heronformula = heronformula;
    }

    public String getRadiouscirclethreepoints() {
        return radiouscirclethreepoints;
    }

    public void setRadiouscirclethreepoints(String radiouscirclethreepoints) {
        this.radiouscirclethreepoints = radiouscirclethreepoints;
    }

    public String getDimensionrightangledtriangle() {
        return dimensionrightangledtriangle;
    }

    public void setDimensionrightangledtriangle(String dimensionrightangledtriangle) {
        this.dimensionrightangledtriangle = dimensionrightangledtriangle;
    }

    public String getHexagonarea() {
        return hexagonarea;
    }

    public void setHexagonarea(String hexagonarea) {
        this.hexagonarea = hexagonarea;
    }

    public String getAreaofpolygon() {
        return areaofpolygon;
    }

    public void setAreaofpolygon(String areaofpolygon) {
        this.areaofpolygon = areaofpolygon;
    }

    public String getLinelineintersection() {
        return linelineintersection;
    }

    public void setLinelineintersection(String linelineintersection) {
        this.linelineintersection = linelineintersection;
    }

    public String getLinemidpoint() {
        return linemidpoint;
    }

    public void setLinemidpoint(String linemidpoint) {
        this.linemidpoint = linemidpoint;
    }

    public String getLinethroughtwopoints() {
        return linethroughtwopoints;
    }

    public void setLinethroughtwopoints(String linethroughtwopoints) {
        this.linethroughtwopoints = linethroughtwopoints;
    }

    public String getMinimumheighttriangle() {
        return minimumheighttriangle;
    }

    public void setMinimumheighttriangle(String minimumheighttriangle) {
        this.minimumheighttriangle = minimumheighttriangle;
    }

    public String getPerimeterusingblocks() {
        return perimeterusingblocks;
    }

    public void setPerimeterusingblocks(String perimeterusingblocks) {
        this.perimeterusingblocks = perimeterusingblocks;
    }

    public String getPointinsidetriangle() {
        return pointinsidetriangle;
    }

    public void setPointinsidetriangle(String pointinsidetriangle) {
        this.pointinsidetriangle = pointinsidetriangle;
    }

    public String getRatiodivideline() {
        return ratiodivideline;
    }

    public void setRatiodivideline(String ratiodivideline) {
        this.ratiodivideline = ratiodivideline;
    }

    public String getRectanglesinnxm() {
        return rectanglesinnxm;
    }

    public void setRectanglesinnxm(String rectanglesinnxm) {
        this.rectanglesinnxm = rectanglesinnxm;
    }

    public String getSquaresintriangle2x2() {
        return squaresintriangle2x2;
    }

    public void setSquaresintriangle2x2(String squaresintriangle2x2) {
        this.squaresintriangle2x2 = squaresintriangle2x2;
    }

    public String getSumofmanhattan() {
        return sumofmanhattan;
    }

    public void setSumofmanhattan(String sumofmanhattan) {
        this.sumofmanhattan = sumofmanhattan;
    }

    public String getThreepointscollinear() {
        return threepointscollinear;
    }

    public void setThreepointscollinear(String threepointscollinear) {
        this.threepointscollinear = threepointscollinear;
    }

    public String getTriangleangles() {
        return triangleangles;
    }

    public void setTriangleangles(String triangleangles) {
        this.triangleangles = triangleangles;
    }

    public String getAddone() {
        return addone;
    }

    public void setAddone(String addone) {
        this.addone = addone;
    }

    public String getBinarypalindromen() {
        return binarypalindromen;
    }

    public void setBinarypalindromen(String binarypalindromen) {
        this.binarypalindromen = binarypalindromen;
    }

    public String getBoothmultyply() {
        return boothmultyply;
    }

    public void setBoothmultyply(String boothmultyply) {
        this.boothmultyply = boothmultyply;
    }

    public String getClosestnumberssamebits() {
        return closestnumberssamebits;
    }

    public void setClosestnumberssamebits(String closestnumberssamebits) {
        this.closestnumberssamebits = closestnumberssamebits;
    }

    public String getCodeconversiongraytobinary() {
        return codeconversiongraytobinary;
    }

    public void setCodeconversiongraytobinary(String codeconversiongraytobinary) {
        this.codeconversiongraytobinary = codeconversiongraytobinary;
    }

    public String getCountatob() {
        return countatob;
    }

    public void setCountatob(String countatob) {
        this.countatob = countatob;
    }

    public String getCountsetbits() {
        return countsetbits;
    }

    public void setCountsetbits(String countsetbits) {
        this.countsetbits = countsetbits;
    }

    public String getEuclidnomodanddivide() {
        return euclidnomodanddivide;
    }

    public void setEuclidnomodanddivide(String euclidnomodanddivide) {
        this.euclidnomodanddivide = euclidnomodanddivide;
    }

    public String getFindduplicatesbitarray() {
        return findduplicatesbitarray;
    }

    public void setFindduplicatesbitarray(String findduplicatesbitarray) {
        this.findduplicatesbitarray = findduplicatesbitarray;
    }

    public String getGreycodesofn() {
        return greycodesofn;
    }

    public void setGreycodesofn(String greycodesofn) {
        this.greycodesofn = greycodesofn;
    }

    public String getKaratsubamultiply() {
        return karatsubamultiply;
    }

    public void setKaratsubamultiply(String karatsubamultiply) {
        this.karatsubamultiply = karatsubamultiply;
    }

    public String getMaxconsecutiveone() {
        return maxconsecutiveone;
    }

    public void setMaxconsecutiveone(String maxconsecutiveone) {
        this.maxconsecutiveone = maxconsecutiveone;
    }

    public String getMassubarrayxor() {
        return massubarrayxor;
    }

    public void setMassubarrayxor(String massubarrayxor) {
        this.massubarrayxor = massubarrayxor;
    }

    public String getMultiplybyseven() {
        return multiplybyseven;
    }

    public void setMultiplybyseven(String multiplybyseven) {
        this.multiplybyseven = multiplybyseven;
    }

    public String getNmagicnumber() {
        return nmagicnumber;
    }

    public void setNmagicnumber(String nmagicnumber) {
        this.nmagicnumber = nmagicnumber;
    }

    public String getNsquarenopow() {
        return nsquarenopow;
    }

    public void setNsquarenopow(String nsquarenopow) {
        this.nsquarenopow = nsquarenopow;
    }

    public String getOddevenswap() {
        return oddevenswap;
    }

    public void setOddevenswap(String oddevenswap) {
        this.oddevenswap = oddevenswap;
    }

    public String getOddoccurrence() {
        return oddoccurrence;
    }

    public void setOddoccurrence(String oddoccurrence) {
        this.oddoccurrence = oddoccurrence;
    }

    public String getOppositesigns() {
        return oppositesigns;
    }

    public void setOppositesigns(String oppositesigns) {
        this.oppositesigns = oppositesigns;
    }

    public String getPandigitalconcatenations() {
        return pandigitalconcatenations;
    }

    public void setPandigitalconcatenations(String pandigitalconcatenations) {
        this.pandigitalconcatenations = pandigitalconcatenations;
    }

    public String getPoweroffour() {
        return poweroffour;
    }

    public void setPoweroffour(String poweroffour) {
        this.poweroffour = poweroffour;
    }

    public String getRussianpeasantmultiply() {
        return russianpeasantmultiply;
    }

    public void setRussianpeasantmultiply(String russianpeasantmultiply) {
        this.russianpeasantmultiply = russianpeasantmultiply;
    }

    public String getAdyacencymatrix() {
        return adyacencymatrix;
    }

    public void setAdyacencymatrix(String adyacencymatrix) {
        this.adyacencymatrix = adyacencymatrix;
    }

    public String getListadyacency() {
        return listadyacency;
    }

    public void setListadyacency(String listadyacency) {
        this.listadyacency = listadyacency;
    }

    public String getBfs() {
        return bfs;
    }

    public void setBfs(String bfs) {
        this.bfs = bfs;
    }

    public String getBfsallpaths() {
        return bfsallpaths;
    }

    public void setBfsallpaths(String bfsallpaths) {
        this.bfsallpaths = bfsallpaths;
    }

    public String getBinarygraphshortestpath() {
        return binarygraphshortestpath;
    }

    public void setBinarygraphshortestpath(String binarygraphshortestpath) {
        this.binarygraphshortestpath = binarygraphshortestpath;
    }

    public String getCountallpaths() {
        return countallpaths;
    }

    public void setCountallpaths(String countallpaths) {
        this.countallpaths = countallpaths;
    }

    public String getCycleinadirectedgraph() {
        return cycleinadirectedgraph;
    }

    public void setCycleinadirectedgraph(String cycleinadirectedgraph) {
        this.cycleinadirectedgraph = cycleinadirectedgraph;
    }

    public String getDfs() {
        return dfs;
    }

    public void setDfs(String dfs) {
        this.dfs = dfs;
    }

    public String getDfstransitiveclosure() {
        return dfstransitiveclosure;
    }

    public void setDfstransitiveclosure(String dfstransitiveclosure) {
        this.dfstransitiveclosure = dfstransitiveclosure;
    }

    public String getDisconnectedgraphbfs() {
        return disconnectedgraphbfs;
    }

    public void setDisconnectedgraphbfs(String disconnectedgraphbfs) {
        this.disconnectedgraphbfs = disconnectedgraphbfs;
    }

    public String getEuleriancycledirectedgraph() {
        return euleriancycledirectedgraph;
    }

    public void setEuleriancycledirectedgraph(String euleriancycledirectedgraph) {
        this.euleriancycledirectedgraph = euleriancycledirectedgraph;
    }

    public String getEulerianpathundirectedgraph() {
        return eulerianpathundirectedgraph;
    }

    public void setEulerianpathundirectedgraph(String eulerianpathundirectedgraph) {
        this.eulerianpathundirectedgraph = eulerianpathundirectedgraph;
    }

    public String getFloydwarshall() {
        return floydwarshall;
    }

    public void setFloydwarshall(String floydwarshall) {
        this.floydwarshall = floydwarshall;
    }

    public String getHamiltonniancycle() {
        return hamiltonniancycle;
    }

    public void setHamiltonniancycle(String hamiltonniancycle) {
        this.hamiltonniancycle = hamiltonniancycle;
    }

    public String getKahnalgorithmtopologicalsorting() {
        return kahnalgorithmtopologicalsorting;
    }

    public void setKahnalgorithmtopologicalsorting(String kahnalgorithmtopologicalsorting) {
        this.kahnalgorithmtopologicalsorting = kahnalgorithmtopologicalsorting;
    }

    public String getKnighttourbacktracking() {
        return knighttourbacktracking;
    }

    public void setKnighttourbacktracking(String knighttourbacktracking) {
        this.knighttourbacktracking = knighttourbacktracking;
    }

    public String getKosarajudfsstronglyconnected() {
        return kosarajudfsstronglyconnected;
    }

    public void setKosarajudfsstronglyconnected(String kosarajudfsstronglyconnected) {
        this.kosarajudfsstronglyconnected = kosarajudfsstronglyconnected;
    }

    public String getKruskalmst() {
        return kruskalmst;
    }

    public void setKruskalmst(String kruskalmst) {
        this.kruskalmst = kruskalmst;
    }

    public String getMinimummovesknight() {
        return minimummovesknight;
    }

    public void setMinimummovesknight(String minimummovesknight) {
        this.minimummovesknight = minimummovesknight;
    }

    public String getNqueenproblem() {
        return nqueenproblem;
    }

    public void setNqueenproblem(String nqueenproblem) {
        this.nqueenproblem = nqueenproblem;
    }

    public String getPrimmstfull() {
        return primmstfull;
    }

    public void setPrimmstfull(String primmstfull) {
        this.primmstfull = primmstfull;
    }

    public String getTopologicalsorting() {
        return topologicalsorting;
    }

    public void setTopologicalsorting(String topologicalsorting) {
        this.topologicalsorting = topologicalsorting;
    }

    public String getUnionfind() {
        return unionfind;
    }

    public void setUnionfind(String unionfind) {
        this.unionfind = unionfind;
    }

    public String getDominodfs() {
        return dominodfs;
    }

    public void setDominodfs(String dominodfs) {
        this.dominodfs = dominodfs;
    }

    public String getExitthemazebfs() {
        return exitthemazebfs;
    }

    public void setExitthemazebfs(String exitthemazebfs) {
        this.exitthemazebfs = exitthemazebfs;
    }

    public String getBellmanfordsp() {
        return bellmanfordsp;
    }

    public void setBellmanfordsp(String bellmanfordsp) {
        this.bellmanfordsp = bellmanfordsp;
    }

    public String getDijkstrasp() {
        return dijkstrasp;
    }

    public void setDijkstrasp(String dijkstrasp) {
        this.dijkstrasp = dijkstrasp;
    }

    public String getBipartitegraph() {
        return bipartitegraph;
    }

    public void setBipartitegraph(String bipartitegraph) {
        this.bipartitegraph = bipartitegraph;
    }

    public String getKnapsackrecursive() {
        return knapsackrecursive;
    }

    public void setKnapsackrecursive(String knapsackrecursive) {
        this.knapsackrecursive = knapsackrecursive;
    }

    public String getCoinexchange() {
        return coinexchange;
    }

    public void setCoinexchange(String coinexchange) {
        this.coinexchange = coinexchange;
    }

    public String getLongestincreasingsubsequence() {
        return longestincreasingsubsequence;
    }

    public void setLongestincreasingsubsequence(String longestincreasingsubsequence) {
        this.longestincreasingsubsequence = longestincreasingsubsequence;
    }

    public String getLongestcommonsubstring() {
        return longestcommonsubstring;
    }

    public void setLongestcommonsubstring(String longestcommonsubstring) {
        this.longestcommonsubstring = longestcommonsubstring;
    }

    public String getPascaltriangle() {
        return pascaltriangle;
    }

    public void setPascaltriangle(String pascaltriangle) {
        this.pascaltriangle = pascaltriangle;
    }

    public String getCicloscpp() {
        return cicloscpp;
    }

    public void setCicloscpp(String cicloscpp) {
        this.cicloscpp = cicloscpp;
    }

    public String getCiclospy() {
        return ciclospy;
    }

    public void setCiclospy(String ciclospy) {
        this.ciclospy = ciclospy;
    }
    

}
