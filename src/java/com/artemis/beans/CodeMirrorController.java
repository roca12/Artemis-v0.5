package com.artemis.beans;

import java.io.Serializable;
import javax.faces.bean.ManagedBean;
import javax.faces.bean.ViewScoped;

@ManagedBean(name = "codemirror")
@ViewScoped
public class CodeMirrorController implements Serializable {

    private String ciclosjava = "import java.io.BufferedReader;\n"
            + "import java.io.IOException;\n"
            + "import java.io.InputStreamReader;\n"
            + "import java.util.Scanner;\n"
            + "\n"
            + "public class LecturaEscritura {\n"
            + "//Variables Globales\n"
            + "    static int númeroentero;\n"
            + "    static long númeroenterolargo;\n"
            + "    static float númerodecimal;\n"
            + "    static double númerodecimallargo;\n"
            + "    static char caracter;\n"
            + "    static String cadena;\n"
            + "    static byte bits;\n"
            + "\n"
            + "    public static void main(String[] args) throws IOException {\n"
            + "System.out.println(\"Lectura\\n\");\n"
            + "        lecturaLenta();\n"
            + "        lecturaRapida();\n"
            + "        System.out.println(\"\");\n"
            + "        System.out.println(\"Impresión \\n\");\n"
            + "        impresionNormal();\n"
            + "        impresionConFormato();\n"
            + "}\n"
            + "\n"
            + "    static void lecturaLenta() {\n"
            + "//Objeto lector\n"
            + "        Scanner sc = new Scanner(System.in);\n"
            + "//Lectura con tipo especificado\n"
            + "        númeroentero = sc.nextInt();\n"
            + "númeroenterolargo = sc.nextLong();\n"
            + "        númerodecimal = sc.nextFloat();\n"
            + "        númerodecimallargo = sc.nextDouble();\n"
            + "        caracter = sc.next().charAt(0);\n"
            + "        cadena = sc.next();\n"
            + "        bits = sc.nextByte();\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    static void lecturaRapida() throws IOException {\n"
            + "//Objeto lector\n"
            + "        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n"
            + "//Lectura como cadena y conversión a tipo\n"
            + "        númeroentero = Integer.parseInt(br.readLine());\n"
            + "        númeroenterolargo = Long.parseLong(br.readLine());\n"
            + "        númerodecimal = Float.parseFloat(br.readLine());\n"
            + "númerodecimallargo = Double.parseDouble(br.readLine());\n"
            + "        caracter = br.readLine().charAt(0);\n"
            + "        cadena = br.readLine();\n"
            + "        bits = Byte.parseByte(br.readLine());\n"
            + "    }\n"
            + "\n"
            + "    static void impresionNormal() {\n"
            + "        System.out.println(númeroentero);\n"
            + "        System.out.println(númeroenterolargo);\n"
            + "        System.out.println(númerodecimal);\n"
            + "        System.out.println(númerodecimallargo);\n"
            + "        System.out.println(caracter);\n"
            + "        System.out.println(cadena);\n"
            + "        System.out.println(bits);\n"
            + "}\n"
            + "\n"
            + "    static void impresionConFormato() {\n"
            + "//Se especifica el tipo de dato o la forma en que se imprimira\n"
            + "        System.out.printf(\"%d \\n\",númeroentero);\n"
            + "        System.out.printf(\"%d \\n\",númeroenterolargo);\n"
            + "        System.out.printf(\"%f \\n\",númerodecimal);\n"
            + "        System.out.printf(\"%e \\n\",númerodecimal);\n"
            + "        System.out.printf(\"%f \\n\",númerodecimallargo);\n"
            + "        System.out.printf(\"%e \\n\",númerodecimallargo);\n"
            + "System.out.printf(\"%s \\n\",caracter);\n"
            + "        System.out.printf(\"%s \\n\",cadena);\n"
            + "        System.out.printf(\"%s \\n\",bits);\n"
            + "}\n"
            + "}";
    private String lecturajava = "import java.io.BufferedReader;\n"
            + "import java.io.IOException;\n"
            + "import java.io.InputStreamReader;\n"
            + "import java.util.Scanner;\n"
            + "\n"
            + "public class LecturaEscritura {\n"
            + "//Variables Globales\n"
            + "    static int númeroentero;\n"
            + "    static long númeroenterolargo;\n"
            + "    static float númerodecimal;\n"
            + "    static double númerodecimallargo;\n"
            + "    static char caracter;\n"
            + "    static String cadena;\n"
            + "    static byte bits;\n"
            + "\n"
            + "    public static void main(String[] args) throws IOException {\n"
            + "System.out.println(\"Lectura\\n\");\n"
            + "        lecturaLenta();\n"
            + "        lecturaRapida();\n"
            + "        System.out.println(\"\");\n"
            + "        System.out.println(\"Impresión \\n\");\n"
            + "        impresionNormal();\n"
            + "        impresionConFormato();\n"
            + "}\n"
            + "\n"
            + "    static void lecturaLenta() {\n"
            + "//Objeto lector\n"
            + "        Scanner sc = new Scanner(System.in);\n"
            + "//Lectura con tipo especificado\n"
            + "        númeroentero = sc.nextInt();\n"
            + "númeroenterolargo = sc.nextLong();\n"
            + "        númerodecimal = sc.nextFloat();\n"
            + "        númerodecimallargo = sc.nextDouble();\n"
            + "        caracter = sc.next().charAt(0);\n"
            + "        cadena = sc.next();\n"
            + "        bits = sc.nextByte();\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    static void lecturaRapida() throws IOException {\n"
            + "//Objeto lector\n"
            + "        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n"
            + "//Lectura como cadena y conversión a tipo\n"
            + "        númeroentero = Integer.parseInt(br.readLine());\n"
            + "        númeroenterolargo = Long.parseLong(br.readLine());\n"
            + "        númerodecimal = Float.parseFloat(br.readLine());\n"
            + "númerodecimallargo = Double.parseDouble(br.readLine());\n"
            + "        caracter = br.readLine().charAt(0);\n"
            + "        cadena = br.readLine();\n"
            + "        bits = Byte.parseByte(br.readLine());\n"
            + "    }\n"
            + "\n"
            + "    static void impresionNormal() {\n"
            + "        System.out.println(númeroentero);\n"
            + "        System.out.println(númeroenterolargo);\n"
            + "        System.out.println(númerodecimal);\n"
            + "        System.out.println(númerodecimallargo);\n"
            + "        System.out.println(caracter);\n"
            + "        System.out.println(cadena);\n"
            + "        System.out.println(bits);\n"
            + "}\n"
            + "\n"
            + "    static void impresionConFormato() {\n"
            + "//Se especifica el tipo de dato o la forma en que se imprimira\n"
            + "        System.out.printf(\"%d \\n\",númeroentero);\n"
            + "        System.out.printf(\"%d \\n\",númeroenterolargo);\n"
            + "        System.out.printf(\"%f \\n\",númerodecimal);\n"
            + "        System.out.printf(\"%e \\n\",númerodecimal);\n"
            + "        System.out.printf(\"%f \\n\",númerodecimallargo);\n"
            + "        System.out.printf(\"%e \\n\",númerodecimallargo);\n"
            + "System.out.printf(\"%s \\n\",caracter);\n"
            + "        System.out.printf(\"%s \\n\",cadena);\n"
            + "        System.out.printf(\"%s \\n\",bits);\n"
            + "}\n"
            + "}", lecturacpp = "//Unicas 2 librerias que se usan en c++ (Contienen todas)\n"
            + "#include<bits/stdc++.h>\n"
            + "#include<cstdlib>\n"
            + "using namespace std;\n"
            + "//variables globales\n"
            + "int númeroentero;\n"
            + "long númeroenterolargo;\n"
            + "float númerodecimal;\n"
            + "double númerodecimallargo;\n"
            + "char caracter;\n"
            + "string cadena;\n"
            + "\n"
            + "void lecturaLenta() {\n"
            + "	//Lectura con tipo especificado\n"
            + "	cin>>númeroentero;\n"
            + "	cin>>númeroenterolargo;\n"
            + "	cin>>númerodecimal;\n"
            + "	cin>>númerodecimallargo;\n"
            + "	cin>>caracter;\n"
            + "	cin>>cadena;\n"
            + "}\n"
            + "void lecturaRapida() {\n"
            + "	//Lectura como cadena y conversión a tipo (En c++ & es necesario)\n"
            + "	scanf(\"%d\",&númeroentero);\n"
            + "	scanf(\"%lld\",&númeroenterolargo);\n"
            + "	scanf(\"%f\",&númerodecimal);\n"
            + "	scanf(\"%lf\",&númerodecimallargo);\n"
            + "	scanf(\"%s\",&caracter);\n"
            + "	scanf(\"%s\",cadena.c_str());\n"
            + "}\n"
            + "void impresionNormal() {\n"
            + "	cout<<númeroentero<<endl;\n"
            + "	cout<<númeroenterolargo<<endl;\n"
            + "	cout<<númerodecimal<<endl;\n"
            + "	cout<<númerodecimallargo<<endl;\n"
            + "	cout<<caracter<<endl;\n"
            + "	cout<<cadena<<endl;\n"
            + "}\n"
            + " void impresionConFormato() {\n"
            + "	//Se especifica el tipo de dato o la forma en que se imprimira\n"
            + "	printf(\"%d \\n\",númeroentero);\n"
            + "	printf(\"%lld \\n\",númeroenterolargo);\n"
            + "	printf(\"%f \\n\",númerodecimal);\n"
            + "	printf(\"%e \\n\",númerodecimal);\n"
            + "	printf(\"%lf \\n\",númerodecimallargo);\n"
            + "	printf(\"%e \\n\",númerodecimallargo);\n"
            + "	printf(\"%c \\n\",caracter);\n"
            + "	printf(\"%s \\n\",cadena.c_str());\n"
            + "}\n"
            + "	\n"
            + "int main (int argc, char *argv[]) {\n"
            + "	cout<<\"Lectura\\n\"<<endl;\n"
            + "	lecturaLenta();\n"
            + "	cout<<\"Impresión \\n\"<<endl;\n"
            + "	impresionNormal();\n"
            + "	cout<<endl;\n"
            + "	cout<<\"Lectura\\n\"<<endl;\n"
            + "	lecturaRapida();\n"
            + "	cout<<\"Impresión \\n\"<<endl;\n"
            + "	impresionConFormato();\n"
            + "	return 0;\n"
            + "}	", lecturapy = "#Los comentarios en Python se usa el # (Numeral)\n"
            + "#variables globales\n"
            + "#la identación define el orden\n"
            + "númeroentero=int(0)\n"
            + "númeroenterolargo=int(0)\n"
            + "númerodecimal=float(0)\n"
            + "númerodecimallargo=float(0)\n"
            + "caracter=''\n"
            + "cadena=\"\"\n"
            + "print(\"Lectura\")\n"
            + "#Lectura con tipo especificado\n"
            + "númeroentero=int(input())\n"
            + "númeroenterolargo=int(input())\n"
            + "númerodecimal=float(input())\n"
            + "númerodecimallargo=float(input())\n"
            + "caracter=input()\n"
            + "cadena=str(input())\n"
            + "print(\"Impresión\")\n"
            + "print(númeroentero)\n"
            + "print(númeroenterolargo)\n"
            + "print(númerodecimal)\n"
            + "print(númerodecimallargo)\n"
            + "print(caracter)\n"
            + "print(cadena)\n"
            + "print(\"Impresión formateada\")\n"
            + "#Se especifica el tipo de dato o la forma en que se imprimira\n"
            + "#obligatorio usar el % \n"
            + "print(\"%d\" % númeroentero)\n"
            + "print(\"%d\" % númeroenterolargo)\n"
            + "print(\"%f\" %númerodecimal)\n"
            + "print(\"%e\"%númerodecimal)\n"
            + "print(\"%f\"%númerodecimallargo)\n"
            + "print(\"%e\"%númerodecimallargo)\n"
            + "print(\"%c\"%caracter)\n"
            + "print(\"%s\"%cadena)";
    private String condicionalesjava = "JAVA\n"
            + "import java.util.Scanner;\n"
            + "public class CondicionalesCiclos {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        Scanner sc = new Scanner(System.in);\n"
            + "//Lectura \n"
            + "int número = sc.nextInt();\n"
            + "//Estructura de un condicional\n"
            + "//Dentro el parentesis va la condicion a revisar\n"
            + "        //Si se cumple se realiza las siguientes lineas\n"
            + "        //En caso contrario pasa al else \n"
            + "        //y se realiza las lineas siguientes del else\n"
            + "        if (número % 2 == 0) {\n"
            + "            System.out.println(\"Es par\");\n"
            + "} else {\n"
            + "            System.out.println(\"Es impar\");\n"
            + "        }\n"
            + "        System.out.println(\"\");\n"
            + "        System.out.println(\"Ciclo for \");\n"
            + "// variable iteradora, condicion , acumulador\n"
            + "        for (int i = 0; i < 10; i++) {\n"
            + "            System.out.println(i);\n"
            + "        }\n"
            + "        System.out.println(\"Ciclo while\");\n"
            + "//Variable, condicion, al final acumulador\n"
            + "        int acumulador = 0;\n"
            + "        while (acumulador < 10) {\n"
            + "            System.out.println(acumulador);\n"
            + "            acumulador++;\n"
            + "\n"
            + "        }\n"
            + "        System.out.println(\"Ciclo do while\");\n"
            + "//Haga hasta que una condición se cumpla\n"
            + "        acumulador = 0;\n"
            + "        do {\n"
            + "            System.out.println(acumulador);\n"
            + "            acumulador++;\n"
            + "        } while (acumulador < 10);\n"
            + "        System.out.println(\"Ciclo for each\");\n"
            + "//Iterar entre todos los elementos que tenga una estructura\n"
            + "        //Sin importar el tamaño \n"
            + "        int números[] = {1,2,3,4,5,6,7,8,9,0};\n"
            + "for (int o : números) {\n"
            + "            System.out.println(o);\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "}", condicionalescpp = "#include<bits/stdc++.h>\n"
            + "#include<cstdlib>\n"
            + "using namespace std;\n"
            + "\n"
            + "int main (int argc, char *argv[]) {\n"
            + "	\n"
            + "	int número;\n"
            + "	cin>>número;\n"
            + "	//Estructura de un condicional\n"
            + "	//Dentro el parentesis va la condicion a revisar\n"
            + "	//Si se cumple se realiza las siguientes lineas\n"
            + "	//En caso contrario pasa al else \n"
            + "	//y se realiza las lineas siguientes del else\n"
            + "	if (número % 2 == 0) {\n"
            + "		cout<<\"Es par\"<<endl;\n"
            + "	} else {\n"
            + "		cout<<\"Es impar\"<<endl;\n"
            + "	}\n"
            + "	cout<<endl;\n"
            + "	cout<<\"Ciclo for \"<<endl;\n"
            + "	// variable iteradora, condicion , acumulador\n"
            + "	for (int i = 0; i < 10; i++) {\n"
            + "		cout<<i<<endl;\n"
            + "	}\n"
            + "	cout<<\"Ciclo while\"<<endl;\n"
            + "	//Variable, condicion, al final acumulador\n"
            + "	int acumulador = 0;\n"
            + "	while (acumulador < 10) {\n"
            + "		cout<<acumulador<<endl;;\n"
            + "		acumulador++;\n"
            + "		\n"
            + "	}\n"
            + "	cout<<\"Ciclo do while\"<<endl;\n"
            + "	//Haga hasta que una condición se cumpla\n"
            + "	acumulador = 0;\n"
            + "	do {\n"
            + "		cout<<acumulador<<endl;\n"
            + "		acumulador++;\n"
            + "	} while (acumulador < 10);\n"
            + "	cout<<\"Ciclo for each\"<<endl;\n"
            + "	//Iterar entre todos los elementos que tenga una estructura\n"
            + "	//Sin importar el tamaño \n"
            + "	int números[] = {1,2,3,4,5,6,7,8,9,0};\n"
            + "	for (int o : números) {\n"
            + "		cout<<o<<endl;\n"
            + "	}\n"
            + "	return 0;\n"
            + "}	", condicionalespy = "numero=0;\n"
            + "numero =int(input())\n"
            + "#Estructura de un condicional\n"
            + "#Dentro el parentesis va la condicion a revisar\n"
            + "#Si se cumple se realiza las siguientes lineas\n"
            + "#En caso contrario pasa al else \n"
            + "#y se realiza las lineas siguientes del else\n"
            + "if (numero % 2 == 0):\n"
            + "    print(\"Es par\")\n"
            + "else: \n"
            + "    print(\"Es impar\")\n"
            + "print(\"Ciclo for \")\n"
            + "#variable iteradora, rango inicio,final\n"
            + "for i in range (0,10):\n"
            + "    print(i)\n"
            + "print(\"Ciclo while\")\n"
            + "#Variable, condicion, al final acumulador\n"
            + "acumulador = 0;\n"
            + "while (acumulador < 10):\n"
            + "    print(acumulador)\n"
            + "    acumulador=acumulador+1;\n"
            + "print(\"Ciclo for each\")\n"
            + "#Iterar entre todos los elementos que tenga una estructura\n"
            + "#Sin importar el tamaño \n"
            + "numeros =[1,2,3,4,5,6,7,8,9,0]\n"
            + "for o in numeros:\n"
            + "    print(o)";
    private String excepcionesjava = "import java.util.Scanner;\n"
            + "public class ControlExcep {\n"
            + "    public static void main(String[] args) {\n"
            + "        Scanner sc = new Scanner(System.in);\n"
            + "int número;\n"
            + "//Intenta guardar el dato en la variable\n"
            + "        //Si falla controla la excepcion y \n"
            + "        //realiza otra cosa sin terminar la ejecución\n"
            + "try {\n"
            + "            número=sc.nextInt();\n"
            + "            System.out.println(número);\n"
            + "} catch (Exception e) {\n"
            + "            System.out.println(\"El dato insertado no es un número\");\n"
            + "            System.out.println(\"O es muy grande para un tipo int\");\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "}", excepcionespy = "número=0\n"
            + "#Intenta guardar el dato en la variable\n"
            + "#Si falla controla la excepción y \n"
            + "#realiza otra cosa sin terminar la ejecución\n"
            + "try:\n"
            + "    número=int(input())\n"
            + "    print (número)\n"
            + "except:\n"
            + "    print (\"El dato insertado no es un número\")\n"
            + "    print (\"O es muy grande para un tipo int\")\n"
            + "";
    private String tiempoejecucion = "/*Calculo del tiempo de ejecución de un ciclo de 100000 números\n"
            + "Varia de maquina en maquina, y dependiendo de lo que se \n"
            + "encuentre en ejecución en la maquina*/\n"
            + "public class CalculoTiempo {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        long timeBefore = System.currentTimeMillis();\n"
            + "        final int N =100000;\n"
            + "        for (int i = 0; i <= N; i++) {\n"
            + "            System.out.println(i);\n"
            + "        }\n"
            + "        long timeAfter = System.currentTimeMillis();\n"
            + "        System.out.println((timeAfter-timeBefore)+\"ms\");\n"
            + "}\n"
            + "}";
    private String estructurasjava = "import java.util.*;\n"
            + "\n"
            + "public class Main {\n"
            + "\n"
            + "    public static Random r = new Random();\n"
            + "    public static int i, j;\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        Scanner sc = new Scanner(System.in);\n"
            + "System.out.println(\"Inserte cantidad de datos\");\n"
            + "        int n = sc.nextInt();\n"
            + "        System.out.println(\"Que estructura quiere utilizar? (Los números son aleatorios\");\n"
            + "        System.out.println(\"1) Vector fijo \");\n"
            + "        System.out.println(\"2) Vector dinamico\");\n"
            + "        System.out.println(\"3) Vector sin repeticion\");\n"
            + "        System.out.println(\"4) Matriz\");\n"
            + "        System.out.println(\"5) Diccionario\");\n"
            + "        System.out.println(\"6) Pila\");\n"
            + "System.out.println(\"7) Cola\");\n"
            + "        int aux = sc.nextInt();\n"
            + "        switch (aux) {\n"
            + "            case 1:\n"
            + "                vectorfijo(n);\n"
            + "                break;\n"
            + "            case 2:\n"
            + "                vectordinamico(n);\n"
            + "                break;\n"
            + "            case 3:\n"
            + "                vectorsinrepeticion(n);\n"
            + "                break;\n"
            + "            case 4:\n"
            + "matriz(n);\n"
            + "                break;\n"
            + "            case 5:\n"
            + "                Diccionario(n);\n"
            + "break;\n"
            + "            case 6:\n"
            + "                pila(n);\n"
            + "                break;\n"
            + "            case 7:\n"
            + "                cola(n);\n"
            + "                break;\n"
            + "\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void vectordinamico(int n) {\n"
            + "        ArrayList<Integer> arreglo = new ArrayList<>();\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            arreglo.add(r.nextInt());\n"
            + "        }\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            System.out.println(arreglo.get(i));\n"
            + "\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    public static void vectorfijo(int n) {\n"
            + "        int[] números = new int[n];\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            números[i] = r.nextInt();\n"
            + "        }\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            System.out.println(números[i]);\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    public static void matriz(int n) {\n"
            + "        int[][] matrix = new int[n][n];\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            for (j = 0; j < n; j++) {\n"
            + "                matrix[i][j] = r.nextInt(50);\n"
            + "\n"
            + "            }\n"
            + "        }\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            for (j = 0; j < n; j++) {\n"
            + "                System.out.print(matrix[i][j] + \" \");\n"
            + "\n"
            + "            }\n"
            + "            System.out.println(\"\");\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void vectorsinrepeticion(int n) {\n"
            + "        HashSet<Integer> sinrep = new HashSet<>();\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            sinrep.add(r.nextInt(50));\n"
            + "        }\n"
            + "        Iterator it = sinrep.iterator();\n"
            + "        while (it.hasNext()) {\n"
            + "            System.out.println(it.next());\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void Diccionario(int n) {\n"
            + "        HashMap<Integer, String> dicc = new HashMap<>();\n"
            + "        char letra = 'a';\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            dicc.put(r.nextInt(), letra + \"\");\n"
            + "            int aux = (int) letra;\n"
            + "            aux++;\n"
            + "            letra = (char) aux;\n"
            + "        }\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            System.out.println(dicc.get(i) + \"\");\n"
            + "\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    public static void pila(int n) {\n"
            + "        Stack<Integer> mipila = new Stack<>();\n"
            + "\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            mipila.push(r.nextInt(50));\n"
            + "        }\n"
            + "        while (!mipila.isEmpty()) {\n"
            + "            System.out.println(mipila.pop());\n"
            + "\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    public static void cola(int n) {\n"
            + "        Queue<Integer> micola = new LinkedList<>();\n"
            + "\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            micola.offer(r.nextInt(50));\n"
            + "        }\n"
            + "        while (!micola.isEmpty()) {\n"
            + "            System.out.println(micola.poll());\n"
            + "\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "}", estructurascpp = "#include<bits/stdc++.h>\n"
            + "#include<cstdlib>\n"
            + "using namespace std;\n"
            + "\n"
            + "int i, j;\n"
            + "\n"
            + "void vectordinamico(int n) {\n"
            + "	vector<int> arreglo;\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		arreglo.push_back(rand()%100);\n"
            + "	}\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		cout<<arreglo.at(i)<<endl;\n"
            + "		\n"
            + "	}\n"
            + "	\n"
            + "}\n"
            + "\n"
            + "void vectorfijo(int n) {\n"
            + "	int números[n];\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		números[i] = rand()%100;\n"
            + "	}\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		cout<<números[i]<<endl;;\n"
            + "	}\n"
            + "	\n"
            + "}\n"
            + "\n"
            + "void matriz(int n) {\n"
            + "	int matrix [n][n];\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		for (j = 0; j < n; j++) {\n"
            + "			matrix[i][j] = rand()%100;\n"
            + "			\n"
            + "		}\n"
            + "	}\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		for (j = 0; j < n; j++) {\n"
            + "			cout<<matrix[i][j] << \" \";\n"
            + "			\n"
            + "		}\n"
            + "		cout<<endl;\n"
            + "	}\n"
            + "}\n"
            + "\n"
            + "void vectorsinrepeticion(int n) {\n"
            + "	set<int> sinrep;\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		sinrep.insert(rand()%100);\n"
            + "	}\n"
            + "	for (auto itr = sinrep.begin(); itr != sinrep.end(); ++itr) { \n"
            + "		cout<<*itr<<endl;\n"
            + "	} \n"
            + "}\n"
            + "\n"
            + "void Diccionario(int n) {\n"
            + "	map<int, char> dicc;\n"
            + "	char letra = 'a';\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		dicc.insert({rand()%100, letra});\n"
            + "		int aux = (int) letra;\n"
            + "		aux++;\n"
            + "		letra = (char) aux;\n"
            + "	}\n"
            + "	for (auto itr = dicc.begin(); itr != dicc.end(); ++itr) { \n"
            + "		cout << itr->first \n"
            + "			<< '\\t' << itr->second << '\\n'; \n"
            + "	} \n"
            + "	\n"
            + "}\n"
            + "\n"
            + "void pila(int n) {\n"
            + "	stack<int> mipila;\n"
            + "	\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		mipila.push(rand() % 100);\n"
            + "	}\n"
            + "	while (!mipila.empty()) {\n"
            + "		cout<<mipila.top()<<endl;\n"
            + "		mipila.pop();\n"
            + "	}\n"
            + "	\n"
            + "}\n"
            + "void cola(int n) {\n"
            + "	queue<int> micola;\n"
            + "	for (i = 0; i < n; i++) {\n"
            + "		micola.push(rand() % 100);\n"
            + "	}\n"
            + "	while (!micola.empty()) {\n"
            + "		cout<<micola.front()<<endl;\n"
            + "		micola.pop();\n"
            + "	}\n"
            + "	\n"
            + "}	\n"
            + "\n"
            + "\n"
            + "\n"
            + "\n"
            + "int main (int argc, char *argv[]) {\n"
            + "	cout<<\"Inserte cantidad de datos\"<<endl;\n"
            + "	int n ;\n"
            + "	cin>>n;\n"
            + "	cout<<\"Que estructura quiere utilizar? (Los números son aleatorios\"<<endl;\n"
            + "	cout<<\"1) Vector fijo \"<<endl;\n"
            + "	cout<<\"2) Vector dinamico\"<<endl;\n"
            + "	cout<<\"3) Vector sin repeticion\"<<endl;\n"
            + "	cout<<\"4) Matriz\"<<endl;\n"
            + "	cout<<\"5) Diccionario\"<<endl;\n"
            + "	cout<<\"6) Pila\"<<endl;\n"
            + "	cout<<\"7) Cola\"<<endl;\n"
            + "	int aux;\n"
            + "	cin>>aux;\n"
            + "	switch (aux) {\n"
            + "	case 1:\n"
            + "		vectorfijo(n);\n"
            + "		break;\n"
            + "	case 2:\n"
            + "		vectordinamico(n);\n"
            + "		break;\n"
            + "	case 3:\n"
            + "		vectorsinrepeticion(n);\n"
            + "		break;\n"
            + "	case 4:\n"
            + "		matriz(n);\n"
            + "		break;\n"
            + "	case 5:\n"
            + "		Diccionario(n);\n"
            + "		break;\n"
            + "	case 6:\n"
            + "		pila(n);\n"
            + "		break;\n"
            + "	case 7:\n"
            + "		cola(n);\n"
            + "		break;\n"
            + "		\n"
            + "	}\n"
            + "	return 0;\n"
            + "}	", estructuraspy = "from collections import deque\n"
            + "import random\n"
            + "def vector(n):\n"
            + "    arreglo=[]\n"
            + "    for i in (0,n):\n"
            + "	arreglo.append(random.randint(0,100))\n"
            + "	\n"
            + "    for i in (arreglo):\n"
            + "        print(i)\n"
            + "\n"
            + "def matriz(n):\n"
            + "    matrix = []\n"
            + "    for i in range(n):\n"
            + "        row = []\n"
            + "        for j in range(n):\n"
            + "            row.append(random.randint(0,100))\n"
            + "        matrix.append(row)\n"
            + "    for i in range(n):\n"
            + "        for j in range(n):\n"
            + "            print(matrix[i][j],end =\" \")\n"
            + "        print()    \n"
            + "\n"
            + "def vectorsinrepeticion(n):\n"
            + "    sinrep={0}\n"
            + "    for i in range(n):\n"
            + "        sinrep.add(random.randint(0,100))\n"
            + "    sinrep.remove(0)    \n"
            + "    for i in sinrep :\n"
            + "        print(i)\n"
            + "\n"
            + "def Diccionario( n):\n"
            + "    dicc={}\n"
            + "    valor = 0\n"
            + "for i in range(n):\n"
            + "dicc[random.randint(0,100)]= valor\n"
            + "        valor=valor+1\n"
            + "for x in dicc:\n"
            + "        print(str(x)+\":\"+str(dicc[x]))\n"
            + "	\n"
            + "def pila(n) :\n"
            + "    mipila=[]\n"
            + "    for i in range(n):\n"
            + "        mipila.append(random.randint(0,100))\n"
            + "    while(len(mipila)!=0):\n"
            + "        print(mipila.pop())\n"
            + "\n"
            + "def cola(n): \n"
            + "    micola=deque([])\n"
            + "    for i in range(n):\n"
            + "        micola.append(random.randint(0,100))\n"
            + "\n"
            + "    while(len(micola)!=0):\n"
            + "print(micola.popleft())\n"
            + "	\n"
            + "\n"
            + "\n"
            + "print(\"Inserte cantidad de datos\")\n"
            + "n=int(input())\n"
            + "#No existe switch en python\n"
            + "print(\"Vector\")\n"
            + "vector(n)\n"
            + "print(\"Vector sin repetición\")\n"
            + "vectorsinrepeticion(n)\n"
            + "print(\"Diccionario\")\n"
            + "Diccionario(n)\n"
            + "print(\"Pila\")\n"
            + "pila(n)\n"
            + "print(\"Cola\")\n"
            + "cola(n);\n"
            + "print(\"Matriz\")\n"
            + "matriz(n)";
    private String binarysearch = "// Implementación Java de una busqueda binaria recursiva \n"
            + "\n"
            + "public class BinarySearch {\n"
            + " /*Retorna el indice de x si se encuentra presente\n"
            + "    en arr[1,2,....r]*, si no retorna -1*/\n"
            + "static  int binarySearch(int arr[], int l, int r, int x) {\n"
            + "        if (r >= l) {\n"
            + "            int mid = l + (r - l) / 2;\n"
            + "/*Si el elemento esta presente en el medio*/\n"
            + "if (arr[mid] == x) {\n"
            + "                return mid;\n"
            + "}\n"
            + "/*Si el elemento es más pequeño que la mitad\n"
            + "            entonces solo puede estar presente en el \n"
            + "            subarreglo izquierdo*/\n"
            + "            if (arr[mid] > x) {\n"
            + "return binarySearch(arr, l, mid - 1, x);\n"
            + "}\n"
            + "//Si no el elemento solo pued estar presente \n"
            + "            //en el subarreglo derecho \n"
            + "            return binarySearch(arr, mid + 1, r, x);\n"
            + "        }\n"
            + "//Si llegamos aqui, el elemento no esta presente\n"
            + "//en el arreglo\n"
            + "        return -1;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        int arr[] = {2, 3, 4, 10, 40};\n"
            + "        int n = arr.length;\n"
            + "        int x = 10;\n"
            + "        int result = binarySearch(arr, 0, n - 1, x);\n"
            + "        if (result == -1) {\n"
            + "            System.out.println(\"Elemento no presente\");\n"
            + "} else {\n"
            + "            System.out.println(\"Element encontrado en la posición \" + result);\n"
            + "        }\n"
            + "    }\n"
            + "}";
    private String exponentialsearch = "//Programa Java para encontrar un elemento\n"
            + "//x en un array ordenado usando Exponential Search\n"
            + "\n"
            + "import java.util.Arrays;\n"
            + "\n"
            + "public class ExponentialSearch {\n"
            + "\n"
            + "/* Retorna posición de la primerra ocurrencia \n"
            + "    de x en un arreglo*/\n"
            + "static int exponentialSearch(int arr[],\n"
            + "int n, int x) {\n"
            + "// Si z esta presente en la primera localización en si misma\n"
            + "        if (arr[0] == x) {\n"
            + "            return 0;\n"
            + "        }\n"
            + "/*Encuentra ranfo para la busqueda binaria\n"
            + "        por repetidos dobles*/\n"
            + "        int i = 1;\n"
            + "while (i < n && arr[i] <= x) {\n"
            + "i = i * 2;\n"
            + "        }\n"
            + "//llama la busqueda binaria para el rango encontrado \n"
            + "return Arrays.binarySearch(arr, i / 2,\n"
            + "                Math.min(i, n), x);\n"
            + "    }\n"
            + "    public static void main(String args[]) {\n"
            + "        int arr[] = {2, 3, 4, 10, 40};\n"
            + "        int x = 10;\n"
            + "        int result = exponentialSearch(arr, arr.length, x);\n"
            + "\n"
            + "System.out.println((result < 0)\n"
            + "                ? \"El elemento no esta presente en el array\"\n"
            + "                : \"Elemento encontrado en : \"\n"
            + "                + result);\n"
            + "    }\n"
            + "}";
    private String arraymaxminsearch = "/* Programa Java que busca el maximo y el minimo\n"
            + "en un array*/\n"
            + "public class ArrayMaxMinSearch { \n"
            + "/*Clase Pair es usada para retornar\n"
            + "dos valores de getMinMax()*/\n"
            + "    static class Pair { \n"
            + "\n"
            + "        int min; \n"
            + "        int max; \n"
            + "    } \n"
            + "\n"
            + "    static Pair getMinMax(int arr[], int n) { \n"
            + "        Pair minmax = new  Pair(); \n"
            + "        int i; \n"
            + "/*Si es el unico elemento, lo retorna como min y max*/\n"
            + "if (n == 1) { \n"
            + "            minmax.max = arr[0]; \n"
            + "            minmax.min = arr[0]; \n"
            + "            return minmax; \n"
            + "} \n"
            + "/*Si hay más de un elemento, \n"
            + "        entones inicializa min y más*/\n"
            + "if (arr[0] > arr[1]) { \n"
            + "            minmax.max = arr[0]; \n"
            + "            minmax.min = arr[1]; \n"
            + "        } else { \n"
            + "            minmax.max = arr[1]; \n"
            + "            minmax.min = arr[0]; \n"
            + "        } \n"
            + "        for (i = 2; i < n; i++) { \n"
            + "            if (arr[i] > minmax.max) { \n"
            + "                minmax.max = arr[i]; \n"
            + "            } else if (arr[i] < minmax.min) { \n"
            + "                minmax.min = arr[i]; \n"
            + "            } \n"
            + "        } \n"
            + "        return minmax; \n"
            + "    } \n"
            + "    public static void main(String args[]) { \n"
            + "        int arr[] = {1000, 11, 445, 1, 330, 3000}; \n"
            + "        int arr_size = 6; \n"
            + "        Pair minmax = getMinMax(arr, arr_size); \n"
            + "System.out.printf(\"\\nEl minimo elemento es %d\", minmax.min); \n"
            + "        System.out.printf(\"\\nEl maximo elemento es %d\", minmax.max); \n"
            + "    } \n"
            + "}";
    private String fibonaccisearch = "// Programa Java para Fibonacci Search  \n"
            + "\n"
            + "public class FibonacciSearch {\n"
            + "\n"
            + "//Función de utilidad para biscar el minimo\n"
            + "    //de dos elementos\n"
            + "    public static int min(int x, int y) {\n"
            + "        return (x <= y) ? x : y;\n"
            + "    }\n"
            + "\n"
            + "    /* Regresa el indice de x si esta presente, si no retorna -1*/\n"
            + "public static int fibMonaccianSearch(int arr[],\n"
            + "int x, int n) {\n"
            + "/* Inicializa los números fibonacci*/\n"
            + "        int fibMMm2 = 0; // (m-2)esimo número fibonacci. \n"
            + "        int fibMMm1 = 1; // (m-1)esimo número fibonacci. \n"
            + "        int fibM = fibMMm2 + fibMMm1; // mesimo fibonacci.\n"
            + "/* FibM va a ser almacenado como el más pequeño\n"
            + "        fibonacci más grande o igual a n*/\n"
            + "while (fibM < n) {\n"
            + "            fibMMm2 = fibMMm1;\n"
            + "            fibMMm1 = fibM;\n"
            + "            fibM = fibMMm2 + fibMMm1;\n"
            + "}\n"
            + "// Marca el rango eliminado del frente\n"
            + "        int offset = -1;\n"
            + "/* Si bien hay elementos a inspeccionar.\n"
            + "        Tenga en cuenta que comparamos arr [fibMm2] con x.\n"
            + "        Cuando fibM se convierte en 1, fibMm2 se convierte en 0 */\n"
            + "        while (fibM > 1) {\n"
            + "//Revisa si fibMm2 es una ubicación valida\n"
            + "int i = min(offset + fibMMm2, n - 1);\n"
            + "/*Si x es más grande que el valor\n"
            + "            en el indice fibMm2, fuera del subarray\n"
            + "desde offset a i*/\n"
            + "            if (arr[i] < x) {\n"
            + "                fibM = fibMMm1;\n"
            + "                fibMMm1 = fibMMm2;\n"
            + "                fibMMm2 = fibM - fibMMm1;\n"
            + "offset = i;\n"
            + "            } /*Si x es más grande que el valor en indice \n"
            + "            fibMm2, corta el subarreglo despues de i+1*/ \n"
            + "else if (arr[i] > x) {\n"
            + "                fibM = fibMMm2;\n"
            + "                fibMMm1 = fibMMm1 - fibMMm2;\n"
            + "fibMMm2 = fibM - fibMMm1;\n"
            + "            } /* Elemento encontrado, retorna indice*/ \n"
            + "		else {\n"
            + "                return i;\n"
            + "            }\n"
            + "        }\n"
            + "/* Comparando el ultimo elemento con x*/\n"
            + "if (fibMMm1 == 1 && arr[offset + 1] == x) {\n"
            + "return offset + 1;\n"
            + "        }\n"
            + "/*Elemento no encontrado, retorna -1*/\n"
            + "return -1;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int arr[] = {10, 22, 35, 40, 45, 50,\n"
            + "            80, 82, 85, 90, 100};\n"
            + "        int n = 11;\n"
            + "        int x = 85;\n"
            + "        System.out.println(\"Found at index: \"\n"
            + "+ fibMonaccianSearch(arr, x, n));\n"
            + "    }\n"
            + "}";
    private String jumpsearch = "//Programa Java que implementa Jump Search\n"
            + "public class JumpSearch {\n"
            + "\n"
            + "    public static int jumpSearch(int[] arr, int x) {\n"
            + "int n = arr.length;\n"
            + "//Buscando el tamaño del bloque que sera\n"
            + "//saltado\n"
            + "        int step = (int) Math.floor(Math.sqrt(n));\n"
            + "/* Buscando el bloque donde el elemento\n"
            + "        esta presente (Si esta presente)*/\n"
            + "int prev = 0;\n"
            + "        while (arr[Math.min(step, n) - 1] < x) {\n"
            + "            prev = step;\n"
            + "            step += (int) Math.floor(Math.sqrt(n));\n"
            + "if (prev >= n) {\n"
            + "                return -1;\n"
            + "            }\n"
            + "        }\n"
            + "/*Realizando una busqueda linear para x en \n"
            + "        el bloque empezando con prev*/\n"
            + "while (arr[prev] < x) {\n"
            + "            prev++;\n"
            + "/*Si nosotros alcanzamos el siguiente bloque\n"
            + "            o el fin del array el elemento no esta presente*/\n"
            + "if (prev == Math.min(step, n)) {\n"
            + "return -1;\n"
            + "            }\n"
            + "        }\n"
            + "// Si el elemento fue encontrado\n"
            + "if (arr[prev] == x) {\n"
            + "            return prev;\n"
            + "        }\n"
            + "        return -1;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "int arr[] = {0, 1, 1, 2, 3, 5, 8, 13, 21,\n"
            + "            34, 55, 89, 144, 233, 377, 610};\n"
            + "        int x = 55;\n"
            + "//Encontrar el indice de 'x' usando Jump Search\n"
            + "int index = jumpSearch(arr, x);\n"
            + "// Imprime el indice donde x fue encontrado\n"
            + "        System.out.println(\"\\nNúmero \" + x\n"
            + "                + \" esta en el indice \" + index);\n"
            + "    }\n"
            + "}";
    private String minabssumpair = "//Programa JAVA que busque el par de números\n"
            + "//que sumados de la minima suma absoluta\n"
            + "\n"
            + "public class MinAbsSumPair {\n"
            + "//función que busca el par \n"
            + "static void minAbsSumPair(int arr[], int arr_size) {\n"
            + "        int inv_count = 0;\n"
            + "        int l, r, min_sum, sum, min_l, min_r;\n"
            + "/*El array debe tener al menos 2 elementos*/\n"
            + "if (arr_size < 2) {\n"
            + "            System.out.println(\"Invalid Input\");\n"
            + "return;\n"
            + "        }\n"
            + "/* Inicialización de los valores*/\n"
            + "min_l = 0;\n"
            + "        min_r = 1;\n"
            + "        min_sum = arr[0] + arr[1];\n"
            + "        for (l = 0; l < arr_size - 1; l++) {\n"
            + "            for (r = l + 1; r < arr_size; r++) {\n"
            + "                sum = arr[l] + arr[r];\n"
            + "                if (Math.abs(min_sum) > Math.abs(sum)) {\n"
            + "                    min_sum = sum;\n"
            + "                    min_l = l;\n"
            + "min_r = r;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        System.out.println(\" Los dos elementos los cuales \"\n"
            + "                + \"tienen la suma minima son \"\n"
            + "                + arr[min_l] + \" y \" + arr[min_r]);\n"
            + "}\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "int arr[] = {1, 60, -10, 70, -80, 85};\n"
            + "        minAbsSumPair(arr, 6);\n"
            + "    }\n"
            + "\n"
            + "}";
    private String missingnosearch = "//Programa java para buscar el número perdido\n"
            + "//usando xor\n"
            + "public class MissingNoSearch {\n"
            + "//Función que busca el número perdido\n"
            + "static int getMissingNo(int a[], int n) {\n"
            + "int x1 = a[0];\n"
            + "        int x2 = 1;\n"
            + "/*For XOR para todos los elementos \n"
            + "del arreglo*/\n"
            + "        for (int i = 1; i < n; i++) {\n"
            + "x1 = x1 ^ a[i];\n"
            + "        }\n"
            + "/* For xor de todos los elementos de 1 a n+1 */\n"
            + "for (int i = 2; i <= n + 1; i++) {\n"
            + "x2 = x2 ^ i;\n"
            + "        }\n"
            + "        return (x1 ^ x2);\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        int a[] = {1, 2, 3, 4, 5, 7, 8};\n"
            + "        int miss = getMissingNo(a, 7);\n"
            + "System.out.println(miss);\n"
            + "    }\n"
            + "}";
    private String pairdifferrencesearch = "// Programa Java para buscar un par\n"
            + "// Dada una diferencia\n"
            + "public class PairDifferenceSearch {\n"
            + "//La función asume que el array esta ordenado\n"
            + "static boolean findPair(int arr[], int n) {\n"
            + "int size = arr.length;\n"
            + "// Inicializa la posición de dos elementos\n"
            + "        int i = 0, j = 1;\n"
            + "// Busca por el par\n"
            + "while (i < size && j < size) {\n"
            + "            if (i != j && arr[j] - arr[i] == n) {\n"
            + "                System.out.print(\"Par Encontrado: \"\n"
            + "                        + \"( \" + arr[i] + \", \" + arr[j] + \" )\");\n"
            + "                return true;\n"
            + "            } else if (arr[j] - arr[i] < n) {\n"
            + "j++;\n"
            + "            } else {\n"
            + "                i++;\n"
            + "            }\n"
            + "        }\n"
            + "//No encuentra el par\n"
            + "        System.out.print(\"No hay tal par\");\n"
            + "return false;\n"
            + "    }\n"
            + "    public static void main(String[] args) {\n"
            + "        int arr[] = {1, 8, 30, 40, 100};\n"
            + "        int n = 60;\n"
            + "        findPair(arr, n);\n"
            + "}\n"
            + "}";
    private String ternarysearch = "//Programa Java para ilustrar \n"
            + "//recursivamente la aproximación\n"
            + "//de una busqueda ternaria\n"
            + "\n"
            + "public class TernarySearch {\n"
            + "\n"
            + "//Función que realiza la busqueda ternaria\n"
            + "static int ternarySearch(int l, int r, int key, int ar[]) {\n"
            + "if (r >= l) {\n"
            + "//encontrar el mid1 y mid 2\n"
            + "int mid1 = l + (r - l) / 3;\n"
            + "            int mid2 = r - (r - l) / 3;\n"
            + "//Verificar si la key esta presente en algun medio\n"
            + "if (ar[mid1] == key) {\n"
            + "                return mid1;\n"
            + "            }\n"
            + "            if (ar[mid2] == key) {\n"
            + "                return mid2;\n"
            + "}\n"
            + "/*Desde que la key no este presente en el mid\n"
            + "            verifica en cada region si esta presente\n"
            + "            luego repite la operación de busqueda\n"
            + "            en esa región*/\n"
            + "            if (key < ar[mid1]) {\n"
            + "//La key yace entre 1 y mid1\n"
            + "return ternarySearch(l, mid1 - 1, key, ar);\n"
            + "            } else if (key > ar[mid2]) {\n"
            + "//La key yace entre mid2 y r\n"
            + "return ternarySearch(mid2 + 1, r, key, ar);\n"
            + "} else {\n"
            + "//La key  yace entre mid 1 y mid 2\n"
            + "return ternarySearch(mid1 + 1, mid2 - 1, key, ar);\n"
            + "            }\n"
            + "        }\n"
            + "// key no encontrada\n"
            + "        return -1;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "int l, r, p, key;\n"
            + "//Cree el array y ordenelo si no lo está\n"
            + "        int ar[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n"
            + "// Indice inicial\n"
            + "        l = 0;\n"
            + "// Tamaño del arreglo \n"
            + "        r = 9;\n"
            + "// Buscando por el 5\n"
            + "        // key que va a ser buscada en el array\n"
            + "key = 5;\n"
            + "// Busca usando Ternary Search\n"
            + "        p = ternarySearch(l, r, key, ar);\n"
            + "// Imprime el resultado\n"
            + "        System.out.println(\"Indice de \" + key + \" es \" + p);\n"
            + "// Buscando por el 50\n"
            + "        // Key a ser buscada en el array\n"
            + "key = 50;\n"
            + "// Buscar usando Ternary Search\n"
            + "        p = ternarySearch(l, r, key, ar);\n"
            + "// Imprime el resultado \n"
            + "        System.out.println(\"Index of \" + key + \" is \" + p);\n"
            + "}\n"
            + "}";
    private String recursivebubblesort = "//Programa java que realiza Bubble Sort Recursivo\n"
            + "import java.util.Arrays; \n"
            + "\n"
            + "public class RecursiveBubbleSort  \n"
            + "{ \n"
            + "\n"
            + "    static void bubbleSort(int arr[], int n) \n"
            + "    { \n"
            + "// Caso base\n"
            + "        if (n == 1) \n"
            + "            return; \n"
            + "//Un paso de Bubble Sort, luego de este\n"
            + "       //paso, el elemento más largo es movido\n"
            + "//  hasta el final\n"
            + "        for (int i=0; i<n-1; i++) \n"
            + "            if (arr[i] > arr[i+1]) \n"
            + "            {   //intercambia arr[i], arr[i+1] \n"
            + "                int temp = arr[i]; \n"
            + "                arr[i] = arr[i+1]; \n"
            + "                arr[i+1] = temp; \n"
            + "            } \n"
            + "        bubbleSort(arr, n-1); \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        int arr[] = {64, 34, 25, 12, 22, 11, 90};\n"
            + "  bubbleSort(arr, arr.length);\n"
            + "        System.out.println(\"Array ordenado : \"); \n"
            + "        System.out.println(Arrays.toString(arr)); \n"
            + "} \n"
            + "}";
    private String quicksort = "// Programa java para la implementación de QuickSort\n"
            + "\n"
            + "public class QuickSort {\n"
            + "\n"
            + "    /* Esta función toma el ultimo elemento como\n"
            + "    pivote, coloca el pivote en la posición correcta\n"
            + "    en el array ordenado, y coloca todos los más \n"
            + "    pequeñps (Más pequeños que el pivote) a la izquierda\n"
            + "    del pivote, y todos los más grandes a la derecha del\n"
            + "pivote*/\n"
            + "    static int partition(int arr[], int low, int high) {\n"
            + "        int pivot = arr[high];\n"
            + "        int i = (low - 1); // Indice del elemento más pequeño\n"
            + "        for (int j = low; j < high; j++) {\n"
            + "/*Si el actual elemento es más pequeño\n"
            + "            p igual que el pivote*/\n"
            + "if (arr[j] <= pivot) {\n"
            + "                i++;\n"
            + "//intercambia arr[i] y arr[j] \n"
            + "int temp = arr[i];\n"
            + "                arr[i] = arr[j];\n"
            + "arr[j] = temp;\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "// Intercambia arr[i+1] y arr[high] (o pivote) \n"
            + "int temp = arr[i + 1];\n"
            + "        arr[i + 1] = arr[high];\n"
            + "        arr[high] = temp;\n"
            + "\n"
            + "        return i + 1;\n"
            + "}\n"
            + "\n"
            + "/*arr[] --> Array que sera ordenado, \n"
            + "low  --> indice inicial, \n"
            + "      high  --> indice final */\n"
            + "    static void sort(int arr[], int low, int high) {\n"
            + "        if (low < high) {\n"
            + "            /* pi esta particionando indices, arr[pi] is  \n"
            + "              now at right place */\n"
            + "            int pi = partition(arr, low, high);\n"
            + "// Recursivamente ordena elementos antes de \n"
            + "            // la partición y despues de la partición\n"
            + "sort(arr, low, pi - 1);\n"
            + "            sort(arr, pi + 1, high);\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "/* Imprimir array */\n"
            + "    static void printArray(int arr[]) {\n"
            + "        int n = arr.length;\n"
            + "        for (int i = 0; i < n; ++i) {\n"
            + "            System.out.print(arr[i] + \" \");\n"
            + "        }\n"
            + "        System.out.println();\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        int arr[] = {10, 7, 8, 9, 1, 5};\n"
            + "        int n = arr.length;\n"
            + "        sort(arr, 0, n - 1);\n"
            + "        System.out.println(\"Array ordenado\");\n"
            + "printArray(arr);\n"
            + "    }\n"
            + "}";
    private String radixsort = "//Implementación java de Radix Sort\n"
            + "\n"
            + "import java.util.*;\n"
            + "\n"
            + "public class RadixSort {\n"
            + "\n"
            + "// Una función de utilidad que obtiene\n"
            + "    //El maximo valor en arr[] \n"
            + "static int getMax(int arr[], int n) {\n"
            + "        int mx = arr[0];\n"
            + "        for (int i = 1; i < n; i++) {\n"
            + "            if (arr[i] > mx) {\n"
            + "                mx = arr[i];\n"
            + "}\n"
            + "        }\n"
            + "        return mx;\n"
            + "    }\n"
            + "\n"
            + "    /*Una función que realiza conteo de ordenamiento en \n"
            + "    arr[] de acuerdo al digito\n"
            + "    representado como exp*/\n"
            + "static void countSort(int arr[], int n, int exp) {\n"
            + "        int output[] = new int[n]; // Array de salida\n"
            + "        int i;\n"
            + "        int count[] = new int[10];\n"
            + "Arrays.fill(count, 0);\n"
            + "        // Almacena el conteo de las ocurrencias en count[]\n"
            + "for (i = 0; i < n; i++) {\n"
            + "            count[(arr[i] / exp) % 10]++;\n"
            + "}\n"
            + "// cambia count[i] de tal manera que ahora\n"
            + "        //contenga la actual posicion de este digito en\n"
            + "//output[]\n"
            + "        for (i = 1; i < 10; i++) {\n"
            + "            count[i] += count[i - 1];\n"
            + "        }\n"
            + "//Contruye el array de salida\n"
            + "        for (i = n - 1; i >= 0; i--) {\n"
            + "            output[count[(arr[i] / exp) % 10] - 1] = arr[i];\n"
            + "count[(arr[i] / exp) % 10]--;\n"
            + "        }\n"
            + "// copia el array de salida a arr[], ahora arr[] \n"
            + "        // contiene los números ordenados de acuerdo al digito\n"
            + "//actual \n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            arr[i] = output[i];\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static void radixsort(int arr[], int n) {\n"
            + "// Encuentra el maximo número para conocer el número \n"
            + "        // de digitos\n"
            + "        int m = getMax(arr, n);\n"
            + "for (int exp = 1; m / exp > 0; exp *= 10) {\n"
            + "            countSort(arr, n, exp);\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "//Imprimir el array\n"
            + "    static void print(int arr[], int n) {\n"
            + "        for (int i = 0; i < n; i++) {\n"
            + "            System.out.print(arr[i] + \" \");\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int arr[] = {170, 45, 75, 90, 802, 24, 2, 66};\n"
            + "        int n = arr.length;\n"
            + "        radixsort(arr, n);\n"
            + "        print(arr, n);\n"
            + "}\n"
            + "}";
    private String shellsort = "// Implementación java de ShellSort\n"
            + "public class ShellSort \n"
            + "{   /*Imprimir el array */\n"
            + "    static void printArray(int arr[]) \n"
            + "    { \n"
            + "        int n = arr.length; \n"
            + "        for (int i=0; i<n; ++i) \n"
            + "            System.out.print(arr[i] + \" \"); \n"
            + "        System.out.println(); \n"
            + "    } \n"
            + "    //Función ordenadora Shell Sort\n"
            + "static  int sort(int arr[]) \n"
            + "{ \n"
            + "        int n = arr.length; \n"
            + "//Inicia con un gran salto, luego reduce el salto\n"
            + "for (int gap = n/2; gap > 0; gap /= 2) \n"
            + "{   //Realiza un insertion sort con salto\n"
            + "            // Los primeros elementros del sato a[0..gap-1]\n"
            + "            // estan ya en un orden de salto que sigue agregando\n"
            + "            //un elemento más hasta que el array entero este ordenado\n"
            + "for (int i = gap; i < n; i += 1) \n"
            + "{ \n"
            + "//Agrega a[i] a los elementos que estan en el ordenamiento\n"
            + "// con salto\n"
            + "                int temp = arr[i]; \n"
            + "                int j; \n"
            + "                for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) \n"
            + "                    arr[j] = arr[j - gap]; \n"
            + "                arr[j] = temp; \n"
            + "            } \n"
            + "        } \n"
            + "        return 0; \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        int arr[] = {12, 34, 54, 2, 3}; \n"
            + "        System.out.println(\"Array antes de ordenar\"); \n"
            + "        printArray(arr); \n"
            + "        sort(arr);\n"
            + "        System.out.println(\"Array despues de ordenar\"); \n"
            + "printArray(arr); \n"
            + "    } \n"
            + "}  ";
    private String timsort = "// Programa Java que realiza TimSort\n"
            + "\n"
            + "public class TimSort {\n"
            + "\n"
            + "    static int RUN = 32;\n"
            + "\n"
            + "// esta función ordena el arreglo \n"
            + "    //desde el índice izquierdo hasta\n"
            + "    //a la derecha el índice que es de tamaño más alto RUN \n"
            + "public static void insertionSort(int[] arr, int left, int right) {\n"
            + "        for (int i = left + 1; i <= right; i++) {\n"
            + "            int temp = arr[i];\n"
            + "            int j = i - 1;\n"
            + "            while (arr[j] > temp && j >= left) {\n"
            + "                arr[j + 1] = arr[j];\n"
            + "                j--;\n"
            + "            }\n"
            + "            arr[j + 1] = temp;\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void merge(int[] arr, int l,\n"
            + "int m, int r) {   //Array original esta separado en dos partes\n"
            + "        // array derecho e izquierdo \n"
            + "        int len1 = m - l + 1, len2 = r - m;\n"
            + "int[] left = new int[len1];\n"
            + "        int[] right = new int[len2];\n"
            + "        for (int x = 0; x < len1; x++) {\n"
            + "            left[x] = arr[l + x];\n"
            + "        }\n"
            + "        for (int x = 0; x < len2; x++) {\n"
            + "            right[x] = arr[m + 1 + x];\n"
            + "        }\n"
            + "\n"
            + "        int i = 0;\n"
            + "        int j = 0;\n"
            + "        int k = l;\n"
            + "// despues de comparar, \n"
            + "        // after comparing,unimos los dos array  \n"
            + "        // en un subarray más largo\n"
            + "        while (i < len1 && j < len2) {\n"
            + "if (left[i] <= right[j]) {\n"
            + "                arr[k] = left[i];\n"
            + "                i++;\n"
            + "            } else {\n"
            + "                arr[k] = right[j];\n"
            + "j++;\n"
            + "            }\n"
            + "            k++;\n"
            + "        }\n"
            + "//Copia los elementos restates de la izquiera, si hay\n"
            + "while (i < len1) {\n"
            + "            arr[k] = left[i];\n"
            + "k++;\n"
            + "            i++;\n"
            + "        }\n"
            + "\n"
            + "// Copia los elementos restates de la derecha, si hay\n"
            + "while (j < len2) {\n"
            + "            arr[k] = right[j];\n"
            + "            k++;\n"
            + "            j++;\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void timSort(int[] arr, int n) {\n"
            + "//Ordena individualmente los subarrays de \n"
            + "        //tamaño RUN\n"
            + "for (int i = 0; i < n; i += RUN) {\n"
            + "            insertionSort(arr, i, Math.min((i + 31), (n - 1)));\n"
            + "}\n"
            + "//Comienza a unir de tamaño run, luego\n"
            + "        //podra unir de tamaño 64, 128, 256 y asi...\n"
            + "for (int size = RUN; size < n; size = 2 * size) {\n"
            + "// Toma un punto inicial del subarray izquierdo\n"
            + "            // nosotros vamos a unir arr[left..left+size-1] y\n"
            + "//arr[left+size, left+2*size-1], luego de cada union\n"
            + "// nosotros incrementamos izquiera en  2*size  \n"
            + "            for (int left = 0; left < n; left += 2 * size) {\n"
            + "//Encontramos punto de finalizacion de\n"
            + "                // el subarray izquierdo, mid+1\n"
            + "                // mid+1 es el punto inicial del \n"
            + "//subarray derecho  \n"
            + "                int mid = left + size - 1;\n"
            + "                int right = Math.min((left + 2 * size - 1), (n - 1));\n"
            + "\n"
            + "// une sub array arr[left.....mid] y  \n"
            + "                // arr[mid+1....right]  \n"
            + "                merge(arr, left, mid, right);\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "// Imprimir el array\n"
            + "    public static void printArray(int[] arr, int n) {\n"
            + "        for (int i = 0; i < n; i++) {\n"
            + "            System.out.print(arr[i] + \" \");\n"
            + "        }\n"
            + "        System.out.print(\"\\n\");\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int[] arr = {5, 21, 7, 23, 19};\n"
            + "        int n = arr.length;\n"
            + "        System.out.print(\"Given Array is\\n\");\n"
            + "        printArray(arr, n);\n"
            + "        timSort(arr, n);\n"
            + "        System.out.print(\"After Sorting Array is\\n\");\n"
            + "printArray(arr, n);\n"
            + "    }\n"
            + "}";
    private String treesort = "//Codigo java que implementa Tree Sort \n"
            + "public class TreeSort {\n"
            + "//Clase conteniendo hijo izquierdo\n"
            + "    //y derecho del nodo actual, y \n"
            + "    // el valor del nodo (Key)\n"
            + "static class Node {\n"
            + "\n"
            + "        int key;\n"
            + "        Node left, right;\n"
            + "\n"
            + "        public Node(int item) {\n"
            + "            key = item;\n"
            + "            left = right = null;\n"
            + "}\n"
            + "    }\n"
            + "\n"
            + "// Raiz del arbol de busqueda\n"
            + "    //binaria\n"
            + "static Node root;\n"
            + "//Constructor inicial\n"
            + "    static void init() {\n"
            + "        root = null;\n"
            + "    }\n"
            + "//Este metodo principalmente\n"
            + "    static void insert(int key) {\n"
            + "root = insertRec(root, key);\n"
            + "    }\n"
            + "/*Una función recursiva que inserta \n"
            + "    nuevos valores al arbol de busqueda binaria*/\n"
            + "static Node insertRec(Node root, int key) {\n"
            + "/*Si el arbol esta vacio\n"
            + "        Retorne un nuevo nodo*/\n"
            + "if (root == null) {\n"
            + "            root = new Node(key);\n"
            + "return root;\n"
            + "        }\n"
            + "/*De otra forma, baja por el arbol*/\n"
            + "if (key < root.key) {\n"
            + "            root.left = insertRec(root.left, key);\n"
            + "        } else if (key > root.key) {\n"
            + "            root.right = insertRec(root.right, key);\n"
            + "}\n"
            + "/*Retorna la raiz*/\n"
            + "        return root;\n"
            + "    }\n"
            + "/*Una función que realiza recorrido\n"
            + "    inorden atraves del arbol*/\n"
            + "static void inorderRec(Node root) {\n"
            + "        if (root != null) {\n"
            + "            inorderRec(root.left);\n"
            + "            System.out.print(root.key + \" \");\n"
            + "            inorderRec(root.right);\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static void treeins(int arr[]) {\n"
            + "        for (int i = 0; i < arr.length; i++) {\n"
            + "            insert(arr[i]);\n"
            + "        }\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "\n"
            + "        int arr[] = {5, 4, 7, 2, 11};\n"
            + "        treeins(arr);\n"
            + "        inorderRec(root);\n"
            + "}\n"
            + "}";
    private String mergesort = "/*Programa java para Merge Sort*/\n"
            + "public class MergeSort \n"
            + "{   /*Une dos subarrays de arr[]\n"
            + "    Primer subarray es arr[1...m]\n"
            + "    Segundo subarray es arr[m+1..r]*/\n"
            + "static   void merge(int arr[], int l, int m, int r) \n"
            + "{   //Encuentra tamaños de dos subarrays a ser unidos\n"
            + "int n1 = m - l + 1; \n"
            + "        int n2 = r - m; \n"
            + "        /* Crear arrays temporales */\n"
            + "        int L[] = new int [n1]; \n"
            + "        int R[] = new int [n2]; \n"
            + "/*Copia datos en los arrays temporales*/\n"
            + "for (int i=0; i<n1; ++i) \n"
            + "            L[i] = arr[l + i]; \n"
            + "        for (int j=0; j<n2; ++j) \n"
            + "R[j] = arr[m + 1+ j]; \n"
            + "/*Une los arreglos temporales*/\n"
            + "        // Indices iniciales del los dos subarrays\n"
            + "        int i = 0, j = 0; \n"
            + "//indice inicial de array unido\n"
            + "int k = l; \n"
            + "        while (i < n1 && j < n2) \n"
            + "        { \n"
            + "            if (L[i] <= R[j]) \n"
            + "            { \n"
            + "                arr[k] = L[i]; \n"
            + "                i++; \n"
            + "            } \n"
            + "            else\n"
            + "            { \n"
            + "                arr[k] = R[j]; \n"
            + "j++; \n"
            + "            } \n"
            + "            k++; \n"
            + "        } \n"
            + "        /*Copia los elementos restanes de L[] si hay*/\n"
            + "while (i < n1) \n"
            + "        { \n"
            + "            arr[k] = L[i]; \n"
            + "i++; \n"
            + "            k++; \n"
            + "        } \n"
            + "//Copia los elementos restanes de R[] si hay\n"
            + "while (j < n2) \n"
            + "        { \n"
            + "            arr[k] = R[j]; \n"
            + "            j++; \n"
            + "            k++; \n"
            + "        } \n"
            + "    } \n"
            + "  static  void sort(int arr[], int l, int r) \n"
            + "{ \n"
            + "        if (l < r) \n"
            + "        { \n"
            + "//Encuentra el punto medio\n"
            + "            int m = (l+r)/2; \n"
            + "// Ordena los dos subarrays\n"
            + "sort(arr, l, m); \n"
            + "            sort(arr , m+1, r); \n"
            + "// Une los subarrays\n"
            + "            merge(arr, l, m, r); \n"
            + "} \n"
            + "    } \n"
            + "\n"
            + "//Imprimir array\n"
            + "    static void printArray(int arr[]) \n"
            + "    { \n"
            + "        int n = arr.length; \n"
            + "        for (int i=0; i<n; ++i) \n"
            + "            System.out.print(arr[i] + \" \"); \n"
            + "        System.out.println(); \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        int arr[] = {12, 11, 13, 5, 6, 7}; \n"
            + "\n"
            + "        System.out.println(\"Array dado\"); \n"
            + "        printArray(arr); \n"
            + "   sort(arr, 0, arr.length-1); \n"
            + "        System.out.println(\"\\nArray ordenado\"); \n"
            + "printArray(arr); \n"
            + "    } \n"
            + "}";
    private String binaryinsertionsort = "// Programa java implementando\n"
            + "// Binary Insertion Sort\n"
            + "\n"
            + "import java.util.Arrays; \n"
            + "public class BinaryInsertionSort \n"
            + "{ \n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        final int[] arr = {37, 23, 0, 17, 12, 72, 31, \n"
            + "                             46, 100, 88, 54 }; \n"
            + "\n"
            + "        sort(arr); \n"
            + "        for(int i=0; i<arr.length; i++) \n"
            + "            System.out.print(arr[i]+\" \"); \n"
            + "    } \n"
            + "\n"
            + "    static  void sort(int array[]) \n"
            + "    { \n"
            + "        for (int i = 1; i < array.length; i++) \n"
            + "{ \n"
            + "            int x = array[i]; \n"
            + "// Encontrar ubicación para insertar usando\n"
            + "// Binary Search\n"
            + "            int j = Math.abs(Arrays.binarySearch(array, 0, i, x) + 1); \n"
            + "            System.arraycopy(array, j, array, j+1, i-j); \n"
            + "// Colocar elemento en su correcta localización\n"
            + "            array[j] = x; \n"
            + "        } \n"
            + "    } \n"
            + "} ";
    private String bitonicsort = "/* Programa java para Bitonic Sort*/\n"
            + "/* Nota: Este programa solo funciona si el tamaño\n"
            + "de la entrada es una potencia de 2*/\n"
            + "public class BitonicSort {\n"
            + "/* El parámetro dir indica la dirección de ordenamiento,\n"
            + "       ASCENDIENDO o DESCENDIENDO; si (a [i]> a [j]) está de acuerdo\n"
            + "       con la dirección, entonces a[i] y a[j] son\n"
            + "intercambiados*/\n"
            + "    static void compAndSwap(int a[], int i, int j, int dir) {\n"
            + "        if ((a[i] > a[j] && dir == 1)\n"
            + "                || (a[i] < a[j] && dir == 0)) {\n"
            + "// intercambiando elementos\n"
            + "            int temp = a[i];\n"
            + "a[i] = a[j];\n"
            + "            a[j] = temp;\n"
            + "        }\n"
            + "    }\n"
            + "    static void bitonicMerge(int a[], int low, int cnt, int dir) {\n"
            + "        if (cnt > 1) {\n"
            + "            int k = cnt / 2;\n"
            + "            for (int i = low; i < low + k; i++) {\n"
            + "                compAndSwap(a, i, i + k, dir);\n"
            + "            }\n"
            + "            bitonicMerge(a, low, k, dir);\n"
            + "            bitonicMerge(a, low + k, k, dir);\n"
            + "        }\n"
            + "    }\n"
            + "    static void bitonicSort(int a[], int low, int cnt, int dir) {\n"
            + "        if (cnt > 1) {\n"
            + "            int k = cnt / 2;\n"
            + "// Ordena en orden ascendente, dir es 1 \n"
            + "            bitonicSort(a, low, k, 1);\n"
            + "// ordena en orden descendente, dir es 0\n"
            + "bitonicSort(a, low + k, k, 0);\n"
            + "// une toda la secuencia en orden ascendente\n"
            + "bitonicMerge(a, low, cnt, dir);\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static void sort(int a[], int N, int up) {\n"
            + "        bitonicSort(a, 0, N, up);\n"
            + "    }\n"
            + "\n"
            + "/*Imprimir array */\n"
            + "    static void printArray(int arr[]) {\n"
            + "        int n = arr.length;\n"
            + "        for (int i = 0; i < n; ++i) {\n"
            + "            System.out.print(arr[i] + \" \");\n"
            + "        }\n"
            + "        System.out.println();\n"
            + "    }\n"
            + "\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        int a[] = {3, 7, 4, 8, 6, 2, 1, 5};\n"
            + "        int up = 1;\n"
            + "        sort(a, a.length, up);\n"
            + "        System.out.println(\"\\nArray ordenado\");\n"
            + "printArray(a);\n"
            + "    }\n"
            + "}";
    private String cocktailsort = "// Programa java implementando Cocktail sort\n"
            + "public class CocktailSort {\n"
            + "\n"
            + "    static void cocktailSort(int a[]) {\n"
            + "        boolean swapped = true;\n"
            + "        int start = 0;\n"
            + "        int end = a.length;\n"
            + "        while (swapped == true) {\n"
            + "// Resetea la bandera intercambiada al entrar\n"
            + "            // en el ciclo, porque puede ser true de la\n"
            + "            // anterior iteración\n"
            + "            swapped = false;\n"
            + "// Ciclo del fondo a encima igual\n"
            + "// que bubble sort\n"
            + "            for (int i = start; i < end - 1; ++i) {\n"
            + "                if (a[i] > a[i + 1]) {\n"
            + "                    int temp = a[i];\n"
            + "                    a[i] = a[i + 1];\n"
            + "                    a[i + 1] = temp;\n"
            + "swapped = true;\n"
            + "                }\n"
            + "            }\n"
            + "   // Si nada fue movido, array esta ordenado\n"
            + "            if (swapped == false) {\n"
            + "                break;\n"
            + "            }\n"
            + "            // de otra forma, resetea la bandera intercambiada\n"
            + "            // de tal forma que pueda ser usada en el \n"
            + "            //siguiente proceso\n"
            + "            swapped = false;\n"
            + "// Mueve el punto final atras en uno, porque\n"
            + "            // el item al final esta en la derecha completa\n"
            + "end = end - 1;\n"
            + "            // from top to bottom, doing the \n"
            + "            // same comparison as in the previous stage \n"
            + "            for (int i = end - 1; i >= start; i--) {\n"
            + "                if (a[i] > a[i + 1]) {\n"
            + "                    int temp = a[i];\n"
            + "                    a[i] = a[i + 1];\n"
            + "                    a[i + 1] = temp;\n"
            + "swapped = true;\n"
            + "                }\n"
            + "            }\n"
            + "// Incrementa el punto inicial, por que\n"
            + "            // la ultima fase pudo haber movido el siguiente\n"
            + "            // más pequeño número en la derecha completa\n"
            + "start = start + 1;\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    /* Imprime el array*/\n"
            + "    static void printArray(int a[]) {\n"
            + "        int n = a.length;\n"
            + "        for (int i = 0; i < n; i++) {\n"
            + "            System.out.print(a[i] + \" \");\n"
            + "        }\n"
            + "        System.out.println();\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        ;\n"
            + "        int a[] = {5, 1, 4, 2, 8, 0, 2};\n"
            + "        cocktailSort(a);\n"
            + "        System.out.println(\"Arreglo ordenado\");\n"
            + "printArray(a);\n"
            + "    }\n"
            + "}";
    private String combsort = "// Programa java implementando Comb Sort\n"
            + "public class CombSort \n"
            + "{   // Para buscar espacio entre elementos\n"
            + "static  int getNextGap(int gap) \n"
            + "    { \n"
            + "        gap = (gap*10)/13; \n"
            + "        if (gap < 1) \n"
            + "            return 1; \n"
            + "        return gap; \n"
            + "    } \n"
            + "  static  void sort(int arr[]) \n"
            + "{ \n"
            + "        int n = arr.length; \n"
            + "\n"
            + "// Inicializa espacio\n"
            + "int gap = n; \n"
            + "        boolean swapped = true; \n"
            + "/*Mantiene ejecutando mientras gap es más que 1 y la \n"
            + "        ultima iteración causa un intercambio*/ \n"
            + "while (gap != 1 || swapped == true) \n"
            + "        { \n"
            + "            gap = getNextGap(gap); \n"
            + "/*Inicializa swapped como falso, aso \n"
            + "podemos verificar si el intercambio paso\n"
            + "            o no*/ \n"
            + "            swapped = false; \n"
            + "            //Compara todos los elementos con el espacio actual \n"
            + "for (int i=0; i<n-gap; i++) \n"
            + "            { \n"
            + "                if (arr[i] > arr[i+gap]) \n"
            + "{   //Intercambia arr[i] y arr[i+gap]\n"
            + "int temp = arr[i]; \n"
            + "                    arr[i] = arr[i+gap]; \n"
            + "arr[i+gap] = temp; \n"
            + "// Se intercambió\n"
            + "swapped = true; \n"
            + "                } \n"
            + "            } \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "\n"
            + "        int arr[] = {8, 4, 1, 56, 3, -44, 23, -6, 28, 0}; \n"
            + "        sort(arr); \n"
            + "        System.out.println(\"Array ordenado\"); \n"
            + "        for (int i=0; i<arr.length; ++i) \n"
            + "            System.out.print(arr[i] + \" \"); \n"
            + "\n"
            + "} \n"
            + "}";
    private String countingsort = "// Implementación java de Counting Sort\n"
            + "public class CountingSort \n"
            + "{ \n"
            + "   static  void sort(char arr[]) \n"
            + "{ \n"
            + "        int n = arr.length; \n"
            + "// El array de caracteres que sera el array \n"
            + "        //ordenado de salida\n"
            + "        char output[] = new char[n]; \n"
            + "// Crea un array de conteo para almacenar \n"
            + "        // conteo individual de caracteres e inicializar\n"
            + "// array de conteo en 0\n"
            + "        int count[] = new int[256]; \n"
            + "        for (int i=0; i<256; ++i) \n"
            + "            count[i] = 0; \n"
            + "// Almacena el conteo de cada caracter\n"
            + "for (int i=0; i<n; ++i) \n"
            + "++count[arr[i]]; \n"
            + "// Cambian count[i] de forma que ahora contenga la \n"
            + "        //posición actual de este caracter en el array de saliday \n"
            + "for (int i=1; i<=255; ++i) \n"
            + "            count[i] += count[i-1]; \n"
            + "// Construye el array de caracteres de salida\n"
            + "        // Para hacerlo estable lo hacemos en orden inverso\n"
            + "for (int i = n-1; i>=0; i--) \n"
            + "        { \n"
            + "            output[count[arr[i]]-1] = arr[i]; \n"
            + "--count[arr[i]]; \n"
            + "        } \n"
            + "//Copia el array de salida a arr, asi arr ahora\n"
            + "// contiene los caracteres ordenados \n"
            + "        for (int i = 0; i<n; ++i) \n"
            + "            arr[i] = output[i]; \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "\n"
            + "        char arr[] = {'g', 'e', 'e', 'k', 's', 'f', 'o', \n"
            + "                    'r', 'g', 'e', 'e', 'k', 's'\n"
            + "                    }; \n"
            + "        sort(arr); \n"
            + "        System.out.print(\"array de caracteres ordenado: \"); \n"
            + "        for (int i=0; i<arr.length; ++i) \n"
            + "            System.out.print(arr[i]); \n"
            + "} \n"
            + "}";
    private String cyclesort = "// Java program to implement cycle sort \n"
            + "//Programa java implementando Cycle sort\n"
            + "public class CycleSort { \n"
            + "    public static void cycleSort(int arr[], int n) \n"
            + "{   //Contador de escrituras en memoria\n"
            + "        int writes = 0; \n"
            + "//Pasar poe los elementros del array\n"
            + "        //y ponerlos en el lugar correcto \n"
            + "for (int cycle_start = 0; cycle_start <= n - 2; cycle_start++) {  \n"
            + "// Inicializa item como punto inicial\n"
            + "            int item = arr[cycle_start]; \n"
            + "// Encuentra posicion donde nosotros pondremos el item\n"
            + "            // Basicamente contamos todos los elementos más pequeños\n"
            + "//a la derecha del item\n"
            + "            int pos = cycle_start; \n"
            + "            for (int i = cycle_start + 1; i < n; i++) \n"
            + "                if (arr[i] < item) \n"
            + "                    pos++; \n"
            + "//Si item esta ya en la posicion correcta\n"
            + "if (pos == cycle_start) \n"
            + "                continue; \n"
            + "//Ignorar todos los elementos duplicados\n"
            + "            while (item == arr[pos]) \n"
            + "                pos += 1; \n"
            + "//Ponemos el item en su posición correcta\n"
            + "if (pos != cycle_start) { \n"
            + "                int temp = item; \n"
            + "                item = arr[pos]; \n"
            + "                arr[pos] = temp; \n"
            + "                writes++; \n"
            + "} \n"
            + "//Rota el resto del ciclo\n"
            + "            while (pos != cycle_start) { \n"
            + "                pos = cycle_start; \n"
            + "                // Encuentra posicion donde poner el elemento \n"
            + "for (int i = cycle_start + 1; i < n; i++) \n"
            + "                    if (arr[i] < item) \n"
            + "                        pos += 1; \n"
            + "//Ignora todos los duplicados\n"
            + "                while (item == arr[pos]) \n"
            + "                    pos += 1; \n"
            + "\n"
            + "// Ponemos el item en su posición correcta\n"
            + "if (item != arr[pos]) { \n"
            + "                    int temp = item; \n"
            + "                    item = arr[pos]; \n"
            + "                    arr[pos] = temp; \n"
            + "                    writes++; \n"
            + "                } \n"
            + "            } \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        int arr[] = { 1, 8, 3, 9, 10, 10, 2, 4 }; \n"
            + "        int n = arr.length; \n"
            + "        cycleSort(arr, n); \n"
            + "        System.out.println(\"Luego de ordenar : \"); \n"
            + "        for (int i = 0; i < n; i++) \n"
            + "            System.out.print(arr[i] + \" \"); \n"
            + "} \n"
            + "} ";
    private String mergesort3way = "//Porgrama java que realiza Merge Sort de tres vias\n"
            + "public class MergeSort3Way \n"
            + "{ \n"
            + "    public static void mergeSort3Way(Integer[] gArray) \n"
            + "{   //Si el arrat tiene tamaño 0, retorna null\n"
            + "        if (gArray == null) \n"
            + "            return; \n"
            + "        //Creando duplicado del array dado\n"
            + "Integer[] fArray = new Integer[gArray.length]; \n"
            + "//Copiando elementos del array dado al\n"
            + "//array duplicado\n"
            + "        System.arraycopy(gArray, 0, fArray, 0, fArray.length); \n"
            + "        mergeSort3WayRec(fArray, 0, gArray.length, gArray); \n"
            + "//Copiando elementos del array duplicado al\n"
            + "//array dado\n"
            + "        System.arraycopy(fArray, 0, gArray, 0, fArray.length); \n"
            + "} \n"
            + "    /*Realizando el algoritmo Merge Sort en el array\n"
            + "    dado para los valores en el rando de los indices \n"
            + "    [low,high], low es el menor y high es el mayor\n"
            + "Exclusivo*/\n"
            + "    public static void mergeSort3WayRec(Integer[] gArray, \n"
            + "                  int low, int high, Integer[] destArray) \n"
            + "{ \n"
            + "        //Si el array tiene tamaño 1 no haga nada\n"
            + "if (high - low < 2) \n"
            + "            return; \n"
            + "// Separando el array en tres partes\n"
            + "        int mid1 = low + ((high - low) / 3); \n"
            + "        int mid2 = low + 2 * ((high - low) / 3) + 1; \n"
            + "// Ordenando las tres partes recursivamente\n"
            + "        mergeSort3WayRec(destArray, low, mid1, gArray); \n"
            + "mergeSort3WayRec(destArray, mid1, mid2, gArray); \n"
            + "        mergeSort3WayRec(destArray, mid2, high, gArray); \n"
            + "// Uniendo las tres partes\n"
            + "        merge(destArray, low, mid1, mid2, high, gArray); \n"
            + "    } \n"
            + "/*Une los rangos ordenados (low, mid1),(mid1,mid2)\n"
            + "    y (mid2, high), mid 1 es el primer indice punto \n"
            + "    medio en todo el rando para unir mid2 es segundo*/\n"
            + "public static void merge(Integer[] gArray, int low, \n"
            + "                           int mid1, int mid2, int high, \n"
            + "                                   Integer[] destArray) \n"
            + "    { \n"
            + "        int i = low, j = mid1, k = mid2, l = low; \n"
            + "// escoje el más pequeño de los más pequeños en los\n"
            + "//tres rangos\n"
            + "        while ((i < mid1) && (j < mid2) && (k < high)) \n"
            + "        { \n"
            + "            if (gArray[i].compareTo(gArray[j]) < 0) \n"
            + "            { \n"
            + "                if (gArray[i].compareTo(gArray[k]) < 0) \n"
            + "                    destArray[l++] = gArray[i++]; \n"
            + "\n"
            + "                else\n"
            + "                    destArray[l++] = gArray[k++]; \n"
            + "            } \n"
            + "            else\n"
            + "            { \n"
            + "                if (gArray[j].compareTo(gArray[k]) < 0) \n"
            + "                    destArray[l++] = gArray[j++]; \n"
            + "                else\n"
            + "                    destArray[l++] = gArray[k++]; \n"
            + "            } \n"
            + "        } \n"
            + "        while ((i < mid1) && (j < mid2)) \n"
            + "        { \n"
            + "            if (gArray[i].compareTo(gArray[j]) < 0) \n"
            + "                destArray[l++] = gArray[i++]; \n"
            + "            else\n"
            + "                destArray[l++] = gArray[j++]; \n"
            + "        }  \n"
            + "        while ((j < mid2) && (k < high)) \n"
            + "        { \n"
            + "            if (gArray[j].compareTo(gArray[k]) < 0) \n"
            + "                destArray[l++] = gArray[j++]; \n"
            + "\n"
            + "            else\n"
            + "                destArray[l++] = gArray[k++]; \n"
            + "     } \n"
            + "        while ((i < mid1) && (k < high)) \n"
            + "        { \n"
            + "            if (gArray[i].compareTo(gArray[k]) < 0) \n"
            + "                destArray[l++] = gArray[i++]; \n"
            + "            else\n"
            + "                destArray[l++] = gArray[k++]; \n"
            + "        } \n"
            + "        while (i < mid1) \n"
            + " destArray[l++] = gArray[i++]; \n"
            + "        while (j < mid2) \n"
            + " destArray[l++] = gArray[j++]; \n"
            + "        while (k < high) \n"
            + "            destArray[l++] = gArray[k++]; \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "\n"
            + "        Integer[] data = new Integer[] {45, -2, -45, 78, \n"
            + "                               30, -42, 10, 19, 73, 93}; \n"
            + "        mergeSort3Way(data); \n"
            + "System.out.println(\"Despues de merge sort de 3 vias: \"); \n"
            + "for (int i = 0; i < data.length; i++) \n"
            + "            System.out.print(data[i] + \" \"); \n"
            + "} \n"
            + "}";
    private String pigeonholesort = "/*Programa java que implemeta Pigeonhole Sort*/\n"
            + "import java.util.*;\n"
            + "\n"
            + "public class PigeonholeSort {\n"
            + "\n"
            + "    static void pigeonhole_sort(int arr[],\n"
            + "            int n) {\n"
            + "        int min = arr[0];\n"
            + "        int max = arr[0];\n"
            + "        int range, i, j, index;\n"
            + "        for (int a = 0; a < n; a++) {\n"
            + "            if (arr[a] > max) {\n"
            + "                max = arr[a];\n"
            + "            }\n"
            + "            if (arr[a] < min) {\n"
            + "                min = arr[a];\n"
            + "            }\n"
            + "        }\n"
            + "        range = max - min + 1;\n"
            + "        int[] phole = new int[range];\n"
            + "        Arrays.fill(phole, 0);\n"
            + "        for (i = 0; i < n; i++) {\n"
            + "            phole[arr[i] - min]++;\n"
            + "        }\n"
            + "        index = 0;\n"
            + "        for (j = 0; j < range; j++) {\n"
            + "            while (phole[j]-- > 0) {\n"
            + "                arr[index++] = j + min;\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int[] arr = {8, 3, 2, 7, 4, 6, 8};\n"
            + "        System.out.print(\"Array ordenado : \");\n"
            + "        pigeonhole_sort(arr, arr.length);\n"
            + "        for (int i = 0; i < arr.length; i++) {\n"
            + "            System.out.print(arr[i] + \" \");\n"
            + "}\n"
            + "    }\n"
            + "\n"
            + "}";
    private String ahocorasick = "//Codigo JAVA que implementa el algoritmo\n"
            + "// Aho Corasick de busqueda de palabras\n"
            + "import java.util.LinkedList;\n"
            + "import java.util.Queue;\n"
            + "\n"
            + "public class AhoCorasick {\n"
            + "\n"
            + "    static class TrieNode {\n"
            + "        private final int SIZE = 4;\n"
            + "        TrieNode parent;\n"
            + "        TrieNode fall;\n"
            + "        TrieNode[] children;\n"
            + "        char c;\n"
            + "        TrieNode next;\n"
            + "        boolean isEnd;\n"
            + "        public TrieNode() {\n"
            + "            children = new TrieNode[SIZE];\n"
            + "        }\n"
            + "\n"
            + "        public TrieNode(char c) {\n"
            + "            this();\n"
            + "            this.c = c;\n"
            + "        }\n"
            + "        public TrieNode child(char ch) {\n"
            + "            TrieNode node = children[ch % SIZE];\n"
            + "            if (node == null) {\n"
            + "                return null;\n"
            + "            } else {\n"
            + "                while (node.next != null) {\n"
            + "                    if (node.c == ch) {\n"
            + "                        return node;\n"
            + "}\n"
            + "                    node = node.next;\n"
            + "                }\n"
            + "\n"
            + "                // Caracter estaba al final de la lista\n"
            + "if (node.c == ch) {\n"
            + "                    return node;\n"
            + "                }\n"
            + "\n"
            + "                return null;\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        public void addWord(String word) {\n"
            + "            char firstChar = word.charAt(0);\n"
            + "            TrieNode child = child(firstChar);\n"
            + "            if (child == null) {\n"
            + "                child = new TrieNode(firstChar);\n"
            + "                child.parent = this;\n"
            + "                int pos = firstChar % SIZE;\n"
            + "                if (children[pos] == null) {\n"
            + "                    children[pos] = child;\n"
            + "                } else {\n"
            + "                    TrieNode node = children[pos];\n"
            + "                    while (node.next != null) {\n"
            + "                        node = node.next;\n"
            + "                    }\n"
            + "\n"
            + "                    node.next = child;\n"
            + "                }\n"
            + "            }\n"
            + "\n"
            + "            if (word.length() > 1) {\n"
            + "                child.addWord(word.substring(1));\n"
            + "            } else {\n"
            + "                child.isEnd = true;\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        public boolean contains(String word) {\n"
            + "            if (word.length() == 0) {\n"
            + "                return isEnd;\n"
            + "            } else {\n"
            + "                TrieNode node = child(word.charAt(0));\n"
            + "                if (node == null) {\n"
            + "                    return false;\n"
            + "                } else {\n"
            + "                    return node.contains(word.substring(1));\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        public void constructFallLinks() {\n"
            + "            TrieNode root = this;\n"
            + "            root.fall = root;\n"
            + "\n"
            + "            // BFS\n"
            + "            Queue<TrieNode> queue = new LinkedList<>();\n"
            + "            queue.add(root);\n"
            + "            while (!queue.isEmpty()) {\n"
            + "                TrieNode currentNode = queue.poll();\n"
            + "\n"
            + "// Agrega hijo\n"
            + "                for (int i = 0; i < SIZE; i++) {\n"
            + "                    TrieNode node = currentNode.children[i];\n"
            + "                    if (node != null) {\n"
            + "                        while (node.next != null) {\n"
            + "                            queue.add(node);\n"
            + "                            node = node.next;\n"
            + "                        }\n"
            + "                        queue.add(node);\n"
            + "                    }\n"
            + "                }\n"
            + "\n"
            + "                if (currentNode != root) {\n"
            + "// Atraviesa arriba la caida del padre para encontrar\n"
            + "                    // el sufijo más largo\n"
            + "                    //o hasta que alcanzamos la raiz del arbol\n"
            + "TrieNode f = currentNode.parent.fall;\n"
            + "                    while (f.child(currentNode.c) != null && f != root) {\n"
            + "                        f = f.fall;\n"
            + "                    }\n"
            + "                    currentNode.fall = f.child(currentNode.c);\n"
            + "\n"
            + "if (currentNode.fall == null) {\n"
            + "// Sufijo no encontrado, caemos la raiz\n"
            + "currentNode.fall = root;\n"
            + "                    }\n"
            + "\n"
            + "                    if (currentNode.fall == currentNode) {\n"
            + "currentNode.fall = root;\n"
            + "                    }\n"
            + "\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "/*Realiza una bsuqueda en el texto de la palabras\n"
            + "cotenidas en Trie*/\n"
            + "        public void search(String text) {\n"
            + "            TrieNode root = this;\n"
            + "            TrieNode currentNode = root;\n"
            + "            TrieNode node;\n"
            + "            TrieNode n;\n"
            + "            char[] chars = text.toCharArray();\n"
            + "            for (char ch : chars) {\n"
            + "                node = currentNode;\n"
            + "                while (node.child(ch) == null && node != root) {\n"
            + "                    node = node.fall;\n"
            + "                }\n"
            + "                if (node == root) {\n"
            + "                    node = node.child(ch);\n"
            + "                    if (node == null) {\n"
            + "                        node = root;\n"
            + "                    }\n"
            + "                } else {\n"
            + "                    node = node.child(ch);\n"
            + "                }\n"
            + "\n"
            + "                n = node;\n"
            + "                while (n != root) {\n"
            + "if (n.isEnd) {\n"
            + "                        System.out.println(\"Encontrada palabra que termina en \" + n.c);\n"
            + "}\n"
            + "                    n = n.fall;\n"
            + "                }\n"
            + "                currentNode = node;\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        TrieNode trie = new TrieNode();\n"
            + "        trie.addWord(\"soft\");\n"
            + "        trie.addWord(\"fo\");\n"
            + "        trie.constructFallLinks();\n"
            + "trie.search(\"abcfosoft\");\n"
            + "\n"
            + "    }\n"
            + "\n"
            + "}";
    private String anagramspattern = "// Programa java que busca todos los anagramás\n"
            + "// de un patrón en un texto \n"
            + "public class AnagramsPattern \n"
            + "{ \n"
            + "    static final int MAX = 256; \n"
            + "// Esta función retorna true si los contenidos\n"
            + "    // de arr1[] y arr2[] son iguales, de otra forma es falso\n"
            + "static boolean compare(char arr1[], char arr2[]) \n"
            + "    { \n"
            + "        for (int i = 0; i < MAX; i++) \n"
            + "            if (arr1[i] != arr2[i]) \n"
            + "return false; \n"
            + "        return true; \n"
            + "    } \n"
            + "// Esta función busca todas las permutaciones de \n"
            + "// pat[] en txt[]\n"
            + "    static void search(String pat, String txt) \n"
            + "    { \n"
            + "        int M = pat.length(); \n"
            + "        int N = txt.length(); \n"
            + "\n"
            + "// countP[]:  Almacena el conteo de todos\n"
            + "        // los caracteres del patrón\n"
            + "        // countTW[]: Almacena el conteo de los caracteres\n"
            + "        // la ventana de texto\n"
            + "        char[] countP = new char[MAX]; \n"
            + "char[] countTW = new char[MAX]; \n"
            + "        for (int i = 0; i < M; i++) \n"
            + "        { \n"
            + "            (countP[pat.charAt(i)])++; \n"
            + "            (countTW[txt.charAt(i)])++; \n"
            + "} \n"
            + "//Atravesar atravez de los caracteres restantes de patrón\n"
            + "for (int i = M; i < N; i++) \n"
            + "{   //Compara conteos de la ventana actual\n"
            + "            // de texto con los conteos de pattern[]\n"
            + "if (compare(countP, countTW)) \n"
            + "                System.out.println(\"Encontrado en indice \" + \n"
            + "(i - M));  \n"
            + "// Agreca el actual caracter a la ventana actual\n"
            + "            (countTW[txt.charAt(i)])++; \n"
            + "// Remueve el primer caracter de la anterior ventana\n"
            + "countTW[txt.charAt(i-M)]--; \n"
            + "} \n"
            + "        // Revisa por la ultima ventana en el texto\n"
            + "if (compare(countP, countTW)) \n"
            + "            System.out.println(\"Encontrado en indice \" +  \n"
            + "                                       (N - M)); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        String txt = \"BACDGABCDA\"; \n"
            + "        String pat = \"ABCD\"; \n"
            + "search(pat, txt); \n"
            + "    } \n"
            + "}";
    private String boyermoore = "/*Programa java para heuristica de malos caracteres\n"
            + "usando el algoritmo de Boyer Moore*/\n"
            + "\n"
            + "public class BoyerMoore{ \n"
            + "\n"
            + "     static int NO_OF_CHARS = 256; \n"
            + "//Una función de utilidad para obtener el maximo de\n"
            + "//dos enteros\n"
            + "\n"
            + "     static int max (int a, int b) { return (a > b)? a: b; } \n"
            + "//El preprocesado del algoritmo\n"
            + "     static void badCharHeuristic( char []str, int size,int badchar[]) \n"
            + "{ \n"
            + "      int i; \n"
            + "\n"
            + "      // Inicializa todas las ocurrencias en  -1 \n"
            + "for (i = 0; i < NO_OF_CHARS; i++) \n"
            + "badchar[i] = -1; \n"
            + "      /*Llena el actual valor de la ultima ocurrencia\n"
            + "de un caracter*/\n"
            + "      for (i = 0; i < size; i++) \n"
            + "           badchar[(int) str[i]] = i; \n"
            + "} \n"
            + "/* Una función de busqueda de patrón que usa \n"
            + "     la heuristica de mal caracter*/\n"
            + "static void search( char txt[],  char pat[]) \n"
            + "     { \n"
            + "      int m = pat.length; \n"
            + "      int n = txt.length; \n"
            + "\n"
            + "      int badchar[] = new int[NO_OF_CHARS]; \n"
            + "/* Llena el arreglo de malos caracteres llamando\n"
            + "      la función de preprocesado para el patrón dado*/\n"
            + "      badCharHeuristic(pat, m, badchar); \n"
            + "      int s = 0;  // s  es cambiado del patron con respecto al texto  \n"
            + "while(s <= (n - m)) \n"
            + "      { \n"
            + "          int j = m-1; \n"
            + "/* Mantiene reduciento el indice j para el patrón\n"
            + "          mientras los caracteres del patrón y el texto \n"
            + "          estan coincidiendo en s*/\n"
            + "          while(j >= 0 && pat[j] == txt[s+j]) \n"
            + "              j--; \n"
            + "/*Si el patrón esta presente en el actual\n"
            + "          cambio, entonces el indice j se convertira en -1\n"
            + "          luego del ciclo de arriba*/\n"
            + "          if (j < 0) \n"
            + "          { \n"
            + "              System.out.println(\"Patrón encontrado en cambio = \" + s); \n"
            + "\n"
            + "s += (s+m < n)? m-badchar[txt[s+m]] : 1; \n"
            + "\n"
            + "          } \n"
            + "\n"
            + "          else\n"
            + "\n"
            + "              s += max(1, j - badchar[txt[s+j]]); \n"
            + "      } \n"
            + "     } \n"
            + "\n"
            + "    public static void main(String []args) { \n"
            + "\n"
            + "         char txt[] = \"ABAAABCDABCABC\".toCharArray(); \n"
            + "         char pat[] = \"ABC\".toCharArray(); \n"
            + "         search(txt, pat); \n"
            + "} \n"
            + "}";
    private String finiteautomata = "// Programa java para el algoritmo\n"
            + "// Finite Automata de busqueda de patrones\n"
            + "public class FiniteAutomata {\n"
            + "\n"
            + "    static int NO_OF_CHARS = 256;\n"
            + "\n"
            + "    static int getNextState(char[] pat, int M,\n"
            + "int state, int x) {\n"
            + "// Si el caracter c es el mismo como el \n"
            + "        // siguiente en patrón, simplemente incrementa\n"
            + "        // state\n"
            + "if (state < M && x == pat[state]) {\n"
            + "return state + 1;\n"
            + "        }\n"
            + "// ns almacena el resultado el cual es \n"
            + "        // el siguiente state\n"
            + "        int ns, i;\n"
            + "/* ns finalmente contiene el prefijo más largo\n"
            + "        el cual tambien es sufijo en \"pat[0..state-1]c\"\n"
            + "        Empieza desde el valor más largo posible \n"
            + "        y se detiene cuando se encuentra un prefijo el cual\n"
            + "        es tambien sufijo*/\n"
            + "        for (ns = state; ns > 0; ns--) {\n"
            + "if (pat[ns - 1] == x) {\n"
            + "                for (i = 0; i < ns - 1; i++) {\n"
            + "                    if (pat[i] != pat[state - ns + 1 + i]) {\n"
            + "                        break;\n"
            + "                    }\n"
            + "                }\n"
            + "                if (i == ns - 1) {\n"
            + "                    return ns;\n"
            + "}\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        return 0;\n"
            + "    }\n"
            + "/*Esta función construye la tabla TF la cual\n"
            + "    representa Finite Automata del patrón dado*/\n"
            + "static void computeTF(char[] pat, int M, int TF[][]) {\n"
            + "        int state, x;\n"
            + "        for (state = 0; state <= M; ++state) {\n"
            + "            for (x = 0; x < NO_OF_CHARS; ++x) {\n"
            + "                TF[state][x] = getNextState(pat, M, state, x);\n"
            + "}\n"
            + "        }\n"
            + "    }\n"
            + "/* Imprime todas las ocurrencuas de pat en txt*/\n"
            + "static void search(char[] pat, char[] txt) {\n"
            + "        int M = pat.length;\n"
            + "        int N = txt.length;\n"
            + "        int[][] TF = new int[M + 1][NO_OF_CHARS];\n"
            + "        computeTF(pat, M, TF);\n"
            + "// Procesa txt sobre FA.\n"
            + "        int i, state = 0;\n"
            + "        for (i = 0; i < N; i++) {\n"
            + "            state = TF[state][txt[i]];\n"
            + "            if (state == M) {\n"
            + "                System.out.println(\"Patrón encontrado \"\n"
            + "                        + \"en indice \" + (i - M + 1));\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "char[] pat = \"AABAACAADAABAAABAA\".toCharArray();\n"
            + "        char[] txt = \"AABA\".toCharArray();\n"
            + "        search(txt, pat);\n"
            + "    }\n"
            + "}";
    private String kmpstringmatching = "/* Programa java implementando el algoritmo \n"
            + "de busqueda KMP*/\n"
            + "public class KMPStringMatching {\n"
            + "\n"
            + "static void KMPSearch(String pat, String txt) {\n"
            + "        int M = pat.length();\n"
            + "        int N = txt.length();\n"
            + "// Crea lps[] el cual podra mantener el\n"
            + "        // más largo prefijo sufijo para patrón\n"
            + "int lps[] = new int[M];\n"
            + "int j = 0; // indice de pat[] \n"
            + "// Preprocesa el patrón (Calcula lps[]) \n"
            + "computeLPSArray(pat, M, lps);\n"
            + "        int i = 0; // indice para txt[] \n"
            + "        while (i < N) {\n"
            + "            if (pat.charAt(j) == txt.charAt(i)) {\n"
            + "                j++;\n"
            + "                i++;\n"
            + "            }\n"
            + "            if (j == M) {\n"
            + "                System.out.println(\"Encontrado patrón \"\n"
            + "+ \"en indice \" + (i - j));\n"
            + "                j = lps[j - 1];\n"
            + "            } // no coincide luego de j veces\n"
            + "else if (i < N && pat.charAt(j) != txt.charAt(i)) {\n"
            + "/*No coincide lps[0..lps[j-1]] caracteres\n"
            + "                ellos coincidiran de todos modos*/\n"
            + "if (j != 0) {\n"
            + "                    j = lps[j - 1];\n"
            + "                } else {\n"
            + "                    i = i + 1;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static void computeLPSArray(String pat, int M, int lps[]) {\n"
            + "// Longitus del anterior prefijo sufijo más largo\n"
            + "        int len = 0;\n"
            + "        int i = 1;\n"
            + "        lps[0] = 0; // lps[0] es siempre 0\n"
            + "\n"
            + "// el ciclo calcula lps[i] para i = 1 hasta M-1 \n"
            + "while (i < M) {\n"
            + "            if (pat.charAt(i) == pat.charAt(len)) {\n"
            + "                len++;\n"
            + "                lps[i] = len;\n"
            + "                i++;\n"
            + "            } else // (pat[i] != pat[len]) \n"
            + "{\n"
            + "// Esto es dificl, considere el ejemplo\n"
            + "                // AAACAAAA y i = 7. la idea es similar\n"
            + "                // el paso de busqueda\n"
            + "                if (len != 0) {\n"
            + "                    len = lps[len - 1];\n"
            + "// Tambien, note que no incrementamos \n"
            + "//i aqui\n"
            + "                } else // if (len == 0) \n"
            + "                {\n"
            + "                    lps[i] = len;\n"
            + "                    i++;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        String txt = \"ABABDABACDABABCABAB\";\n"
            + "        String pat = \"ABABCABAB\";\n"
            + "KMPSearch(pat, txt);\n"
            + "    }\n"
            + "}";
    private String manacheralgorithm = "// Programa java implementando el algoritmo de Manacher\n"
            + "// LPS: longest palindrome string\n"
            + "public class ManacherAlgorithm {\n"
            + "\n"
            + "    static char text[];\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        text = \"babcbabcbaccba\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "        text = \"abaaba\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "        text = \"abababa\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "        text = \"abcbabcbabcba\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "        text = \"caba\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "        text = \"abacdfgdcaba\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "        text = \"abacdfgdcabba\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "        text = \"abacdedcaba\".toCharArray();\n"
            + "        findLongestPalindromicString();\n"
            + "    }\n"
            + "\n"
            + "    static int min(int a, int b) {\n"
            + "        int res = a;\n"
            + "        if (b < a) {\n"
            + "            res = b;\n"
            + "        }\n"
            + "        return res;\n"
            + "    }\n"
            + "\n"
            + "    static void findLongestPalindromicString() {\n"
            + "        int N = text.length;\n"
            + "        if (N == 0) {\n"
            + "return;\n"
            + "        }\n"
            + "        N = 2 * N + 1; //Conteo de posición\n"
            + "int L[] = new int[N]; //LPS tamaño de array\n"
            + "L[0] = 0;\n"
            + "        L[1] = 1;\n"
            + "        int C = 1; //Posición central\n"
            + "        int R = 2; //posición Centro derecho\n"
            + "        int i = 0; //Posición actual derecho\n"
            + "        int iMirror; //Posición actual izquierda\n"
            + "        int maxLPSLength = 0;\n"
            + "int maxLPSCenterPosition = 0;\n"
            + "        int start = -1;\n"
            + "        int end = -1;\n"
            + "int diff = -1;\n"
            + "//Descomentar para imprimir tamaño del arreglo LPS\n"
            + "//printf(\"%d %d \", L[0], L[1]); \n"
            + "        for (i = 2; i < N; i++) {\n"
            + "            iMirror = 2 * C - i;\n"
            + "            L[i] = 0;\n"
            + "            diff = R - i;\n"
            + "            if (diff > 0) {\n"
            + "                L[i] = min(L[iMirror], diff);\n"
            + "}\n"
            + "/*Intente expandir palíndromo centrado en currentRightPosition i\n"
            + "            Aquí para posiciones impares, comparamos caracteres y\n"
            + "            si coinciden, aumente la longitud de LPS en UNO\n"
            + "            Si la posición es igual, solo incrementamos LPS en UNO sin*/\n"
            + "try {\n"
            + "                while (((i + L[i]) < N && (i - L[i]) > 0)\n"
            + "&& (((i + L[i] + 1) % 2 == 0)\n"
            + "                        || (text[(i + L[i] + 1) / 2] == text[(i - L[i] - 1) / 2]))) {\n"
            + "                    L[i]++;\n"
            + "                }\n"
            + "            } catch (Exception e) {\n"
            + "}\n"
            + "//Comparación de cualquier caracter\n"
            + "            if (L[i] > maxLPSLength) \n"
            + "{\n"
            + "                maxLPSLength = L[i];\n"
            + "                maxLPSCenterPosition = i;\n"
            + "            }\n"
            + "            if (i + L[i] > R) {\n"
            + "                C = i;\n"
            + "                R = i + L[i];\n"
            + "}\n"
            + "//Descomentar para imprimir tamaño del arreglo LPS\n"
            + "//printf(\"%d \", L[i]); \n"
            + "        }\n"
            + "        start = (maxLPSCenterPosition - maxLPSLength) / 2;\n"
            + "        end = start + maxLPSLength - 1;\n"
            + "        System.out.println(\"LPS del string es \" + String.copyValueOf(text) + \": \");\n"
            + "\n"
            + "        for (i = start; i <= end; i++) {\n"
            + "            System.out.printf(\"%c\", text[i]);\n"
            + "\n"
            + "}\n"
            + "        System.out.println(\"\");\n"
            + "    }\n"
            + "}";
    private String rabinkarp = "/*Implementación java del algoritmo de \n"
            + "Rabin Karp*/ \n"
            + "public class RabinKarp  \n"
            + "{   // d es elnúmero de caracteres en el alfabeto de entrada\n"
            + "public final static int d = 256; \n"
            + "/* pat -> patrón \n"
            + "        txt -> texto\n"
            + "        q -> Un número primo\n"
            + "*/\n"
            + "    static void search(String pat, String txt, int q) \n"
            + "    { \n"
            + "        int M = pat.length(); \n"
            + "        int N = txt.length(); \n"
            + "int i, j; \n"
            + "        int p = 0; // valor hash  del patrón\n"
            + "        int t = 0; // valor hash  del txt \n"
            + "        int h = 1; \n"
            + "// el valor de h debe ser \"pow(d, M-1)%q\"\n"
            + "for (i = 0; i < M-1; i++) \n"
            + "            h = (h*d)%q; \n"
            + "/*Calcula el valor hash del patron y primera \n"
            + "ventana de texto*/\n"
            + "        for (i = 0; i < M; i++) \n"
            + "        { \n"
            + "            p = (d*p + pat.charAt(i))%q; \n"
            + "            t = (d*t + txt.charAt(i))%q; \n"
            + "} \n"
            + "//Desliza el patrón por encima del texto uno por uno\n"
            + "        for (i = 0; i <= N - M; i++) \n"
            + "        { \n"
            + "/*Verifica los valores hash de la actual ventana de text\n"
            + "            y patrón. Si el valor hash coincide entonces solo revisa \n"
            + "            los caratceres uno por uno*/\n"
            + "            if ( p == t ) \n"
            + "            {   /*Revisa por caracteres uno por uno*/\n"
            + "for (j = 0; j < M; j++) \n"
            + "                { \n"
            + "                    if (txt.charAt(i+j) != pat.charAt(j)) \n"
            + "                        break; \n"
            + "                } \n"
            + "// Si p==t y pat[0...M-1] = txt[i, i+1, ...i+M-1] \n"
            + "if (j == M) \n"
            + "                    System.out.println(\"Patron encontrado en el indice \" + i); \n"
            + "            } \n"
            + "// Calcula el valor hash de la siguiente ventana de texto\n"
            + "            // Remueve el digito lider, y final\n"
            + "if ( i < N-M ) \n"
            + "            { \n"
            + "                t = (d*(t - txt.charAt(i)*h) + txt.charAt(i+M))%q; \n"
            + "/*Nosotros obtendremos un valor negativo de t\n"
            + "                convirtiendolo a positivo*/\n"
            + "                if (t < 0) \n"
            + "t = (t + q); \n"
            + "            } \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        String txt = \"EQUIPO ARTEMIS\"; \n"
            + "        String pat = \"ARTE\"; \n"
            + "int q = 101; // un número primo\n"
            + "        search(pat, txt, q); \n"
            + "    } \n"
            + "}  ";
    private String wildcardpattern = "//Programa java que implementa el cotejamiento\n"
            + "// de patrones con Wildcard\n"
            + "import java.util.Arrays;\n"
            + "\n"
            + "public class WildcardPattern {\n"
            + "//Función que coteja str con el patron wildcard\n"
            + "static boolean strmatch(String str, String pattern,\n"
            + "int n, int m) {\n"
            + "// Patron vacio colo puede coincidir \n"
            + "// con string vacio\n"
            + "        if (m == 0) {\n"
            + "            return (n == 0);\n"
            + "}\n"
            + "// Tabla de busqueda para almacenar resultados\n"
            + "// de subproblemás\n"
            + "        boolean[][] lookup = new boolean[n + 1][m + 1];\n"
            + "        //Inicializa la tabla en falso\n"
            + "        for (int i = 0; i < n + 1; i++) {\n"
            + "            Arrays.fill(lookup[i], false);\n"
            + "}\n"
            + "        lookup[0][0] = true;\n"
            + "//Solo '*' puede coincidri con string vacio\n"
            + "for (int j = 1; j <= m; j++) {\n"
            + "            if (pattern.charAt(j - 1) == '*') {\n"
            + "lookup[0][j] = lookup[0][j - 1];\n"
            + "            }\n"
            + "        }\n"
            + "// Llena la yabla \n"
            + "for (int i = 1; i <= n; i++) {\n"
            + "            for (int j = 1; j <= m; j++) {\n"
            + "/*Dos casos que podemos ver de '*'\n"
            + "                a) Ignoramos '*' y pasamos al siguiente\n"
            + "                caracter en el patrón\n"
            + "                b) '*' coincide con un iesimo\n"
            + "                caracter en una entrada*/\n"
            + "\n"
            + "                if (pattern.charAt(j - 1) == '*') {\n"
            + "lookup[i][j] = lookup[i][j - 1]\n"
            + "|| lookup[i - 1][j];\n"
            + "                } \n"
            + "/*Actuales caracteres son considerados \n"
            + "                como coincidentes en dos casos\n"
            + "                a) actual caracter de patron es '?'\n"
            + "b) caracteres actuales coinciden*/\n"
            + "                else if (pattern.charAt(j - 1) == '?'\n"
            + "                        || str.charAt(i - 1) == pattern.charAt(j - 1)) {\n"
            + "                    lookup[i][j] = lookup[i - 1][j - 1];\n"
            + "} // Si el caracter no coincide\n"
            + "                else {\n"
            + "lookup[i][j] = false;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "        return lookup[n][m];\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        String str = \"baaabab\";\n"
            + "        String pattern = \"*****ba*****ab\";\n"
            + "//Casos de prueba \n"
            + "// String pattern = \"ba*****ab\";\n"
            + "// String pattern = \"ba*ab\";\n"
            + "        // String pattern = \"a*ab\";\n"
            + "        // String pattern = \"a*****ab\";\n"
            + "        // String pattern = \"*a*****ab\";\n"
            + "        // String pattern = \"ba*ab****\";\n"
            + "        // String pattern = \"****\";\n"
            + "        // String pattern = \"*\";\n"
            + "        // String pattern = \"aa?ab\";\n"
            + "        // String pattern = \"b*b\";\n"
            + "        // String pattern = \"a*a\";\n"
            + "        // String pattern = \"baaabab\";\n"
            + "        // String pattern = \"?baaabab\";\n"
            + "        // String pattern = \"*baaaba*\"; \n"
            + "\n"
            + "        if (strmatch(str, pattern, str.length(),\n"
            + "                pattern.length())) {\n"
            + "            System.out.println(\"Si\");\n"
            + "        } else {\n"
            + "            System.out.println(\"No\");\n"
            + "}\n"
            + "\n"
            + "    }\n"
            + "}";
    private String gcdlcm = "//Programa java que realiza\n"
            + "//Maximo comun divisor y minimo comun multiplo\n"
            + "public class GCDLCM {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "int a =8,b=12;\n"
            + "        System.out.println(\"GCD de a y b es :\"+gcd(a, b));\n"
            + "        System.out.println(\"LCM de a y b es :\"+lcm(a, b));\n"
            + "}\n"
            + "//Maximo Comun Divisor\n"
            + "    public static int gcd(int a, int b) {\n"
            + "        return b == 0 ? a : gcd(b, a % b);\n"
            + "    }\n"
            + "//Minimo Comun Multiplo\n"
            + "    public static int lcm(int a, int b) {\n"
            + "        return a * (b / gcd(a, b));\n"
            + "}\n"
            + "}";
    private String primalitytest = "//Programa java que verifica si un número\n"
            + "// es primo o no\n"
            + "public class PrimalityTest {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        boolean isprime = false;\n"
            + "        int n = 5;\n"
            + "        if (isPrime(n)) {\n"
            + "            System.out.println(\"Es primo\");\n"
            + "} else {\n"
            + "            System.out.println(\"No es primo\");\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "//Prueba de primalidad\n"
            + "public static boolean isPrime(int x) {\n"
            + "        if (x < 2) {\n"
            + "            return false;\n"
            + "        }\n"
            + "        if (x == 2) {\n"
            + "            return true;\n"
            + "        }\n"
            + "        if (x % 2 == 0) {\n"
            + "            return false;\n"
            + "        }\n"
            + "        for (int i = 3; i * i <= x; i++) {\n"
            + "            if (x % i == 0) {\n"
            + "                return false;\n"
            + "}\n"
            + "        }\n"
            + "        return true;\n"
            + "    }\n"
            + "\n"
            + "}";
    private String primefactors = "//Programa que descompone un número n\n"
            + "// en sus factores primos\n"
            + "public class PrimeFactors {\n"
            + "\n"
            + "public static void main(String[] args) {\n"
            + "        primeFactors(12);\n"
            + "    }\n"
            + "//Descomposicion en factores primos\n"
            + "    public static void primeFactors(int N) {\n"
            + "        for (long p = 2; p * p <= N; ++p) {\n"
            + "            while (N % p == 0) {\n"
            + "                System.out.println(p);\n"
            + "                N /= p;\n"
            + "            }\n"
            + "        }\n"
            + "        if (N > 1) {\n"
            + "            System.out.println(N);\n"
            + "}\n"
            + "    }\n"
            + "\n"
            + "}";
    private String divisibilitybysmallnumbers = "//Programa que verifica la divisibilidad de un \n"
            + "// número entre los números 1 a 12\n"
            + "public class DivisibilityBySmallNumbers {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        boolean[] res = divisility(12);\n"
            + "        for (int i = 0; i < res.length; i++) {\n"
            + "            System.out.println(i+\" : \"+res[i]);\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static public boolean[] divisility(int num) {\n"
            + "        String M = String.valueOf(num);\n"
            + "        int n=M.length();\n"
            + "        boolean[] isMultipleOf = new boolean[13];\n"
            + "        int sum = 0;\n"
            + "        for (char c : M.toCharArray()) {\n"
            + "            sum += c - '0';\n"
            + "        }\n"
            + "        int lastDigit = M.charAt(n - 1) - '0';\n"
            + "//Divisibilidad entre 1\n"
            + "        isMultipleOf[1] = true;\n"
            + "//Divisibilidad entre 2\n"
            + "        isMultipleOf[2] = lastDigit % 2 == 0;\n"
            + "//Divisibilidad entre 3\n"
            + "        isMultipleOf[3] = sum % 3 == 0;\n"
            + "//Divisibilidad entre 4\n"
            + "if (n > 1) {\n"
            + "            isMultipleOf[4] = Integer.parseInt(M.substring(n - 2, n)) % 4 == 0;\n"
            + "} else {\n"
            + "            isMultipleOf[4] = lastDigit % 4 == 0;\n"
            + "        }\n"
            + "        //Divisibilidad entre 5\n"
            + "        isMultipleOf[5] = lastDigit == 0 || lastDigit == 5;\n"
            + "        //Divisibilidad entre 6\n"
            + "isMultipleOf[6] = isMultipleOf[2] && isMultipleOf[3];\n"
            + "        int altSum = 0;\n"
            + "        int[] pattern = {1, 3, 2, -1, -3, -2};\n"
            + "        int j = 0;\n"
            + "        for (int i = n - 1; i >= 0; i--) {\n"
            + "            altSum += pattern[j] * (M.charAt(i) - '0');\n"
            + "j = (j + 1) % 6;\n"
            + "        }\n"
            + "        //Divisibilidad entre 7\n"
            + "        isMultipleOf[7] = Math.abs(altSum) % 7 == 0;\n"
            + "//Divisibilidad entre 8\n"
            + "        if (n > 2) {\n"
            + "            isMultipleOf[8] = Integer.parseInt(M.substring(n - 3, n)) % 8 == 0;\n"
            + "        } else {\n"
            + "isMultipleOf[8] = Integer.parseInt(M) % 8 == 0;\n"
            + "        }\n"
            + "        //Divisibilidad entre 9\n"
            + "        isMultipleOf[9] = sum % 8 == 0;\n"
            + "//Divisibilidad entre 10\n"
            + "        isMultipleOf[10] = lastDigit == 0;\n"
            + "altSum = 0;\n"
            + "        int s = 1;\n"
            + "        for (int i = n - 1; i >= 0; i--) {\n"
            + "            altSum += s * (M.charAt(i) - '0');\n"
            + "s = -s;\n"
            + "        }\n"
            + "//Divisibilidad entre 11\n"
            + "        isMultipleOf[11] = Math.abs(altSum) % 11 == 0;\n"
            + "        //Divisibilidad entre 12\n"
            + "isMultipleOf[12] = isMultipleOf[3] && isMultipleOf[4];\n"
            + "        return isMultipleOf;\n"
            + "}\n"
            + "}";
    private String numberofdivisors = "//Programa java que cuenta el número\n"
            + "// de divisores de x\n"
            + "public class NumberOfDivisors {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "System.out.println(divisors(56));\n"
            + "    }\n"
            + "\n"
            + "//Todos los divisores de un número\n"
            + "public static int divisors(int x) {\n"
            + "        int nDiv = 1;\n"
            + "        for (int p = 2; p * p <= x; ++p) {\n"
            + "            int cnt = 0;\n"
            + "            while (x % p == 0) {\n"
            + "                ++cnt;\n"
            + "                x /= p;\n"
            + "            }\n"
            + "            nDiv *= cnt + 1;\n"
            + "        }\n"
            + "        if (x > 1) {\n"
            + "            nDiv *= 2;\n"
            + "        }\n"
            + "        return nDiv;\n"
            + "\n"
            + "}\n"
            + "\n"
            + "}";
    private String primenumbers = "//Programa java que encuentra todos los números \n"
            + "//primos bajo N\n"
            + "import java.util.Arrays;\n"
            + "\n"
            + "public class PrimeNumbers {\n"
            + "\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        boolean[] res = sieveEratostenes(100);\n"
            + "        for (int i = 0; i < res.length; i++) {\n"
            + "            System.out.println(i+\" : \"+res[i]);\n"
            + "}\n"
            + "    }\n"
            + "\n"
            + "//Criba de Eratostenes (Todos los primos bajo un número)\n"
            + "public static boolean[] sieveEratostenes(int N) {\n"
            + "        boolean[] prime = new boolean[N + 1];\n"
            + "        Arrays.fill(prime, true);\n"
            + "        prime[0] = prime[1] = false;\n"
            + "        for (int p = 2; p * p <= N; p++) {\n"
            + "            if (prime[p]) {\n"
            + "                for (int i = p * p; i <= N; i += p) {\n"
            + "                    prime[i] = false;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "        return prime;\n"
            + "}\n"
            + "\n"
            + "}";
    private String fibonaccilastdigit = "// Programa java que encuentra el ultimo digito \n"
            + "// de un nesimo número fibonacci\n"
            + "public class FibonacciLastDigit {\n"
            + "//Funcion que retona el nesimo\n"
            + "    // Número de fibonacci\n"
            + "static long fib(long n) {\n"
            + "        long F[][] = new long[][]{{1, 1}, {1, 0}};\n"
            + "        if (n == 0) {\n"
            + "            return 0;\n"
            + "        }\n"
            + "        power(F, n - 1);\n"
            + "        return F[0][0];\n"
            + "}\n"
            + "//Función que multiplica dos\n"
            + "    // matrices y almacera el resultado en la primera\n"
            + "static void multiply(long F[][], long M[][]) {\n"
            + "        long x = F[0][0] * M[0][0]\n"
            + "                + F[0][1] * M[1][0];\n"
            + "        long y = F[0][0] * M[0][1]\n"
            + "                + F[0][1] * M[1][1];\n"
            + "        long z = F[1][0] * M[0][0]\n"
            + "                + F[1][1] * M[1][0];\n"
            + "        long w = F[1][0] * M[0][1]\n"
            + "                + F[1][1] * M[1][1];\n"
            + "        F[0][0] = x;\n"
            + "        F[0][1] = y;\n"
            + "        F[1][0] = z;\n"
            + "        F[1][1] = w;\n"
            + "    }\n"
            + "    static void power(long F[][], long n) {\n"
            + "        if (n == 0 || n == 1) {\n"
            + "            return;\n"
            + "        }\n"
            + "        long M[][] = new long[][]{{1, 1}, {1, 0}};\n"
            + "        power(F, n / 2);\n"
            + "        multiply(F, F);\n"
            + "if (n % 2 != 0) {\n"
            + "multiply(F, M);\n"
            + "}\n"
            + "    }\n"
            + "// Retorna el ultimo digito \n"
            + "// nesimo número fibonacci\n"
            + "public static long findLastDigit(long n) {\n"
            + "        return (fib(n) % 10);\n"
            + "    }\n"
            + "    public static void main(String[] args) {\n"
            + "        int n;\n"
            + "        n = 1;\n"
            + "        System.out.println(findLastDigit(n));\n"
            + "        n = 61;\n"
            + "        System.out.println(findLastDigit(n));\n"
            + "        n = 7;\n"
            + "        System.out.println(findLastDigit(n));\n"
            + "        n = 67;\n"
            + "        System.out.println(findLastDigit(n));\n"
            + "}\n"
            + "}";
    private String longfibonacci = "//Porgrama java que busca el nesimo número\n"
            + "// de fibonacci cuando n puede ser muy largo\n"
            + "import java.math.*; \n"
            + "\n"
            + "public class LongFibonacci \n"
            + "{ \n"
            + "    static BigInteger fib(int n) \n"
            + "    { \n"
            + "        BigInteger a = BigInteger.valueOf(0); \n"
            + "        BigInteger b = BigInteger.valueOf(1); \n"
            + "        BigInteger c = BigInteger.valueOf(1); \n"
            + "        for (int j=2 ; j<=n ; j++) \n"
            + "        { \n"
            + "            c =  a.add(b); \n"
            + "            a = b; \n"
            + "            b = c; \n"
            + "        } \n"
            + "        return (a); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "{ \n"
            + "        int n = 1000; \n"
            + "        System.out.println(\"Fibonacci de  \" + n + \n"
            + "            \" termino\" + \" \" +\"es\" +\" \" + fib(n)); \n"
            + "    } \n"
            + "}";
    private String isfibonumber = "// Programa que verifica si x es número fibonacci\n"
            + "public class IsFiboNumber\n"
            + "{   // Función que retorna si x es cuadrado perfecto\n"
            + "static  boolean isPerfectSquare(int x) \n"
            + "    { \n"
            + "        int s = (int) Math.sqrt(x); \n"
            + "return (s*s == x); \n"
            + "    } \n"
            + "    //Función que verifica si es número fibonacci\n"
            + "static boolean isFibonacci(int n) \n"
            + "{   // N es fibinacci si uno de 5*n*n+4 o or 5*n*n - 4\n"
            + "        // o ambos son cuadrados perfectos\n"
            + "        return isPerfectSquare(5*n*n + 4) || \n"
            + "isPerfectSquare(5*n*n - 4); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        for (int i = 1; i <= 10; i++) \n"
            + "             System.out.println(isFibonacci(i) ?  i +  \" Es un número de fibonacci\" : \n"
            + "                                                  i + \" No es un número de fibonacci\"); \n"
            + "    } \n"
            + "}";
    private String allpermutations = "//Programa java que imprime todas las permutaciones\n"
            + "// de un conjunto \n"
            + "import java.util.HashSet;\n"
            + "import java.util.Iterator;\n"
            + "import java.util.Set;\n"
            + "\n"
            + "public class AllPermutations {\n"
            + "\n"
            + "    static Set<String> permutations;\n"
            + "    static Set<String> result = new HashSet<String>();\n"
            + "\n"
            + "    public static Set<String> permutation(String string) {\n"
            + "        permutations = new HashSet<>();\n"
            + "\n"
            + "        int n = string.length();\n"
            + "        for (int i = n - 1; i >= 0; i--) {\n"
            + "            shuffle(string.charAt(i));\n"
            + "        }\n"
            + "        return permutations;\n"
            + "    }\n"
            + "\n"
            + "    private static void shuffle(char c) {\n"
            + "        if (permutations.isEmpty()) {\n"
            + "            permutations.add(String.valueOf(c));\n"
            + "        } else {\n"
            + "            Iterator<String> it = permutations.iterator();\n"
            + "            for (int i = 0; i < permutations.size(); i++) {\n"
            + "\n"
            + "                String temp1;\n"
            + "                for (; it.hasNext();) {\n"
            + "                    temp1 = it.next();\n"
            + "                    for (int k = 0; k < temp1.length() + 1; k += 1) {\n"
            + "                        StringBuilder sb = new StringBuilder(temp1);\n"
            + "\n"
            + "                        sb.insert(k, c);\n"
            + "\n"
            + "                        result.add(sb.toString());\n"
            + "                    }\n"
            + "                }\n"
            + "            }\n"
            + "            permutations = result;\n"
            + "            result = new HashSet<>();\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        Set<String> finalresult = permutation(\"1234\");\n"
            + "        System.out.println(\"\\nHay en total \" + finalresult.size() + \" permutaciones:\");\n"
            + "        Iterator<String> it = finalresult.iterator();\n"
            + "        while (it.hasNext()) {\n"
            + "            System.out.println(it.next());\n"
            + "}\n"
            + "    }\n"
            + "}";
    private String combination = "//Programa java que imprime todas las combinaciones\n"
            + "// de tamaño r en un arreglo de tamaño n\n"
            + "public class Combination {\n"
            + "\n"
            + "/* arr[] ---> Array de entrada\n"
            + "data[] ---> Array temporal que almacenara la combinación actual\n"
            + "    start & end --->  Iniciando y terminando indices en arr[]\n"
            + "    index ---> Actual indice en data[]\n"
            + "    r ---> Tamaño de una combinacion a ser impresa*/\n"
            + "static void combinationUtil(int arr[], int data[], int start,\n"
            + "            int end, int index, int r) {\n"
            + "// Actual combinación esta lsta para ser impresa, se imprime\n"
            + "if (index == r) {\n"
            + "            for (int j = 0; j < r; j++) {\n"
            + "                System.out.print(data[j] + \" \");\n"
            + "            }\n"
            + "            System.out.println(\"\");\n"
            + "            return;\n"
            + "        }\n"
            + "\n"
            + "        for (int i = start; i <= end && end - i + 1 >= r - index; i++) {\n"
            + "            data[index] = arr[i];\n"
            + "            combinationUtil(arr, data, i + 1, end, index + 1, r);\n"
            + "        }\n"
            + "    }\n"
            + "    static void printCombination(int arr[], int n, int r) {\n"
            + "        int data[] = new int[r];\n"
            + "        combinationUtil(arr, data, 0, n - 1, 0, r);\n"
            + "    }\n"
            + "    public static void main(String[] args) {\n"
            + "        int arr[] = {1, 2, 3, 4, 5};\n"
            + "        int r = 3;\n"
            + "        int n = arr.length;\n"
            + "printCombination(arr, n, r);\n"
            + "    }\n"
            + "}";
    private String combinationscompose = "//Programa java que imprime todas\n"
            + "//las combinaciones que pueden componer un número dado\n"
            + "public class CombinationsCompose {\n"
            + "//Función imprime todas las combinaciones de números 1, 2, ...MAX_POINT\n"
            + "    // que su suma resulte  n\n"
            + "    // i es usado en recursion para mantener revisión del indice\n"
            + "    // en arr[] donde el siguiente elemento sera añadido\n"
            + "    // Valor inicial de i debe ser pasado como 0\n"
            + "\n"
            + "static void printCompositions(int arr[], int n, int i) {\n"
            + "        int MAX_POINT = 3;\n"
            + "        if (n == 0) {\n"
            + "            printArray(arr, i);\n"
            + "        } else if (n > 0) {\n"
            + "            for (int k = 1; k <= MAX_POINT; k++) {\n"
            + "                arr[i] = k;\n"
            + "                printCompositions(arr, n - k, i + 1);\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "// Imprime array\n"
            + "    static void printArray(int arr[], int m) {\n"
            + "        for (int i = 0; i < m; i++) {\n"
            + "            System.out.print(arr[i] + \" \");\n"
            + "        }\n"
            + "        System.out.println();\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int n = 5;\n"
            + "        int size = 100;\n"
            + "        int[] arr = new int[size];\n"
            + "System.out.println(\"Diferentes composiciones formadas por 1, 2 y 3 de \" + n + \" son \");\n"
            + "        printCompositions(arr, n, 0);\n"
            + "    }\n"
            + "}";
    private String allsets = "//Programa java que imprime todos los subconjuntos de \n"
            + "//un conjunto\n"
            + "public class Allsets {\n"
            + "    static void printSubsets(char set[]) {\n"
            + "int n = set.length;\n"
            + "// Ejecuta un ciclo imprimiendo todos\n"
            + "        //  los subconjuntos 2^n uno por uno\n"
            + "for (int i = 0; i < (1 << n); i++) {        \n"
            + "System.out.print(\"{ \");\n"
            + "//Imprime el subconjunto actual\n"
            + "            for (int j = 0; j < n; j++) // (1<<j) es un número con jesimo bit 1\n"
            + "{\n"
            + "                if ((i & (1 << j)) > 0) {\n"
            + "                    System.out.print(set[j] + \" \");\n"
            + "                }\n"
            + "            }\n"
            + "            System.out.println(\"}\");\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        char set[] = {'a', 'b', 'c'};\n"
            + "printSubsets(set);\n"
            + "    }\n"
            + "}";
    private String hanoitowels = "//Programa java que calcula los movimientos\n"
            + "// necesarios para completar las torres de Hanoi\n"
            + "// Sin importar el número de discos n\n"
            + "public class HanoiTowels {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "//Número de discos\n"
            + "        int n;\n"
            + "        n = 8;\n"
            + "        hanoi(n, \"Primera torre\", \"Segunda torre\", \"Tercera torre\");\n"
            + "    }\n"
            + "    static int paso = 1;\n"
            + "//Función recursiva de busqueda\n"
            + "static void hanoi(int n, String from, String temp, String to) {\n"
            + "        if (n == 0) {\n"
            + "            return;\n"
            + "        }\n"
            + "        hanoi(n - 1, from, to, temp);\n"
            + "        System.out.println(paso + \": Mover disco \" + n + \" de \" + from + \" a \" + to);\n"
            + "        paso++;\n"
            + "        hanoi(n - 1, temp, from, to);\n"
            + "}\n"
            + "\n"
            + "}";
    private String axplusbyequalsn = "//Programa que calcula la solución de\n"
            + "// ax + by = n \n"
            + "\n"
            + "public class AXplusBYequalsN { \n"
            + "\n"
            + "    static void solution(int a, int b, int n) \n"
            + "{ \n"
            + "//A traves de todos los posibles valores\n"
            + "for (int i = 0; i * a <= n; i++) \n"
            + "{ \n"
            + "//Verifica si se satisface la ecuación\n"
            + "if ((n - (i * a)) % b == 0) \n"
            + "            { \n"
            + "                System.out.println(\"x = \" + i +  \n"
            + "                                   \", y = \" +  \n"
            + "                                   (n - (i * a)) / b);     \n"
            + "                return ; \n"
            + "} \n"
            + "        } \n"
            + "\n"
            + "        System.out.println(\"Sin solución\"); \n"
            + "} \n"
            + "\n"
            + "    public static void main (String[] args)  \n"
            + "    { \n"
            + "        int a = 2, b = 3, n = 7; \n"
            + "        solution(a, b, n); \n"
            + "\n"
            + "} \n"
            + "}";
    private String amodxequalb = "/* Programa java que encuentra x tal que\n"
            + "a % x es igual  b.*/\n"
            + "public class AmodXequalB {\n"
            + "\n"
            + "    static void modularEquation(int a, int b) {\n"
            + "// Si a es menos que b, entonces no hay solución\n"
            + "if (a < b) {\n"
            + "            System.out.println(\"No solution possible \");\n"
            + "return;\n"
            + "        }\n"
            + "/*Si a es igual a b, entonces cada número \n"
            + "        más grande que a sera la solución, entonces\n"
            + "        es infinito*/\n"
            + "        if (a == b) {\n"
            + "System.out.println(\"Infinite Solution possible \");\n"
            + "return;\n"
            + "        }\n"
            + "/*todo el número resultante debe ser mayor\n"
            + "        que b y (a-b) deben ser divisibles\n"
            + "        por número resultante\n"
            + "        variable count almacena el número de\n"
            + "        valores posibles*/ \n"
            + "        int count = 0;\n"
            + "        int n = a - b;\n"
            + "        int y = (int) Math.sqrt(a - b);\n"
            + "        for (int i = 1; i <= y; ++i) {\n"
            + "if (n % i == 0) {\n"
            + "/*Revisando por ambos divisor y \n"
            + "                cociente cual divide (a-b) completamente\n"
            + "y mayor que b*/  \n"
            + "                if (n / i > b) {\n"
            + "                    count++;\n"
            + "}\n"
            + "                if (i > b) {\n"
            + "                    count++;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "/* Aqui y es añadido dos veces en la\n"
            + "        ultima iteracón entonces y deberia ser decrementado\n"
            + "        para obtener la solución correcta*/ \n"
            + "if (y * y == n && y > b) {\n"
            + "            count--;\n"
            + "        }\n"
            + "        System.out.println(count);\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int a = 21, b = 5;\n"
            + "        modularEquation(a, b);\n"
            + "}\n"
            + "}";
    private String factorial = "// Programa java que encuentra el \n"
            + "// factorial de un número\n"
            + "public class Factorial {\n"
            + "static int factorial(int n) {\n"
            + "        if (n == 0) {\n"
            + "            return 1;\n"
            + "        }\n"
            + "\n"
            + "        return n * factorial(n - 1);\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "int num = 5;\n"
            + "        System.out.println(\"Factorial de \" + num + \" es \" + factorial(5));\n"
            + "    }\n"
            + "}";
    private String bigfactorial = "// Programa java que calcula factoriales\n"
            + "// de números enormes\n"
            + "\n"
            + "public class BigFactorial { \n"
            + "\n"
            + "    static void factorial(int n) \n"
            + "    { \n"
            + "        int res[] = new int[500]; \n"
            + "        res[0] = 1; \n"
            + "int res_size = 1; \n"
            + "// Aplicamos la formula normal de facotorial\n"
            + "// n! = 1 * 2 * 3 * 4...*n \n"
            + "        for (int x = 2; x <= n; x++) \n"
            + "            res_size = multiply(x, res, res_size); \n"
            + "\n"
            + "        System.out.println(\"Factorial of given number is \"); \n"
            + "        for (int i = res_size - 1; i >= 0; i--) \n"
            + "            System.out.print(res[i]); \n"
            + "    } \n"
            + "\n"
            + "    static int multiply(int x, int res[], int res_size) \n"
            + "{ \n"
            + "        int carry = 0; // inicializar carry\n"
            + "// Uno por uno multiplicamos n con \n"
            + "        //los digitos individuales de res[] \n"
            + "for (int i = 0; i < res_size; i++) \n"
            + "        { \n"
            + "            int prod = res[i] * x + carry; \n"
            + "res[i] = prod % 10; //Almacenar ultimo digito de  \n"
            + "// 'prod' en res[] \n"
            + "            carry = prod/10; // Poner el resto de carry \n"
            + "        } \n"
            + "        //Pone el carry en res e incrementa el tamaño del resultadolt size \n"
            + "while (carry!=0) \n"
            + "        { \n"
            + "            res[res_size] = carry % 10; \n"
            + "            carry = carry / 10; \n"
            + "            res_size++; \n"
            + "        } \n"
            + "        return res_size; \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "{ \n"
            + "        factorial(100); \n"
            + "    } \n"
            + "}";
    private String binomialcoefficients = "// Programa java que  calcula el valor\n"
            + "// de coeficientes binomiales\n"
            + "public class BinomialCoefficients { \n"
            + "// Retorna el valor del coeficiente binomial\n"
            + "// C(n, k) \n"
            + "    static int binomialCoeff(int n, int k)  \n"
            + "    { \n"
            + "\n"
            + "// Casos base\n"
            + "        if (k == 0 || k == n) \n"
            + "            return 1; \n"
            + "\n"
            + "// Recursión\n"
            + "        return binomialCoeff(n - 1, k - 1) +  \n"
            + "                    binomialCoeff(n - 1, k); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args)  \n"
            + "   { \n"
            + "        int n = 5, k = 2; \n"
            + "        System.out.printf(\"Valor de C(%d, %d) is %d \", \n"
            + "                        n, k, binomialCoeff(n, k)); \n"
            + "} \n"
            + "}";
    private String cassiniidentity = "//Programa java que demuestra \n"
            + "// la identidad de Cassini\n"
            + "\n"
            + "public class CassiniIdentity\n"
            + "{ \n"
            + "// Retorna (-1)^n \n"
            + "static int cassini(int n) \n"
            + "    { \n"
            + "       return (n & 1) != 0 ? -1 : 1; \n"
            + "    }  \n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "         int n = 5; \n"
            + "         System.out.println(cassini(n)); \n"
            + "} \n"
            + "}";
    private String epowx = "// Programa eficiente que calcula e elevado x\n"
            + "public class EpowX {\n"
            + "// Función que retorna aproximado de e^x\n"
            + "    // Usando suma de los primeros n terminos\n"
            + "// de la serie de Taylor \n"
            + "    static float exponential(int n, float x) {\n"
            + "        float sum = 1;\n"
            + "        for (int i = n - 1; i > 0; --i) {\n"
            + "            sum = 1 + x * sum / i;\n"
            + "        }\n"
            + "        return sum;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int n = 10;\n"
            + "        float x = 1;\n"
            + "        System.out.println(\"e^x = \" + exponential(n, x));\n"
            + "}\n"
            + "}";
    private String euclideulertheorem = "//Programa que verifica el teorema de Euclides Euler\n"
            + "import java.util.ArrayList;\n"
            + "\n"
            + "public class EuclidEulerTheorem {\n"
            + "\n"
            + "    static ArrayList<Long> power2 = new ArrayList<Long>();\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "//Almacenando potencias de 2 para acceder \n"
            + "        // en tiempo O(1) \n"
            + "for (int i = 0; i < 62; i++) {\n"
            + "            power2.add(0L);\n"
            + "        }\n"
            + "\n"
            + "        for (int i = 0; i <= 60; i++) {\n"
            + "            power2.set(i, (1L << i));\n"
            + "}\n"
            + "        System.out.println(\"Generando los primeros números que satisfacen el teorema de Euclid Euler\\n\");\n"
            + "for (long i = 2; i <= 25; i++) {\n"
            + "            long no = ((power2.get((int) i) - 1L) * (power2.get((int) (i - 1))));\n"
            + "            if (isperfect(no) && (no % 2 == 0)) {\n"
            + "                System.out.println(\"(2^\" + i + \" - 1) * (2^(\" + i + \" - 1)) = \" + no + \"\\n\");\n"
            + "\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static boolean isperfect(long n) // Números perfectos\n"
            + "{   /* Verifica si n es suma perfecta de dividores\n"
            + "        excepto por el número en si mismo*/\n"
            + "long s = -n;\n"
            + "        for (long i = 1; i * i <= n; i++) {\n"
            + "// es i un divisor de n\n"
            + "if (n % i == 0) {\n"
            + "                long factor1 = i, factor2 = n / i;\n"
            + "                s += factor1 + factor2;\n"
            + "// aqui i*i == n\n"
            + "                if (factor1 == factor2) {\n"
            + "                    s -= i;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "        return (n == s);\n"
            + "    }\n"
            + "\n"
            + "    boolean isprime(long n) {\n"
            + "// Verifica cual número es primo o no\n"
            + "for (int i = 2; i * i <= n; i++) {\n"
            + "            if (n % i == 0) {\n"
            + "                return false;\n"
            + "}\n"
            + "        }\n"
            + "        return false;\n"
            + "    }\n"
            + "}";
    private String euclideanalgorithm = "//Programa java que demuestra el algoritmo de Euclides  \n"
            + "public class  EuclideanAlgorithm\n"
            + "{ \n"
            + "// Algoritmo de euclides extendido\n"
            + "public static int gcd(int a, int b) \n"
            + "    { \n"
            + "        if (a == 0) \n"
            + "            return b;    \n"
            + "        return gcd(b%a, a); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        int a = 10, b = 15, g; \n"
            + "        g = gcd(a, b); \n"
            + "        System.out.println(\"GCD(\" + a +  \" , \" + b+ \") = \" + g); \n"
            + "\n"
            + "        a = 35; b = 10; \n"
            + "        g = gcd(a, b); \n"
            + "        System.out.println(\"GCD(\" + a +  \" , \" + b+ \") = \" + g); \n"
            + "\n"
            + "        a = 31; b = 2; \n"
            + "        g = gcd(a, b); \n"
            + "        System.out.println(\"GCD(\" + a +  \" , \" + b+ \") = \" + g); \n"
            + "\n"
            + "} \n"
            + "}";
    private String eulertotient = "// Programa simple que calcula el valor \n"
            + "// de la función  totient Euler\n"
            + "public class EulerTotient { \n"
            + "// Función que retorna gcd de a y b\n"
            + "static int gcd(int a, int b) \n"
            + "    { \n"
            + "        if (a == 0) \n"
            + "            return b; \n"
            + "        return gcd(b % a, a); \n"
            + "} \n"
            + "// Función que evalua función totient de euler\n"
            + "static int phi(int n) \n"
            + "    { \n"
            + "        int result = 1; \n"
            + "        for (int i = 2; i < n; i++) \n"
            + "            if (gcd(i, n) == 1) \n"
            + "                result++; \n"
            + "        return result; \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        int n; \n"
            + "\n"
            + "        for (n = 1; n <= 10; n++) \n"
            + "            System.out.println(\"phi(\" + n + \") = \" + phi(n)); \n"
            + "} \n"
            + "}";
    private String factorialnumdigits = "// Programa java que encuentra número de \n"
            + "// digitos en un factorial\n"
            + "public class FactorialNumDigits  \n"
            + "{   // Retorna el número de digtos\n"
            + "    // en n! \n"
            + "static int findDigits(int n) \n"
            + "{   // Factorial existe solo para n>=0 \n"
            + "if (n < 0) \n"
            + "            return 0; \n"
            + "// Caso base\n"
            + "        if (n <= 1) \n"
            + "return 1; \n"
            + "// si no itera atravez de n y calcula el valor\n"
            + "double digits = 0; \n"
            + "        for (int i=2; i<=n; i++) \n"
            + "            digits += Math.log10(i); \n"
            + "\n"
            + "        return (int)(Math.floor(digits)) + 1; \n"
            + "    } \n"
            + "\n"
            + "    public static void main (String[] args)  \n"
            + "    { \n"
            + "        System.out.println(findDigits(1)); \n"
            + "        System.out.println(findDigits(5)); \n"
            + "        System.out.println(findDigits(10)); \n"
            + "        System.out.println(findDigits(120)); \n"
            + "} \n"
            + "}";
    private String factorialnumdigitsop = "// Programa java que encuentra el número de digitos\n"
            + "// en un factorial\n"
            + "public class FactorialNumDigitsOP {\n"
            + "\n"
            + "    public static double M_E = 2.71828182845904523536;\n"
            + "    public static double M_PI = 3.141592654;\n"
            + "/* Funcion que retorna el número de digitos presente en \n"
            + "    n! desde que el resultado sea muy largo*/\n"
            + "static long findDigits(int n) {\n"
            + "\n"
            + "        if (n < 0) {\n"
            + "            return 0;\n"
            + "        }\n"
            + "\n"
            + "        // caso base\n"
            + "        if (n <= 1) {\n"
            + "return 1;\n"
            + "        }\n"
            + "// Usamos la formula de Kamenestsky para\n"
            + "        // calcular el número de digitos\n"
            + "        double x = (n * Math.log10(n / M_E)\n"
            + "+ Math.log10(2 * M_PI * n)\n"
            + "                / 2.0);\n"
            + "\n"
            + "        return (long) Math.floor(x) + 1;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        System.out.println(findDigits(1));\n"
            + "        System.out.println(findDigits(50000000));\n"
            + "        System.out.println(findDigits(1000000000));\n"
            + "        System.out.println(findDigits(120));\n"
            + "}\n"
            + "}";
    private String fermatlittletheorem = "/*Programa de Java para encontrar modular.\n"
            + " inverso de un módulo bajo m\n"
            + " utilizando el pequeño teorema de Fermat.\n"
            + " Este programa funciona solo si m es primo.*/\n"
            + "public class FermatLittleTheorem\n"
            + "{ \n"
            + "    static int __gcd(int a, int b) \n"
            + "    { \n"
            + "\n"
            + "        if(b == 0)  \n"
            + "        { \n"
            + "            return a; \n"
            + "        } \n"
            + "        else \n"
            + "        { \n"
            + "            return __gcd(b, a % b); \n"
            + "} \n"
            + "    } \n"
            + "// Computa x^y bajo modulo m\n"
            + "static int power(int x,int y,int m) \n"
            + "    { \n"
            + "        if (y == 0) \n"
            + "            return 1; \n"
            + "        int p = power(x, y / 2, m) % m; \n"
            + "        p = (p * p) % m; \n"
            + "\n"
            + "        return (y % 2 == 0) ? p : (x * p) % m; \n"
            + "} \n"
            + "// Función para encontrar modular\n"
            + "    // inverso bajo un modulo m\n"
            + "    // Asumimos m es primo\n"
            + "    static void modInverse(int a, int m) \n"
            + "    { \n"
            + "        if (__gcd(a, m) != 1) \n"
            + "            System.out.print(\"No existe inverso\"); \n"
            + "\n"
            + "        else { \n"
            + "// Si a y m son primos relativos, entonces\n"
            + "            // modulo inverso es a^(m-2) mod m \n"
            + "            System.out.print(\"Multiplicación modular inversa es \"\n"
            + "+power(a, m - 2, m)); \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "    public static void main (String[] args)  \n"
            + "{ \n"
            + "        int a = 3, m = 11; \n"
            + "        modInverse(a, m); \n"
            + "    } \n"
            + "}";
    private String fibonaccigoldenratio = "// Programa java que encuentra el \n"
            + "// nesimo número fibonacci\n"
            + "public class FiboGoldenRatio\n"
            + "{   //Valor aproximado del golden ratio\n"
            + "// Approximate value of golden ratio \n"
            + "    static double PHI = 1.6180339; \n"
            + "// Números fibonacci hasta 5\n"
            + "    static int f[] = { 0, 1, 1, 2, 3, 5 }; \n"
            + "// Función que encuentra nesimo\n"
            + "// número fibonacci\n"
            + "static int fib (int n) \n"
            + "{   // Números fibonacci menores a 6\n"
            + "        if (n < 6) \n"
            + "            return f[n]; \n"
            + "// Si no comience conteo desde el quinto\n"
            + "int t = 5; \n"
            + "        int fn = 5; \n"
            + "        while (t < n) { \n"
            + "            fn = (int)Math.round(fn * PHI); \n"
            + "            t++; \n"
            + "        } \n"
            + "        return fn;  \n"
            + "    } \n"
            + "\n"
            + "    public static void main (String[] args)  \n"
            + "    { \n"
            + "        int n = 9; \n"
            + "        System.out.println(n + \" número fibonacci= \"\n"
            + "                                                +fib(n)); \n"
            + "} \n"
            + "}";
    private String floatgcd = "// Programa java que encuentra el GCD de dos\n"
            + "// números flotantes\n"
            + "public class FloatGCD { \n"
            + "// Funcion recursiva que retorna gcd de a y b  \n"
            + "static double gcd(double a, double b) \n"
            + "    { \n"
            + "        if (a < b) \n"
            + "            return gcd(b, a); \n"
            + "\n"
            + "// Caso base\n"
            + "        if (Math.abs(b) < 0.001) \n"
            + "            return a; \n"
            + "\n"
            + "        else\n"
            + "            return (gcd(b, a -  \n"
            + "                   Math.floor(a / b) * b)); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        double a = 1.20, b = 22.5; \n"
            + "        System.out.printf(\"%.1f\" ,gcd(a, b)); \n"
            + "} \n"
            + "} ";
    private String fractionsproduct = "//Programa java que encuentra el producto\n"
            + "// de N fracciones en forma reducida\n"
            + "\n"
            + "public class Fractionsproduct {\n"
            + "// Función que retorna el gcd de a y b\n"
            + "static int gcd(int a, int b) {\n"
            + "        if (a == 0) {\n"
            + "            return b;\n"
            + "        }\n"
            + "        return gcd(b % a, a);\n"
            + "    }\n"
            + "\n"
            + "    static void productReduce(int n, int num[],\n"
            + "            int den[]) {\n"
            + "        int new_num = 1, new_den = 1;\n"
            + "//Encontrando el producto de todos los N\n"
            + "// numeradores y denominadores\n"
            + "        for (int i = 0; i < n; i++) {\n"
            + "            new_num *= num[i];\n"
            + "new_den *= den[i];\n"
            + "        }\n"
            + "// Encontrando GCD de nuevo numerados y denominador \n"
            + "int GCD = gcd(new_num, new_den);\n"
            + "// Convirtiendo en forma reducids\n"
            + "        new_num /= GCD;\n"
            + "new_den /= GCD;\n"
            + "        System.out.println(new_num + \"/\" + new_den);\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int n = 3;\n"
            + "        int num[] = {1, 2, 5};\n"
            + "        int den[] = {2, 1, 6};\n"
            + "productReduce(n, num, den);\n"
            + "\n"
            + "    }\n"
            + "}";
    private String josephus = "//Implementación java de dos Algoritmos que realizan la\n"
            + "// busqueda josephus sabiendo número personas y tamaño\n"
            + "// de salto\n"
            + "public class Josephus {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        System.out.println(josephus(6, 2));\n"
            + "        System.out.println(josephusModular(6, 2));\n"
            + "    }\n"
            + "//Busqueda por algoritmo voraz\n"
            + "    static int josephus(int n, int k) {\n"
            + "        int d[] = new int[n + 1];\n"
            + "        d[0] = -1;\n"
            + "        for (int i = 1; i <= n; i++) {\n"
            + "            d[i] = i;\n"
            + "        }\n"
            + "        int i = n;\n"
            + "        int a = 0;\n"
            + "        while (i != 1) {\n"
            + "            i--;\n"
            + "            a = next(a, k, d);\n"
            + "            d[a] = -1;\n"
            + "            a++;\n"
            + "        }\n"
            + "        for ( i = 0; d[i] == -1; i++);\n"
            + "return d[i];\n"
            + "    }\n"
            + "//Calcule la posición siguiente a caer \n"
            + "static int next(int a, int k, int[] d) {\n"
            + "        int j = a - 1;\n"
            + "        for (int i = 0; i < k;) {\n"
            + "            j = (j + 1) % d.length;\n"
            + "            if (d[j] != -1) {\n"
            + "                i++;\n"
            + "            }\n"
            + "        }\n"
            + "        return j;\n"
            + "    }\n"
            + " //busqueda por matematica modular\n"
            + "    static int josephusModular(int n, int k) {\n"
            + "        int f = 0;\n"
            + "        for (int i = 1; i <= n; i++) {\n"
            + "            f = (f + k) % i;\n"
            + "\n"
            + "        }\n"
            + "        return f + 1;\n"
            + "}\n"
            + "\n"
            + "}";
    private String cardinalnumbers = "//Programa java que convierte números ordinales\n"
            + "// en números cardinales en ingles\n"
            + "public class CardinalNumbers {\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        for (int i = 1; i <= 10; i++) {\n"
            + "            System.out.println(i+cardinalNumber(i));\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    static String cardinalNumber(int n) {\n"
            + "if (n % 10 == 1 && n % 100 != 11) {\n"
            + "return \"st\";\n"
            + "        }\n"
            + "        if (n % 10 == 2 && n % 100 != 12) {\n"
            + "return \"nd\";\n"
            + "        }\n"
            + "        if (n % 10 == 3 && n % 100 != 13) {\n"
            + "            return \"rd\";\n"
            + "}\n"
            + "        return \"th\";\n"
            + "    }\n"
            + "}";
    private String romannumbers = "//Implementación java que convierte números decimales\n"
            + "// a números romanos y viceversa usando matematica modular\n"
            + "public class RomanNumbers {\n"
            + "// Arrays constantes de letras romanas\n"
            + "    static String unit[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n"
            + "    static String ten[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n"
            + "    static String hnd[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        System.out.println(toRoman(122));\n"
            + "        System.out.println(toDecimal(\"CXXII\"));\n"
            + "}\n"
            + "//Función que convierte a romano\n"
            + "    static String toRoman(int n) {\n"
            + "//Los números romanos no tienen letras\n"
            + "        //más alla de los miles\n"
            + "        int a;\n"
            + "StringBuilder sb = new StringBuilder();\n"
            + "        if (n >= 1000) {\n"
            + "            a = n / 1000;\n"
            + "            for (int i = 1; i <= a; i++) {\n"
            + "sb.append(\"M\");\n"
            + "            }\n"
            + "            n %= 1000;\n"
            + "        }\n"
            + "//Letras de las centenas\n"
            + "sb.append(hnd[n / 100]);\n"
            + "        n = n % 100;\n"
            + "//Letras de las decenas\n"
            + "        sb.append(ten[n / 10]);\n"
            + "//Letras de las unidades\n"
            + "        sb.append(unit[n % 10]);\n"
            + "        return sb.toString();\n"
            + "    }\n"
            + "//Devuelve el valor de cada letra\n"
            + "static int valor(char ch) {\n"
            + "        switch (ch) {\n"
            + "            case 'I':\n"
            + "                return 1;\n"
            + "            case 'V':\n"
            + "                return 5;\n"
            + "            case 'X':\n"
            + "                return 10;\n"
            + "            case 'L':\n"
            + "                return 50;\n"
            + "            case 'C':\n"
            + "                return 100;\n"
            + "            case 'D':\n"
            + "                return 500;\n"
            + "            case 'M':\n"
            + "return 1000;\n"
            + "        }\n"
            + "        return 0;\n"
            + "    }\n"
            + "    //Función que convierte a decimal\n"
            + "static int toDecimal(String num) {\n"
            + "        int sum = 0;\n"
            + "        int last = 0;\n"
            + "        int next;\n"
            + "//Toma cada letra y verifica si esta antes o despues \n"
            + "        // suma si esta despues, resta si esta antes\n"
            + "for (int i = num.length() - 1; i >= 0; i--) {\n"
            + "            next = valor(num.charAt(i));\n"
            + "            if (last <= next) {\n"
            + "                sum += next;\n"
            + "            } else {\n"
            + "                sum -= next;\n"
            + "            }\n"
            + "            last = next;\n"
            + "}\n"
            + "        return sum;\n"
            + "\n"
            + "    }\n"
            + "}";
    private String gcdmultiple = "// Programa java que encuentra\n"
            + "// el maximo comun divisor de 2 o más \n"
            + "//números\n"
            + "public class GCDMultiple { \n"
            + "// Funcion que retorna gcd de a y b\n"
            + "static int gcd(int a, int b) \n"
            + "    { \n"
            + "        if (a == 0) \n"
            + "            return b; \n"
            + "        return gcd(b % a, a); \n"
            + "} \n"
            + "// Función que encuentra gcd de un arreglo de números\n"
            + "static int findGCD(int arr[], int n) \n"
            + "    { \n"
            + "        int result = arr[0]; \n"
            + "        for (int i = 1; i < n; i++) \n"
            + "            result = gcd(arr[i], result); \n"
            + "\n"
            + "        return result; \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "    { \n"
            + "        int arr[] = { 2, 4, 6, 8, 16 }; \n"
            + "        int n = arr.length; \n"
            + "        System.out.println(findGCD(arr, n)); \n"
            + "} \n"
            + "}";
    private String hardyramanujantheorem = "// Programa java que cuenta todos los \n"
            + "// factores primos\n"
            + "\n"
            + "public class HardyRamanujanTheorem { \n"
            + "// Una función que cuenta factores primos de \n"
            + "//un número n\n"
            + "    static int exactPrimeFactorCount(int n) \n"
            + "    { \n"
            + "        int count = 0; \n"
            + "        if (n % 2 == 0) { \n"
            + "            count++; \n"
            + "while (n % 2 == 0) \n"
            + "                n = n / 2; \n"
            + "        } \n"
            + "        // n debe ser impar en este punto, asi \n"
            + "        //podemos saltar un elemento (i=i+2)\n"
            + "for (int i = 3; i <= Math.sqrt(n); i = i + 2)  \n"
            + "        { \n"
            + "            if (n % i == 0) { \n"
            + "                count++; \n"
            + "                while (n % i == 0) \n"
            + "n = n / i; \n"
            + "            } \n"
            + "        } \n"
            + "        // Esta condición es para controlar el caso\n"
            + "        // cuando n es un factor primo más grande que 2\n"
            + "if (n > 2) \n"
            + "            count++; \n"
            + "        return count; \n"
            + "    } \n"
            + "\n"
            + "    public static void main (String[] args)  \n"
            + "{ \n"
            + "        int n = 51242183; \n"
            + "        System.out.println( \"El número de diferentes \"\n"
            + "                            + \" factores primos es \"\n"
            + "            + exactPrimeFactorCount(n)); \n"
            + "        System.out.println( \"El valor de (log(n))\"\n"
            + "                   + \" es \" + Math.log(Math.log(n))) ; \n"
            + "    } \n"
            + "}";
    private String hoaxnumber = "// Programa java que verifica si un número es \n"
            + "// falso o no\n"
            + "import java.util.*; \n"
            + "\n"
            + "public class HoaxNumber { \n"
            + "    /*Función que encuentra distintos factores primos\n"
            + "dado un número n*/\n"
            + "\n"
            + "    static List<Integer> primeFactors(int n) \n"
            + "    { \n"
            + "        List<Integer> res = new ArrayList<>(); \n"
            + "        if (n % 2 == 0)  \n"
            + "        { \n"
            + "            while (n % 2 == 0) \n"
            + "                n = n / 2; \n"
            + "res.add(2); \n"
            + "        } \n"
            + "/*N es impar en este punto\n"
            + "        desde que ya no sea divisible por 2\n"
            + "        entonces podemos probar solamente\n"
            + "        por números impares, mientras sean \n"
            + "factores de n*/\n"
            + "        for (int i = 3; i <= Math.sqrt(n); \n"
            + "                                i = i + 2)  \n"
            + "        { \n"
            + "//Verifica si i es factor primo\n"
            + "            if (n % i == 0)  \n"
            + "            { \n"
            + "                while (n % i == 0) \n"
            + "                    n = n / i; \n"
            + "                res.add(i); \n"
            + "} \n"
            + "        } \n"
            + "/*Esra condición es para controlar\n"
            + "        el caso cuando n es un número primo\n"
            + "        más grande que 2*/\n"
            + "        if (n > 2) \n"
            + "res.add(n); \n"
            + "        return res; \n"
            + "} \n"
            + "/*Función que calcula suma de digitos de distintos\n"
            + "    factores primos de dado n y la suma de digitos\n"
            + "    de número n. compara las sumás obtenidas*/\n"
            + "static boolean isHoax(int n) \n"
            + "{  \n"
            + "/*Distintos factores primos de n seran almacenados\n"
            + "        en vector pf*/ \n"
            + "        List<Integer> pf = primeFactors(n); \n"
            + "/* Si n es un número primo\n"
            + "        no puede ser un número falso*/\n"
            + "if (pf.get(0) == n) \n"
            + "            return false; \n"
            + "/*Encontrando suma de digitos de \n"
            + "        distintos factores primos de n*/\n"
            + "int all_pf_sum = 0;  \n"
            + "        for (int i = 0; i < pf.size(); i++) \n"
            + "{ \n"
            + "// Encontramos la suma de digitos de \n"
            + "            // el actual factor primo pf[i] \n"
            + "int pf_sum; \n"
            + "            for (pf_sum = 0; pf.get(i) > 0;  \n"
            + "                pf_sum += pf.get(i) % 10,  \n"
            + "                   pf.set(i,pf.get(i) / 10)); \n"
            + "\n"
            + "            all_pf_sum += pf_sum; \n"
            + "} \n"
            + "// Encontrando suma de digitos de n\n"
            + "int sum_n; \n"
            + "        for (sum_n = 0; n > 0; sum_n += n % 10, \n"
            + "n /= 10); \n"
            + "// Comparando las dos sumás calculadas\n"
            + "return sum_n == all_pf_sum; \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        int n = 84; \n"
            + "        if (isHoax(n)) \n"
            + "System.out.print( \"Un número falso\\n\"); \n"
            + "        else\n"
            + "            System.out.print(\"No es número falso\\n\"); \n"
            + "    } \n"
            + "}";
    private String largestpowdividesfactorial = "/* Programa java que encuentra la potencia más larga de\n"
            + "un número (La cual puede ser compuesta) que divide \n"
            + "factorial*/\n"
            + "public class LargestPowDividesFactorial {\n"
            + "\n"
            + "/* For que encuentra la maxima potencia de número primo\n"
            + "    p que puede dividir un número facorial*/\n"
            + "static int findPowerPrime(int fact, int p) {\n"
            + "        int res = 0;\n"
            + "        while (fact > 0) {\n"
            + "            res += fact / p;\n"
            + "fact /= p;\n"
            + "        }\n"
            + "\n"
            + "        return res;\n"
            + "    }\n"
            + "\n"
            + "// Retorna la suma de todos los factores de n\n"
            + "static int findPowerComposite(int fact, int n) {\n"
            + "// Para almacernar el resultado ( Potencia minima de un \n"
            + "        // factor primo que divide fact)\n"
            + "int res = Integer.MAX_VALUE;\n"
            + "// Atravesar atraves de todos los factores\n"
            + "// primos de n\n"
            + "        for (int i = 2; i <= Math.sqrt(n); i++) {\n"
            + "// contador para contar la potencia del número primo\n"
            + "int count = 0;\n"
            + "            if (n % i == 0) {\n"
            + "                count++;\n"
            + "                n = n / i;\n"
            + "            }\n"
            + "            if (count > 0) {\n"
            + "// Maxima potencia de i que divide \n"
            + "                // fact, dividimos por count para \n"
            + "                // manejar multiples ocurrencias de \n"
            + "// un factor primo\n"
            + "                int curr_pow = findPowerPrime(fact, i) / count;\n"
            + "res = Math.min(res, curr_pow);\n"
            + "            }\n"
            + "        }\n"
            + "// Esta condición es para manejar \n"
            + "        // el caso cuando n es un número primo mayor \n"
            + "// que 2\n"
            + "        if (n >= 2) {\n"
            + "            int curr_pow = findPowerPrime(fact, n);\n"
            + "            res = Math.min(res, curr_pow);\n"
            + "        }\n"
            + "        return res;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int fact = 146, n = 5;\n"
            + "        System.out.println(findPowerComposite(fact, n));\n"
            + "}\n"
            + "}";
    private String lcmofarrayelements = "// Programa java que calcula el minimo común multiplo\n"
            + "// de n elementos\n"
            + "\n"
            + "public class Lcmofarrayelements {\n"
            + "\n"
            + "    public static long lcm_of_array_elements(int[] element_array) {\n"
            + "        long lcm_of_array_elements = 1;\n"
            + "        int divisor = 2;\n"
            + "        while (true) {\n"
            + "            int counter = 0;\n"
            + "            boolean divisible = false;\n"
            + "            for (int i = 0; i < element_array.length; i++) {\n"
            + "\n"
            + "// lcm_of_array_elements (n1, n2, ... 0) = 0. \n"
            + "// Para cada número negativo lo convertimos\n"
            + "                // En positivo y calculamos lcm_of_array_elements. \n"
            + "if (element_array[i] == 0) {\n"
            + "                    return 0;\n"
            + "                } else if (element_array[i] < 0) {\n"
            + "                    element_array[i] = element_array[i] * (-1);\n"
            + "                }\n"
            + "                if (element_array[i] == 1) {\n"
            + "                    counter++;\n"
            + "}\n"
            + "/* Divide element_array por diviser si completa\n"
            + "división */\n"
            + "                if (element_array[i] % divisor == 0) {\n"
            + "                    divisible = true;\n"
            + "                    element_array[i] = element_array[i] / divisor;\n"
            + "}\n"
            + "            }\n"
            + "/*Si el divisor es capaz de dividir completamente cualquier número.\n"
            + "            de la matriz multiplicar con lcm_of_array_elements\n"
            + "            y almacenar en lcm_of_array_elements y continuar\n"
            + "            al mismo divisor para encontrar el siguiente factor.\n"
            + "            si no incrementar divisor*/\n"
            + "\n"
            + "            if (divisible) {\n"
            + "lcm_of_array_elements = lcm_of_array_elements * divisor;\n"
            + "} else {\n"
            + "                divisor++;\n"
            + "            }\n"
            + "//Verifica si todo element_Array es 1 indicando\n"
            + "            // encontramos todos los factores y terminamos el ciclo\n"
            + "if (counter == element_array.length) {\n"
            + "                return lcm_of_array_elements;\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        int[] element_array = {2, 7, 3, 9, 4};\n"
            + "        System.out.println(lcm_of_array_elements(element_array));\n"
            + "}\n"
            + "}";
    private String leonardonumber = "//Pograma java qque busca el nesimo número\n"
            + "// de Leonardo\n"
            + "public class LeonardoNumber { \n"
            + "    static int leonardo(int n) \n"
            + "    { \n"
            + "        if (n == 0 || n == 1) \n"
            + "            return 1; \n"
            + "        return (leonardo(n - 1) + leonardo(n - 2) + 1); \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "{ \n"
            + "        System.out.println(leonardo(3)); \n"
            + "    } \n"
            + "}";
    private String modularexponentiation = "// Programa iteratico que calcula \n"
            + "// potencia modular \n"
            + "public class ModularExponentiation { \n"
            + "\n"
            + "/* Función iterativa que calcula\n"
            + "       (x^y)%p in O(log y) */\n"
            + "static int power(int x, int y, int p) \n"
            + "{ \n"
            + "// Inicializar resultado\n"
            + "        int res = 1;      \n"
            + "// Actualiza x si es más que    \n"
            + "        // o igual a p \n"
            + "        x = x % p; \n"
            + "        while (y > 0) \n"
            + "        {   //Si y es impar, multiplica x con res\n"
            + "            if((y & 1)==1) \n"
            + "                res = (res * x) % p; \n"
            + "// y debe ser par ahora\n"
            + "            // y = y / 2 \n"
            + "            y = y >> 1;  \n"
            + "            x = (x * x) % p;  \n"
            + "        } \n"
            + "        return res; \n"
            + "} \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        int x = 2; \n"
            + "        int y = 5; \n"
            + "        int p = 13; \n"
            + "System.out.println(\"La potencia es \" + power(x, y, p)); \n"
            + "    } \n"
            + "} ";
    private String multipleeulertotient = "// Programa java que eficientemente calcula valores de\n"
            + "// la formula totient de euler para multiples entradas\n"
            + "\n"
            + "import java.util.*;\n"
            + "\n"
            + "public class MultipleEulerTotient {\n"
            + "\n"
            + "static int MAX = 100001;\n"
            + "// Almacena números primos arriba hasta MAX -1\n"
            + "static ArrayList<Integer> p = new ArrayList<Integer>();\n"
            + "// Encurntra los números primos hasta MAX-1 Y\n"
            + "// los almacena en p\n"
            + "\n"
            + "    static void sieve() {\n"
            + "int[] isPrime = new int[MAX + 1];\n"
            + "        for (int i = 2; i <= MAX; i++) {\n"
            + "// Si prime[i] no es marcado antes\n"
            + "            if (isPrime[i] == 0) {\n"
            + "// Llena el vector para cada nuevo\n"
            + "                // primo encontrado\n"
            + "                p.add(i);\n"
            + "for (int j = 2; i * j <= MAX; j++) {\n"
            + "isPrime[i * j] = 1;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "// Función que encuentra totient de n\n"
            + "static int phi(int n) {\n"
            + "int res = n;\n"
            + "// Este ciclo corre sqrt(n / ln(n)) veces\n"
            + "for (int i = 0; p.get(i) * p.get(i) <= n; i++) {\n"
            + "if (n % p.get(i) == 0) {\n"
            + "                // resta multiplos de p[i] de r\n"
            + "                res -= (res / p.get(i));\n"
            + "// Remueve todas las ocurrencias de p[i] en n\n"
            + "while (n % p.get(i) == 0) {\n"
            + "n /= p.get(i);\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "// cuando n es un factor primo mayor \n"
            + "// que sqrt(n) \n"
            + "        if (n > 1) {\n"
            + "            res -= (res / n);\n"
            + "        }\n"
            + "        return res;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) { \n"
            + "//Preprocesa todos los primos hasta 10 ^ 5  \n"
            + "sieve();\n"
            + "        System.out.println(phi(11));\n"
            + "        System.out.println(phi(21));\n"
            + "        System.out.println(phi(31));\n"
            + "        System.out.println(phi(41));\n"
            + "        System.out.println(phi(51));\n"
            + "        System.out.println(phi(61));\n"
            + "        System.out.println(phi(91));\n"
            + "System.out.println(phi(101));\n"
            + "\n"
            + "    }\n"
            + "}";
    private String naturalcoprimesum = "/* Código de Java para determinar si los números\n"
            + "1 a N se puede dividir en dos conjuntos\n"
            + "tal que la diferencia absoluta entre\n"
            + "la suma de estos dos conjuntos es M y estos\n"
            + "dos sumás son co-primos*/\n"
            + "public class NaturalCoprimeSum  \n"
            + "{ \n"
            + "    static int GCD (int a, int b) \n"
            + "    { \n"
            + "        return b == 0 ? a : GCD(b, a % b); \n"
            + "} \n"
            + "/*función que devuelve valor booleano\n"
            + "     sobre la base de si es posible\n"
            + "     dividir 1 a N números en dos conjuntos\n"
            + "     Que satisfacen las condiciones dadas.*/\n"
            + "\n"
            + "static boolean isSplittable(int n, int m) \n"
            + "{ \n"
            + "// Inicializando suma total de 1\n"
            + "        //a n \n"
            + "int total_sum = (n * (n + 1)) / 2; \n"
            + "        /*desde (1) total_sum = sum_s1 + sum_s2 \n"
            + "y (2) m = sum_s1 - sum_s2 asumiendo \n"
            + "        sum_s1> sum_s2. resolviendo estas 2 \n"
            + "        ecuaciones para obtener sum_s1 y sum_s2*/\n"
            + "int sum_s1 = (total_sum + m) / 2; \n"
            + "        // total_sum = sum_s1 + sum_s2 \n"
            + "        // y asi \n"
            + "        int sum_s2 = total_sum - sum_s1; \n"
            + "/*Si la suma total es menor que la \n"
            + "        diferencia absoluta, no hay forma \n"
            + "        de que podamos dividir n números \n"
            + "        en dos conjuntos, así que devuelva falso*/\n"
            + "if (total_sum < m) \n"
            + "            return false; \n"
            + "/*Compruebe si estas dos sumás son\n"
            + "        enteros y se suman a\n"
            + "        suma total y también si su\n"
            + "        La diferencia absoluta es m.*/\n"
            + "if (sum_s1 + sum_s2 == total_sum &&\n"
            + "sum_s1 - sum_s2 == m) \n"
            + "// Ahora si las dos sumás son coprimos\n"
            + "            // Entonces retorna true, si no false\n"
            + "return (GCD(sum_s1, sum_s2) == 1); \n"
            + "/*si dos sumás no suman la suma total\n"
            + "          o si su diferencia absoluta.\n"
            + "         no es m, entonces no hay manera de\n"
            + "         dividir n números, por lo tanto retorna false*/ \n"
            + "return false; \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String args[])  \n"
            + "    { \n"
            + "        int n = 5, m = 7; \n"
            + "        if (isSplittable(n, m)) \n"
            + "            System.out.println(\"Si\"); \n"
            + "        else\n"
            + "            System.out.println(\"No\"); \n"
            + "\n"
            + "} \n"
            + "}";
    private String zeckendorftheorem = "/*Programa java para el Teorema de Zeckendorf, \n"
            + "encuentra la representación de n como suma de \n"
            + "números de fibonacci no vecinos*/\n"
            + "public class ZeckendorfTheorem { \n"
            + "    public static int nearestSmallerEqFib(int n) \n"
            + "    { \n"
            + "// Casos base\n"
            + "        if (n == 0 || n == 1) \n"
            + "            return n; \n"
            + "//Encuentra el mayor número fibonacci menor que n \n"
            + "int f1 = 0, f2 = 1, f3 = 1; \n"
            + "        while (f3 <= n) { \n"
            + "            f1 = f2; \n"
            + "            f2 = f3; \n"
            + "            f3 = f1 + f2; \n"
            + "        } \n"
            + "        return f2; \n"
            + "} \n"
            + "// Imprime representación de fibonacci  \n"
            + "    public static void printFibRepresntation(int n) \n"
            + "    { \n"
            + "        while (n > 0) {     \n"
            + "// Encuentra el mayor número fibonacci menor \n"
            + "            // o igual que n \n"
            + "            int f = nearestSmallerEqFib(n); \n"
            + "// Imprime el número fibonacci encontrado\n"
            + "            System.out.print(f + \" \"); \n"
            + "// Reduce n \n"
            + "            n = n - f; \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String[] args) \n"
            + "{ \n"
            + "        int n = 30; \n"
            + "        System.out.println(\"Representación de fibonacci no vecinos \"\n"
            + "                           + \" de  \" + n + \" es\");   \n"
            + "        printFibRepresntation(n); \n"
            + "    } \n"
            + "}";
    private String rossertheorem = "// Programa java que verifica el Teorema de Rosser\n"
            + "import java.util.*; \n"
            + "public class RosserTheorem \n"
            + "{ \n"
            + "    static ArrayList<Integer> prime=new ArrayList<Integer>();  \n"
            + "// Criba de Eratostenes\n"
            + "    static void sieve() \n"
            + "{ \n"
            + "        int n = 10000; \n"
            + "        boolean []isprime=new boolean[n+2]; \n"
            + "        for(int i=0;i<n;i++) \n"
            + "            isprime[i]=true;      \n"
            + "        isprime[0]=false; \n"
            + "        isprime[1] =false; \n"
            + "        for (int i = 2; i <= n; i++) { \n"
            + "            if (isprime[i]) { \n"
            + "                for (int j = i * i; j <= n; j += i) \n"
            + "isprime[j] =false; \n"
            + "            } \n"
            + "        } \n"
            + "//Almacena primos en prime[] \n"
            + "for (int i = 0; i <= n; i++) \n"
            + "            if (isprime[i]) \n"
            + "                prime.add(i); \n"
            + "} \n"
            + "\n"
            + "// Verifica el TEOREMA DE  ROSSER para todos los números  \n"
            + "// Menores a n\n"
            + "    static void verifyRosser(int n) \n"
            + "{ \n"
            + "        System.out.println(\"TEOREMA DE ROSSER: nesimo número primo > n * (ln n)\"); \n"
            + "\n"
            + "for (int i = 0; i < n; i++) \n"
            + "            if (prime.get(i) > (i + 1) * Math.log(i + 1)) { \n"
            + "                System.out.println( \"para n = \" + (i+1)  \n"
            + "+ \", nesimo número primo = \"\n"
            + "                    + prime.get(i) + \"\\n\\t\"\n"
            + "+ prime.get(i) + \" > \" + (i + 1) \n"
            + "                    + \" * ln(\" + (i + 1) + \")\"); \n"
            + "            } \n"
            + "    } \n"
            + "    public static void main(String [] args) \n"
            + "{ \n"
            + "        sieve(); \n"
            + "        verifyRosser(20);        \n"
            + "    } \n"
            + "}";
    private String sieveoderathosthenesoptimizated = "/*Programa java que genera todos los números primos\n"
            + "menores a N en O(N) Eratostenes Optimizado*/\n"
            + "import java.util.ArrayList;\n"
            + "\n"
            + "public class SieveofEratosthenesOptimizated\n"
            + "{ \n"
            + "    static final int MAX_SIZE = 1000001; \n"
            + "// isPrime[] : isPrime[i] es true si el número es primo  \n"
            + "    // prime[] : Almacena todos los números primos menores a N \n"
            + "    // SPF[] Almacena los factores primos más pequeños de un número \n"
            + "    // [Por ejemplo : factor primo más pequeño que '8' y '16' es  \n"
            + "    //  '2' entonces nosotros ponemos SPF[8]=2 , SPF[16]=2 ] \n"
            + "static ArrayList<Boolean>isprime = new ArrayList<>(MAX_SIZE); \n"
            + "    static ArrayList<Integer>prime = new ArrayList<>(); \n"
            + "    static ArrayList<Integer>SPF = new ArrayList<>(MAX_SIZE); \n"
            + "// Metodo que genera todos los factores primos menores de N\n"
            + "static void manipulated_seive(int N) \n"
            + "{   // 0 y 1 no son primos\n"
            + "        isprime.set(0, false); \n"
            + "        isprime.set(1, false); \n"
            + "\n"
            + "// llena el resto de las entradas\n"
            + "for (int i=2; i<N ; i++) \n"
            + "{ \n"
            + "// si isPrime[i] == True entonces i es  \n"
            + "            // número primo\n"
            + "if (isprime.get(i)) \n"
            + "            { \n"
            + "// pone i dentro de prime[]  \n"
            + "prime.add(i); \n"
            + "// un número primo es su propio factor primo\n"
            + "                // más pequeño\n"
            + "                SPF.set(i,i); \n"
            + "            } \n"
            + "/*Eliminar todos los múltiplos de i * prime [j] que son\n"
            + "            no primos haciendo isPrime [i * prime [j]] = false\n"
            + "            y ponga el factor primo más pequeño de i * Prime [j] como prime [j]\n"
            + "            [Por ejemplo: dejemos i = 5, j = 0, prime[j] = 2 [i * prime [j] = 		10]\n"
            + "            por lo que el factor primo más pequeño de '10' es '2' que es prime 		[j]]\n"
            + "            este bucle se ejecuta solo una vez para el número que no es primo*/\n"
            + "\n"
            + "for (int j=0; \n"
            + "                 j < prime.size() &&\n"
            + "                 i*prime.get(j) < N && prime.get(j) <= SPF.get(i); \n"
            + "                 j++) \n"
            + "            { \n"
            + "                isprime.set(i*prime.get(j),false); \n"
            + "// Pone el factor primo más pequeño de i*prime[j] \n"
            + "SPF.set(i*prime.get(j),prime.get(j)) ; \n"
            + "            } \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main(String args[])  \n"
            + "{ \n"
            + "        int N = 13 ; //Debe ser menor que  MAX_SIZE        \n"
            + "// inicializando isprime y SPF\n"
            + "        for (int i = 0; i < MAX_SIZE; i++){ \n"
            + "            isprime.add(true); \n"
            + "            SPF.add(2); \n"
            + "}      \n"
            + "        manipulated_seive(N);   \n"
            + "//Imprima todos los números primos menores que n \n"
            + "for (int i=0; i<prime.size() && prime.get(i) <= N ; i++) \n"
            + "            System.out.print(prime.get(i) + \" \"); \n"
            + "} \n"
            + "}";
    private String smithnumber = "// Programa java que verifica si un número es \n"
            + "// número de Smith o no\n"
            + "import java.util.ArrayList;\n"
            + "\n"
            + "public class SmithNumber \n"
            + "{ \n"
            + "\n"
            + "    static int MAX  = 10000; \n"
            + "//Array que almacena todos los primos menores o iguales\n"
            + "// a 10^6\n"
            + "    static ArrayList <Integer>  primes = new ArrayList<>(); \n"
            + "//Función de la criba de Sundaram\n"
            + "    static void sieveSundaram() \n"
            + "    { \n"
            + "/*En general criva de Sundaram, produce primos más pequeños.\n"
            + "        que (2 * x + 2) para un número dado el número x. Ya que\n"
            + "         Queremos primos más pequeños que MAX, reducimos MAX a la mitad\n"
            + "         Esta matriz se usa para separar números del forma\n"
            + "         i + j + 2ij de otros donde 1 <= i <= j*/\n"
            + "boolean marked[] = new boolean[MAX/2 + 100]; \n"
            + "//Lógica principal de Sundaram, marcar todos los números\n"
            + "        // loc cuales no generan número primo haciendo 2*i+1\n"
            + "for (int i=1; i<=(Math.sqrt(MAX)-1)/2; i++) \n"
            + "            for (int j=(i*(i+1))<<1; j<=MAX/2; j=j+2*i+1) \n"
            + "marked[j] = true; \n"
            + "\n"
            + "// 2s es número primo\n"
            + "        primes.add(2); \n"
            + "// Imprime los otros primos, primos restantes son de la \n"
            + "        //forma 2*i+1 de tal manera que marked[i] es falso\n"
            + "for (int i=1; i<=MAX/2; i++) \n"
            + "            if (marked[i] == false) \n"
            + "                primes.add(2*i + 1); \n"
            + "} \n"
            + "// Retorna true si n es un número de Smith, si no falso \n"
            + "static boolean isSmith(int n) \n"
            + "{ \n"
            + "        int original_no = n; \n"
            + "// Encuentra la suma de los digitos de los factores \n"
            + "        //  primos de n\n"
            + "        int pDigitSum = 0; \n"
            + "for (int i = 0; primes.get(i) <= n/2; i++) \n"
            + "        { \n"
            + "            while (n % primes.get(i) == 0) \n"
            + "{   // Si primes[i] es un factor primo\n"
            + "                // agrega sus digitos a pDigitSum\n"
            + "                int p = primes.get(i); \n"
            + "n = n/p; \n"
            + "                while (p > 0) \n"
            + "                { \n"
            + "                    pDigitSum += (p % 10); \n"
            + "p = p/10; \n"
            + "                } \n"
            + "            } \n"
            + "        } \n"
            + "        /*Si n!=! entonces un primo sigue para ser sumado*/\n"
            + "if (n != 1 && n != original_no) \n"
            + "        { \n"
            + "            while (n > 0) \n"
            + "{ \n"
            + "                pDigitSum = pDigitSum + n%10; \n"
            + "                n = n/10; \n"
            + "            } \n"
            + "        } \n"
            + "// Todos los factores primos sumados \n"
            + "        // Ahora suma los digitos del número original \n"
            + "int sumDigits = 0; \n"
            + "        while (original_no > 0) \n"
            + "{ \n"
            + "            sumDigits = sumDigits + original_no % 10; \n"
            + "            original_no = original_no/10; \n"
            + "        } \n"
            + "        // Si la suma de los digistos en factores primos \n"
            + "        // y la suma de digitos en el número original son los mismos\n"
            + "        // entonces true, si no false\n"
            + "        return (pDigitSum == sumDigits); \n"
            + "} \n"
            + "\n"
            + "\n"
            + "    public static void main(String[] args)  \n"
            + "{   //Encuentra todos los números primos antes del limite\n"
            + "        // estos números son usados para encontrar factores primos\n"
            + "        sieveSundaram();   \n"
            + "        System.out.println(\"Imprimiento primeros números de Smith\" + \n"
            + "\" usando isSmith()\");   \n"
            + "        for (int i=1; i<500; i++) \n"
            + "           if (isSmith(i)) \n"
            + "              System.out.print(i + \" \"); \n"
            + "} \n"
            + "}";
    private String sphenicnumber = "// Programa JAVA que verifica si un número\n"
            + "// es esfenico o no\n"
            + "\n"
            + "import java.util.ArrayList;\n"
            + "import java.util.Collections;\n"
            + "import java.util.HashSet;\n"
            + "import java.util.Set;\n"
            + "public class SphenicNumber {\n"
            + "\n"
            + "static final int MAX = 1000;\n"
            + "//Crea un vector donde almacenar primos\n"
            + "// inicializa todas las entradas en 0\n"
            + "static ArrayList<Integer> least_pf = new ArrayList<>(MAX);\n"
            + "/* Esta función llena valores en least_pf[]\n"
            + "    de tal modod que el valor de least_pf[] almacene\n"
            + "    el factor primo más pequeño de i\n"
            + "    Se encuentra basado en la criba\n"
            + "de Eratostenes*/\n"
            + "    public static void main(String[] args) {\n"
            + "        for (int i = 0; i < 1001; i++) {\n"
            + "            least_pf.add(0);\n"
            + "        }\n"
            + "        Collections.fill(least_pf, 0);\n"
            + "        leastPrimeFactor(MAX);\n"
            + "        for (int i = 1; i < 100; i++) {\n"
            + "            if (isSphenic(i)) {\n"
            + "System.out.println(i + \" \");\n"
            + "            }\n"
            + "        }\n"
            + "\n"
            + "    } \n"
            + "/*Función que verifica si un número es esfenico*/\n"
            + "static boolean isSphenic(int n) {\n"
            + "/*Almacena tres factores primos de n\n"
            + "        tenemos al menos 3 elementos en s*/ \n"
            + "Set<Integer> s = new HashSet<>();\n"
            + "// Siga encontrando factores primos hasta que n sea 1\n"
            + "        while (n > 1) {\n"
            + "// Encuenta al menos un factor del actual valor de n\n"
            + "int lpf = least_pf.get(n);\n"
            + "// Almacenamos actual tamaño de s para verificar si\n"
            + "//algun factor primo se repite\n"
            + "            int init_size = s.size();\n"
            + "// Inserta un valor primo al actual valor de n\n"
            + "            s.add(lpf);\n"
            + "// si lpf repite un número o se pasa de 3, retorna falso. \n"
            + "            if (s.size() == init_size || s.size() > 3) // El mismo primo divide\n"
            + "// un número más de una vez\n"
            + "            {\n"
            + "                return false;\n"
            + "            }\n"
            + "\n"
            + "// dividir n en lpf\n"
            + "            n /= lpf;\n"
            + "        }\n"
            + "// True si el tamaño es 3\n"
            + "return (s.size() == 3);\n"
            + "    }\n"
            + "\n"
            + "    static void leastPrimeFactor(int n) {\n"
            + "// un factor primo de 1 es 1\n"
            + "        least_pf.set(1, 1);	\n"
            + "// Almacena números primos para todos \n"
            + "// los otros números\n"
            + "        for (int i = 2; i <= n; i++) {\n"
            + "// least_pf[i] == 0 significa que i es primo\n"
            + "if (least_pf.get(i) == 0) {\n"
            + "                least_pf.set(i, i);\n"
            + "                for (int j = 2 * i; j <= n; j += i) {\n"
            + "                    if (least_pf.get(j) == 0) {\n"
            + "                        least_pf.set(j, i);\n"
            + "}\n"
            + "                }\n"
            + "\n"
            + "            }\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "}";
    private String catalannumbers = "//Programa Java que recursivamente encuentra el\n"
            + "// nesimo número Catalan \n"
            + "public class CatalanNumber {\n"
            + "\n"
            + "    public static int catalan(int n) {\n"
            + "        int res = 0;\n"
            + "        // Caso base\n"
            + "        if (n <= 1) {\n"
            + "            return 1;\n"
            + "        }\n"
            + "        for (int i = 0; i < n; i++) {\n"
            + "            res += catalan(i) * catalan(n - i - 1);\n"
            + "        }\n"
            + "        return res;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        for (int i = 0; i < 10; i++) {\n"
            + "            System.out.print(catalan(i) + \" \");\n"
            + "}\n"
            + "    }\n"
            + "}";
    private String charmichaelnumbers = "//Programa java que verifica si un número\n"
            + "// es un número de carmichael\n"
            + "public class CarmichaelNumbers {\n"
            + "\n"
            + "//función que busca el GCD de dos números\n"
            + "static int gcd(int a, int b) {\n"
            + "        if (a < b) {\n"
            + "            return gcd(b, a);\n"
            + "        }\n"
            + "        if (a % b == 0) {\n"
            + "            return b;\n"
            + "        }\n"
            + "        return gcd(b, a % b);\n"
            + "}\n"
            + "//Función que busca el pow(x,y)\n"
            + "// bajo un modulo mod\n"
            + "    static int power(int x, int y, int mod) {\n"
            + "        if (y == 0) {\n"
            + "            return 1;\n"
            + "        }\n"
            + "        int temp = power(x, y / 2, mod) % mod;\n"
            + "        temp = (temp * temp) % mod;\n"
            + "        if (y % 2 == 1) {\n"
            + "            temp = (temp * x) % mod;\n"
            + "        }\n"
            + "        return temp;\n"
            + "}\n"
            + "\n"
            + "//Función que verifica si un número es número de charmichael\n"
            + "static int isCarmichaelNumber(int n) {\n"
            + "        for (int b = 2; b < n; b++) {\n"
            + "// Si 'b' es primo relativo de n\n"
            + "            if (gcd(b, n) == 1) // y pow(b, n-1)%n no es 1,\n"
            + "// retorne falso\n"
            + "            {\n"
            + "                if (power(b, n - 1, n) != 1) {\n"
            + "                    return 0;\n"
            + "                }\n"
            + "            }\n"
            + "        }\n"
            + "        return 1;\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "        System.out.println(isCarmichaelNumber(500));\n"
            + "        System.out.println(isCarmichaelNumber(561));\n"
            + "System.out.println(isCarmichaelNumber(1105));\n"
            + "    }\n"
            + "}";
    private String sternbrocotsequence = "// Programa java que imprime   \n"
            + "// La secuencia de Stern Brocot\n"
            + "import java.util.*; \n"
            + "\n"
            + "public class SternBrocotSequence { \n"
            + "\n"
            + "static void SternSequenceFunc(ArrayList<Integer>\n"
            + "BrocotSequence, int n) \n"
            + "{ \n"
            + "// Ciclo que crea la secuencia\n"
            + "for (int i = 1; BrocotSequence.size() < n; i++) \n"
            + "    { \n"
            + "        int considered_element = BrocotSequence.get(i); \n"
            + "        int precedent = BrocotSequence.get(i-1); \n"
            + "//Agregando la suma de los elementos considerados\n"
            + "        // y son precedentes\n"
            + "        BrocotSequence.add(considered_element + precedent); \n"
            + "//  Agregando siguiente elemento considerado \n"
            + "        BrocotSequence.add(considered_element); \n"
            + "    } \n"
            + "// Imprimiendo secuencia\n"
            + "for (int i = 0; i < 15; ++i) \n"
            + "        System.out.print(BrocotSequence.get(i) + \" \"); \n"
            + "} \n"
            + "\n"
            + "    public static void main (String[] args) {   \n"
            + "        int n = 15; \n"
            + "        ArrayList<Integer> BrocotSequence = new ArrayList<Integer>(); \n"
            + "// Agregando primer y segundo valor \n"
            + "        // A la secuencia\n"
            + "BrocotSequence.add(1); \n"
            + "        BrocotSequence.add(1); \n"
            + "        SternSequenceFunc(BrocotSequence, n);    \n"
            + "} \n"
            + "}";
    private String sylvestersequence = "//Implementación java de la secuencia Sylvester  \n"
            + "public class SylvesterSequence { \n"
            + "\n"
            + "    public static void printSequence(int n) \n"
            + "{ \n"
            + "        int a = 1; // Para almacenar el producto\n"
            + "        int ans = 2; // Para almacenar el número actual\n"
            + "int N = 1000000007; \n"
            + "        //Ciclo hasta n\n"
            + "        for (int i = 1; i <= n; i++) { \n"
            + "           System.out.print(ans + \" \"); \n"
            + "            ans = ((a % N) * (ans % N)) % N; \n"
            + "            a = ans; \n"
            + "            ans = (ans + 1) % N; \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args)  \n"
            + "{ \n"
            + "        int n = 6; \n"
            + "        printSequence(n); \n"
            + "\n"
            + "    } \n"
            + "}";
    private String aliquotsequence = "//Implementación java de una apoximación\n"
            + "// de la secuencia Aliquot \n"
            + "import java.util.*; \n"
            + "\n"
            + "public class AliquotSequence  \n"
            + "{ \n"
            + "// Función que calcula suma de \n"
            + "    // los divisores adecuados\n"
            + "static int getSum(int n)  \n"
            + "{ \n"
            + "        int sum = 0; // 1 es un divisor adecuado\n"
            + "for (int i = 1; i <= Math.sqrt(n); i++) \n"
            + "{ \n"
            + "            if (n % i == 0)  \n"
            + "            {   // Si divisores son iguales, solo toma uno \n"
            + "if (n / i == i)  \n"
            + "                { \n"
            + "                    sum = sum + i; \n"
            + "} \n"
            + "                else // Si no tome ambos\n"
            + "                { \n"
            + "sum = sum + i; \n"
            + "                    sum = sum + (n / i); \n"
            + "} \n"
            + "            } \n"
            + "        } \n"
            + "\n"
            + "// Calcula la suma de los divisores adecuados\n"
            + "return sum - n; \n"
            + "    } \n"
            + "\n"
            + "    static void printAliquot(int n)  \n"
            + "{ \n"
            + "\n"
            + "// Imprime el primer termino\n"
            + "        System.out.printf(\"%d \", n);    \n"
            + "TreeSet<Integer> s = new TreeSet<>(); \n"
            + "        s.add(n); \n"
            + "\n"
            + "        int next = 0; \n"
            + "while (n > 0)  \n"
            + "        {   // Calcula siguiente termino desde el anterior\n"
            + "n = getSum(n); \n"
            + "            if (s.contains(n) && n != s.last())  \n"
            + "            { \n"
            + "                System.out.print(\"\\nRepeats with \" + n); \n"
            + "                break; \n"
            + "            } \n"
            + "            //Imprimir siguiente termino\n"
            + "            System.out.print(n + \" \"); \n"
            + "            s.add(n); \n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String[] args)  \n"
            + "{ \n"
            + "        printAliquot(12); \n"
            + "    } \n"
            + "}";
    private String jugglersequence = "// Implementación java de la secuenca de Juggler\n"
            + "public class JugglerSequence {\n"
            + "    static void printJuggler(int n) {\n"
            + "int a = n;\n"
            + "// Imprime el primer termino\n"
            + "        System.out.print(a + \" \");\n"
            + "// Calcula terminos hasta que el ultimo no sea 1\n"
            + "        while (a != 1) {\n"
            + "            int b = 0;\n"
            + "// Verifica si los previos terminos son pares o impares\n"
            + "            if (a % 2 == 0) // calcular siguiente termino\n"
            + "            {\n"
            + "b = (int) Math.floor(Math.sqrt(a));\n"
            + "} else // para impar anterior, calcular \n"
            + "// Siguiente termino\n"
            + "{\n"
            + "                b = (int) Math.floor(Math.sqrt(a)\n"
            + "                        * Math.sqrt(a) * Math.sqrt(a));\n"
            + "            }\n"
            + "            System.out.print(b + \" \");\n"
            + "            a = b;\n"
            + "        }\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String[] args) {\n"
            + "        printJuggler(3);\n"
            + "        System.out.println();\n"
            + "        printJuggler(9);\n"
            + "}\n"
            + "}";
    private String moserdebrujinsequence = "// Codigo java que genera los primeros n terminos\n"
            + "// de la secuencia de  Moser-de Bruijn \n"
            + "\n"
            + "public class MoserdeBruijnSequence {\n"
            + "\n"
            + "    public static int gen(int n) {\n"
            + "\n"
            + "// S(0) = 0 \n"
            + "        if (n == 0) {\n"
            + "            return 0;\n"
            + "        } // S(1) = 1 \n"
            + "        else if (n == 1) {\n"
            + "            return 1;\n"
            + "        } // S(2 * n) = 4 * S(n) \n"
            + "        else if (n % 2 == 0) {\n"
            + "            return 4 * gen(n / 2);\n"
            + "        } // S(2 * n + 1) = 4 * S(n) + 1 \n"
            + "        else if (n % 2 == 1) {\n"
            + "            return 4 * gen(n / 2) + 1;\n"
            + "        }\n"
            + "        return 0;\n"
            + "    }\n"
            + "\n"
            + "    public static void moserDeBruijn(int n) {\n"
            + "        for (int i = 0; i < n; i++) {\n"
            + "            System.out.print(gen(i) + \" \");\n"
            + "        }\n"
            + "        System.out.println();\n"
            + "    }\n"
            + "\n"
            + "    public static void main(String args[]) {\n"
            + "int n = 15;\n"
            + "        System.out.println(\"Primeros \" + n\n"
            + "                + \" terminos de la secuencia de  \"\n"
            + "                + \"Moser-de Bruijn  : \");\n"
            + "        moserDeBruijn(n);\n"
            + "    }\n"
            + "}";
    private String newmanconwaysequence = "// Programa java que encuentra el nesimo  \n"
            + "// elemento de la secuencia de  Newman-Conway\n"
            + "public class NewmanConwaySequence { \n"
            + "    static int sequence(int n) \n"
            + "    { \n"
            + "        if (n == 1 || n == 2) \n"
            + "            return 1; \n"
            + "        else\n"
            + "            return sequence(sequence(n - 1))  \n"
            + "                  + sequence(n - sequence(n - 1)); \n"
            + "    } \n"
            + "	static intsequenceDP(intn) \n"
            + "{ \n"
            + "    intf[n + 1]; \n"
            + "    inti; \n"
            + "    f[0] = 0; \n"
            + "    f[1] = 1; \n"
            + "    f[2] = 1; \n"
            + "  \n"
            + "    for(i = 3; i <= n; i++)  \n"
            + "        f[i] = f[f[i - 1]] + f[i - f[i - 1]];     \n"
            + "  \n"
            + "    returnf[n]; \n"
            + "} \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        int n = 10; \n"
            + "        System.out.println(sequence(n)); \n"
            + "} \n"
            + "}";
    private String padovansequence = "// Programa JAVA que encuentra el enesimo termino\n"
            + "// de la secuencia de Padovan\n"
            + "// usando programación dinamica  \n"
            + "public class PadovanSequence { \n"
            + "/* Función que calcula el número de Padovan*/\n"
            + "static int pad(int n) \n"
            + "{   //0,1 y 2 número de la serie es 1\n"
            + "int pPrevPrev = 1, pPrev = 1, \n"
            + "            pCurr = 1, pNext = 1; \n"
            + "        for (int i = 3; i <= n; i++) { \n"
            + "            pNext = pPrevPrev + pPrev; \n"
            + "            pPrevPrev = pPrev; \n"
            + "            pPrev = pCurr; \n"
            + "            pCurr = pNext; \n"
            + "        } \n"
            + "        return pNext; \n"
            + "    } \n"
            + "\n"
            + "    public static void main(String args[]) \n"
            + "    { \n"
            + "        int n = 12; \n"
            + "        System.out.println(pad(n)); \n"
            + "} \n"
            + "}";
    private String recamansequence = "// Programa java que imprime el nesimo número\n"
            + "// de la secuencia de Recaman\n"
            + "public class RecamanSequence  { \n"
            + "\n"
            + "static void recaman(int n) \n"
            + "{   //Crea un array que almacenara los terminos\n"
            + "int arr[] = new int[n]; \n"
            + "// Primer termino de la secuencia es siempre 0\n"
            + "arr[0] = 0; \n"
            + "        System.out.print(arr[0]+\" ,\"); \n"
            + "// Llena terminos restantes usando formula recursiva\n"
            + "for (int i = 1; i < n; i++) \n"
            + "        { \n"
            + "            int curr = arr[i - 1] - i; \n"
            + "            int j; \n"
            + "            for (j = 0; j < i; j++) \n"
            + "{   // si arr[i-1] - i es negativo or ya existe \n"
            + "if ((arr[j] == curr) || curr < 0) \n"
            + "                { \n"
            + "                    curr = arr[i - 1] + i; \n"
            + "                    break; \n"
            + "                } \n"
            + "            } \n"
            + "            arr[i] = curr; \n"
            + "            System.out.print(arr[i]+\", \"); \n"
            + "\n"
            + "        } \n"
            + "    } \n"
            + "\n"
            + "\n"
            + "    public static void main (String[] args)  \n"
            + "{ \n"
            + "        int n = 17; \n"
            + "        recaman(n); \n"
            + "    } \n"
            + "}";

    public String getCiclosjava() {
        return ciclosjava;
    }

    public void setCiclosjava(String ciclosjava) {
        this.ciclosjava = ciclosjava;
    }

    public String getLecturajava() {
        return lecturajava;
    }

    public void setLecturajava(String lecturajava) {
        this.lecturajava = lecturajava;
    }

    public String getLecturacpp() {
        return lecturacpp;
    }

    public void setLecturacpp(String lecturacpp) {
        this.lecturacpp = lecturacpp;
    }

    public String getLecturapy() {
        return lecturapy;
    }

    public void setLecturapy(String lecturapy) {
        this.lecturapy = lecturapy;
    }

    public String getCondicionalesjava() {
        return condicionalesjava;
    }

    public void setCondicionalesjava(String condicionalesjava) {
        this.condicionalesjava = condicionalesjava;
    }

    public String getCondicionalescpp() {
        return condicionalescpp;
    }

    public void setCondicionalescpp(String condicionalescpp) {
        this.condicionalescpp = condicionalescpp;
    }

    public String getCondicionalespy() {
        return condicionalespy;
    }

    public void setCondicionalespy(String condicionalespy) {
        this.condicionalespy = condicionalespy;
    }

    public String getExcepcionesjava() {
        return excepcionesjava;
    }

    public void setExcepcionesjava(String excepcionesjava) {
        this.excepcionesjava = excepcionesjava;
    }

    public String getExcepcionespy() {
        return excepcionespy;
    }

    public void setExcepcionespy(String excepcionespy) {
        this.excepcionespy = excepcionespy;
    }

    public String getTiempoejecucion() {
        return tiempoejecucion;
    }

    public void setTiempoejecucion(String tiempoejecucion) {
        this.tiempoejecucion = tiempoejecucion;
    }

    public String getEstructurasjava() {
        return estructurasjava;
    }

    public void setEstructurasjava(String estructurasjava) {
        this.estructurasjava = estructurasjava;
    }

    public String getEstructurascpp() {
        return estructurascpp;
    }

    public void setEstructurascpp(String estructurascpp) {
        this.estructurascpp = estructurascpp;
    }

    public String getEstructuraspy() {
        return estructuraspy;
    }

    public void setEstructuraspy(String estructuraspy) {
        this.estructuraspy = estructuraspy;
    }

    public String getBinarysearch() {
        return binarysearch;
    }

    public void setBinarysearch(String binarysearch) {
        this.binarysearch = binarysearch;
    }

    public String getExponentialsearch() {
        return exponentialsearch;
    }

    public void setExponentialsearch(String exponentialsearch) {
        this.exponentialsearch = exponentialsearch;
    }

    public String getArraymaxminsearch() {
        return arraymaxminsearch;
    }

    public void setArraymaxminsearch(String arraymaxminsearch) {
        this.arraymaxminsearch = arraymaxminsearch;
    }

    public String getFibonaccisearch() {
        return fibonaccisearch;
    }

    public void setFibonaccisearch(String fibonaccisearch) {
        this.fibonaccisearch = fibonaccisearch;
    }

    public String getJumpsearch() {
        return jumpsearch;
    }

    public void setJumpsearch(String jumpsearch) {
        this.jumpsearch = jumpsearch;
    }

    public String getMinabssumpair() {
        return minabssumpair;
    }

    public void setMinabssumpair(String minabssumpair) {
        this.minabssumpair = minabssumpair;
    }

    public String getMissingnosearch() {
        return missingnosearch;
    }

    public void setMissingnosearch(String missingnosearch) {
        this.missingnosearch = missingnosearch;
    }

    public String getPairdifferrencesearch() {
        return pairdifferrencesearch;
    }

    public void setPairdifferrencesearch(String pairdifferrencesearch) {
        this.pairdifferrencesearch = pairdifferrencesearch;
    }

    public String getTernarysearch() {
        return ternarysearch;
    }

    public void setTernarysearch(String ternarysearch) {
        this.ternarysearch = ternarysearch;
    }

    public String getRecursivebubblesort() {
        return recursivebubblesort;
    }

    public void setRecursivebubblesort(String recursivebubblesort) {
        this.recursivebubblesort = recursivebubblesort;
    }

    public String getQuicksort() {
        return quicksort;
    }

    public void setQuicksort(String quicksort) {
        this.quicksort = quicksort;
    }

    public String getRadixsort() {
        return radixsort;
    }

    public void setRadixsort(String radixsort) {
        this.radixsort = radixsort;
    }

    public String getShellsort() {
        return shellsort;
    }

    public void setShellsort(String shellsort) {
        this.shellsort = shellsort;
    }

    public String getTimsort() {
        return timsort;
    }

    public void setTimsort(String timsort) {
        this.timsort = timsort;
    }

    public String getTreesort() {
        return treesort;
    }

    public void setTreesort(String treesort) {
        this.treesort = treesort;
    }

    public String getMergesort() {
        return mergesort;
    }

    public void setMergesort(String mergesort) {
        this.mergesort = mergesort;
    }

    public String getBinaryinsertionsort() {
        return binaryinsertionsort;
    }

    public void setBinaryinsertionsort(String binaryinsertionsort) {
        this.binaryinsertionsort = binaryinsertionsort;
    }

    public String getBitonicsort() {
        return bitonicsort;
    }

    public void setBitonicsort(String bitonicsort) {
        this.bitonicsort = bitonicsort;
    }

    public String getCocktailsort() {
        return cocktailsort;
    }

    public void setCocktailsort(String cocktailsort) {
        this.cocktailsort = cocktailsort;
    }

    public String getCombsort() {
        return combsort;
    }

    public void setCombsort(String combsort) {
        this.combsort = combsort;
    }

    public String getCountingsort() {
        return countingsort;
    }

    public void setCountingsort(String countingsort) {
        this.countingsort = countingsort;
    }

    public String getCyclesort() {
        return cyclesort;
    }

    public void setCyclesort(String cyclesort) {
        this.cyclesort = cyclesort;
    }

    public String getMergesort3way() {
        return mergesort3way;
    }

    public void setMergesort3way(String mergesort3way) {
        this.mergesort3way = mergesort3way;
    }

    public String getPigeonholesort() {
        return pigeonholesort;
    }

    public void setPigeonholesort(String pigeonholesort) {
        this.pigeonholesort = pigeonholesort;
    }

    public String getAhocorasick() {
        return ahocorasick;
    }

    public void setAhocorasick(String ahocorasick) {
        this.ahocorasick = ahocorasick;
    }

    public String getAnagramspattern() {
        return anagramspattern;
    }

    public void setAnagramspattern(String anagramspattern) {
        this.anagramspattern = anagramspattern;
    }

    public String getBoyermoore() {
        return boyermoore;
    }

    public void setBoyermoore(String boyermoore) {
        this.boyermoore = boyermoore;
    }

    public String getFiniteautomata() {
        return finiteautomata;
    }

    public void setFiniteautomata(String finiteautomata) {
        this.finiteautomata = finiteautomata;
    }

    public String getKmpstringmatching() {
        return kmpstringmatching;
    }

    public void setKmpstringmatching(String kmpstringmatching) {
        this.kmpstringmatching = kmpstringmatching;
    }

    public String getManacheralgorithm() {
        return manacheralgorithm;
    }

    public void setManacheralgorithm(String manacheralgorithm) {
        this.manacheralgorithm = manacheralgorithm;
    }

    public String getRabinkarp() {
        return rabinkarp;
    }

    public void setRabinkarp(String rabinkarp) {
        this.rabinkarp = rabinkarp;
    }

    public String getWildcardpattern() {
        return wildcardpattern;
    }

    public void setWildcardpattern(String wildcardpattern) {
        this.wildcardpattern = wildcardpattern;
    }

    public String getGcdlcm() {
        return gcdlcm;
    }

    public void setGcdlcm(String gcdlcm) {
        this.gcdlcm = gcdlcm;
    }

    public String getPrimalitytest() {
        return primalitytest;
    }

    public void setPrimalitytest(String primalitytest) {
        this.primalitytest = primalitytest;
    }

    public String getPrimefactors() {
        return primefactors;
    }

    public void setPrimefactors(String primefactors) {
        this.primefactors = primefactors;
    }

    public String getDivisibilitybysmallnumbers() {
        return divisibilitybysmallnumbers;
    }

    public void setDivisibilitybysmallnumbers(String divisibilitybysmallnumbers) {
        this.divisibilitybysmallnumbers = divisibilitybysmallnumbers;
    }

    public String getNumberofdivisors() {
        return numberofdivisors;
    }

    public void setNumberofdivisors(String numberofdivisors) {
        this.numberofdivisors = numberofdivisors;
    }

    public String getPrimenumbers() {
        return primenumbers;
    }

    public void setPrimenumbers(String primenumbers) {
        this.primenumbers = primenumbers;
    }

    public String getFibonaccilastdigit() {
        return fibonaccilastdigit;
    }

    public void setFibonaccilastdigit(String fibonaccilastdigit) {
        this.fibonaccilastdigit = fibonaccilastdigit;
    }

    public String getLongfibonacci() {
        return longfibonacci;
    }

    public void setLongfibonacci(String longfibonacci) {
        this.longfibonacci = longfibonacci;
    }

    public String getIsfibonumber() {
        return isfibonumber;
    }

    public void setIsfibonumber(String isfibonumber) {
        this.isfibonumber = isfibonumber;
    }

    public String getAllpermutations() {
        return allpermutations;
    }

    public void setAllpermutations(String allpermutations) {
        this.allpermutations = allpermutations;
    }

    public String getCombination() {
        return combination;
    }

    public void setCombination(String combination) {
        this.combination = combination;
    }

    public String getCombinationscompose() {
        return combinationscompose;
    }

    public void setCombinationscompose(String combinationscompose) {
        this.combinationscompose = combinationscompose;
    }

    public String getAllsets() {
        return allsets;
    }

    public void setAllsets(String allsets) {
        this.allsets = allsets;
    }

    public String getHanoitowels() {
        return hanoitowels;
    }

    public void setHanoitowels(String hanoitowels) {
        this.hanoitowels = hanoitowels;
    }

    public String getAxplusbyequalsn() {
        return axplusbyequalsn;
    }

    public void setAxplusbyequalsn(String axplusbyequalsn) {
        this.axplusbyequalsn = axplusbyequalsn;
    }

    public String getAmodxequalb() {
        return amodxequalb;
    }

    public void setAmodxequalb(String amodxequalb) {
        this.amodxequalb = amodxequalb;
    }

    public String getFactorial() {
        return factorial;
    }

    public void setFactorial(String factorial) {
        this.factorial = factorial;
    }

    public String getBigfactorial() {
        return bigfactorial;
    }

    public void setBigfactorial(String bigfactorial) {
        this.bigfactorial = bigfactorial;
    }

    public String getBinomialcoefficients() {
        return binomialcoefficients;
    }

    public void setBinomialcoefficients(String binomialcoefficients) {
        this.binomialcoefficients = binomialcoefficients;
    }

    public String getCassiniidentity() {
        return cassiniidentity;
    }

    public void setCassiniidentity(String cassiniidentity) {
        this.cassiniidentity = cassiniidentity;
    }

    public String getEpowx() {
        return epowx;
    }

    public void setEpowx(String epowx) {
        this.epowx = epowx;
    }

    public String getEuclideulertheorem() {
        return euclideulertheorem;
    }

    public void setEuclideulertheorem(String euclideulertheorem) {
        this.euclideulertheorem = euclideulertheorem;
    }

    public String getEuclideanalgorithm() {
        return euclideanalgorithm;
    }

    public void setEuclideanalgorithm(String euclideanalgorithm) {
        this.euclideanalgorithm = euclideanalgorithm;
    }

    public String getEulertotient() {
        return eulertotient;
    }

    public void setEulertotient(String eulertotient) {
        this.eulertotient = eulertotient;
    }

    public String getFactorialnumdigits() {
        return factorialnumdigits;
    }

    public void setFactorialnumdigits(String factorialnumdigits) {
        this.factorialnumdigits = factorialnumdigits;
    }

    public String getFactorialnumdigitsop() {
        return factorialnumdigitsop;
    }

    public void setFactorialnumdigitsop(String factorialnumdigitsop) {
        this.factorialnumdigitsop = factorialnumdigitsop;
    }

    public String getFermatlittletheorem() {
        return fermatlittletheorem;
    }

    public void setFermatlittletheorem(String fermatlittletheorem) {
        this.fermatlittletheorem = fermatlittletheorem;
    }

    public String getFibonaccigoldenratio() {
        return fibonaccigoldenratio;
    }

    public void setFibonaccigoldenratio(String fibonaccigoldenratio) {
        this.fibonaccigoldenratio = fibonaccigoldenratio;
    }

    public String getFloatgcd() {
        return floatgcd;
    }

    public void setFloatgcd(String floatgcd) {
        this.floatgcd = floatgcd;
    }

    public String getFractionsproduct() {
        return fractionsproduct;
    }

    public void setFractionsproduct(String fractionsproduct) {
        this.fractionsproduct = fractionsproduct;
    }

    public String getJosephus() {
        return josephus;
    }

    public void setJosephus(String josephus) {
        this.josephus = josephus;
    }

    public String getCardinalnumbers() {
        return cardinalnumbers;
    }

    public void setCardinalnumbers(String cardinalnumbers) {
        this.cardinalnumbers = cardinalnumbers;
    }

    public String getRomannumbers() {
        return romannumbers;
    }

    public void setRomannumbers(String romannumbers) {
        this.romannumbers = romannumbers;
    }

    public String getGcdmultiple() {
        return gcdmultiple;
    }

    public void setGcdmultiple(String gcdmultiple) {
        this.gcdmultiple = gcdmultiple;
    }

    public String getHardyramanujantheorem() {
        return hardyramanujantheorem;
    }

    public void setHardyramanujantheorem(String hardyramanujantheorem) {
        this.hardyramanujantheorem = hardyramanujantheorem;
    }

    public String getHoaxnumber() {
        return hoaxnumber;
    }

    public void setHoaxnumber(String hoaxnumber) {
        this.hoaxnumber = hoaxnumber;
    }

    public String getLargestpowdividesfactorial() {
        return largestpowdividesfactorial;
    }

    public void setLargestpowdividesfactorial(String largestpowdividesfactorial) {
        this.largestpowdividesfactorial = largestpowdividesfactorial;
    }

    public String getLcmofarrayelements() {
        return lcmofarrayelements;
    }

    public void setLcmofarrayelements(String lcmofarrayelements) {
        this.lcmofarrayelements = lcmofarrayelements;
    }

    public String getLeonardonumber() {
        return leonardonumber;
    }

    public void setLeonardonumber(String leonardonumber) {
        this.leonardonumber = leonardonumber;
    }

    public String getModularexponentiation() {
        return modularexponentiation;
    }

    public void setModularexponentiation(String modularexponentiation) {
        this.modularexponentiation = modularexponentiation;
    }

    public String getMultipleeulertotient() {
        return multipleeulertotient;
    }

    public void setMultipleeulertotient(String multipleeulertotient) {
        this.multipleeulertotient = multipleeulertotient;
    }

    public String getNaturalcoprimesum() {
        return naturalcoprimesum;
    }

    public void setNaturalcoprimesum(String naturalcoprimesum) {
        this.naturalcoprimesum = naturalcoprimesum;
    }

    public String getZeckendorftheorem() {
        return zeckendorftheorem;
    }

    public void setZeckendorftheorem(String zeckendorftheorem) {
        this.zeckendorftheorem = zeckendorftheorem;
    }

    public String getRossertheorem() {
        return rossertheorem;
    }

    public void setRossertheorem(String rossertheorem) {
        this.rossertheorem = rossertheorem;
    }

    public String getSieveoderathosthenesoptimizated() {
        return sieveoderathosthenesoptimizated;
    }

    public void setSieveoderathosthenesoptimizated(String sieveoderathosthenesoptimizated) {
        this.sieveoderathosthenesoptimizated = sieveoderathosthenesoptimizated;
    }

    public String getSmithnumber() {
        return smithnumber;
    }

    public void setSmithnumber(String smithnumber) {
        this.smithnumber = smithnumber;
    }

    public String getSphenicnumber() {
        return sphenicnumber;
    }

    public void setSphenicnumber(String sphenicnumber) {
        this.sphenicnumber = sphenicnumber;
    }

    public String getCatalannumbers() {
        return catalannumbers;
    }

    public void setCatalannumbers(String catalannumbers) {
        this.catalannumbers = catalannumbers;
    }

    public String getCharmichaelnumbers() {
        return charmichaelnumbers;
    }

    public void setCharmichaelnumbers(String charmichaelnumbers) {
        this.charmichaelnumbers = charmichaelnumbers;
    }

    public String getSternbrocotsequence() {
        return sternbrocotsequence;
    }

    public void setSternbrocotsequence(String sternbrocotsequence) {
        this.sternbrocotsequence = sternbrocotsequence;
    }

    public String getSylvestersequence() {
        return sylvestersequence;
    }

    public void setSylvestersequence(String sylvestersequence) {
        this.sylvestersequence = sylvestersequence;
    }

    public String getAliquotsequence() {
        return aliquotsequence;
    }

    public void setAliquotsequence(String aliquotsequence) {
        this.aliquotsequence = aliquotsequence;
    }

    public String getJugglersequence() {
        return jugglersequence;
    }

    public void setJugglersequence(String jugglersequence) {
        this.jugglersequence = jugglersequence;
    }

    public String getMoserdebrujinsequence() {
        return moserdebrujinsequence;
    }

    public void setMoserdebrujinsequence(String moserdebrujinsequence) {
        this.moserdebrujinsequence = moserdebrujinsequence;
    }

    public String getNewmanconwaysequence() {
        return newmanconwaysequence;
    }

    public void setNewmanconwaysequence(String newmanconwaysequence) {
        this.newmanconwaysequence = newmanconwaysequence;
    }

    public String getPadovansequence() {
        return padovansequence;
    }

    public void setPadovansequence(String padovansequence) {
        this.padovansequence = padovansequence;
    }

    public String getRecamansequence() {
        return recamansequence;
    }

    public void setRecamansequence(String recamansequence) {
        this.recamansequence = recamansequence;
    }
   
}
