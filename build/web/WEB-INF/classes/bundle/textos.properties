
#index
artemis.index.introduccion    = El crecimiento y expansi\u00f3n que ha presentado la inform\u00e1tica ha hecho que las grandes compa\u00f1\u00edas se interesen  en vincular  excelentes profesionales a su equipo de trabajo, en especial  se dedican a buscar buenos programadores para su grupo de desarrollo,  los cuales  pueden ser   incorporados desde eventos que se han estado realizando hace ya varios a\u00f1os, estos han tomado por nombre \u201cmaratones de programaci\u00f3n\u201d, las cuales se llevan a cabo anualmente, en estas participan varias universidades de todo el mundo donde los problemas expuestos son de tipo l\u00f3gico, matem\u00e1tico, trigonom\u00e9trico, entre otros, estos deben resolverse usando algoritmos de programaci\u00f3n  en el menor tiempo posible.  Dichos eventos tienen como finalidad principalmente destacar a los estudiantes con mayor habilidad y pasi\u00f3n en el arte de la codificaci\u00f3n para que posteriormente compitan a nivel regional, nacional y mundialmente. Adem\u00e1s de que los estudiantes destacados sean llamados por importantes compa\u00f1\u00edas para su vinculaci\u00f3n laboral.

#lenguajes
artemis.lenguajes.java.intro       = Es un lenguaje de programaci\u00f3n de prop\u00f3sito general, concurrente, orientado a objetos, que fue dise\u00f1ado espec\u00edficamente para tener tan pocas dependencias de implementaci\u00f3n como fuera posible. Su intenci\u00f3n es permitir que los desarrolladores de aplicaciones escriban el programa una vez y lo ejecuten en cualquier dispositivo, lo que quiere decir que el c\u00f3digo que es ejecutado en una plataforma no tiene que ser recompilado para correr en otra. Java es, a partir de 2012, uno de los lenguajes de programaci\u00f3n m\u00e1s populares en uso, particularmente para aplicaciones de cliente-servidor de web, con unos diez millones de usuarios reportados.  
artemis.lenguajes.python.intro     = Es un lenguaje de programaci\u00f3n interpretado cuya filosof\u00eda hace hincapi\u00e9 en una sintaxis que favorezca un c\u00f3digo legible. Se trata de un lenguaje de programaci\u00f3n multiparadigma, ya que soporta orientaci\u00f3n a objetos, programaci\u00f3n imperativa y, en menor medida, programaci\u00f3n funcional. Es un lenguaje interpretado, usa tipado din\u00e1mico y es multiplataforma.
artemis.lenguajes.cpp.intro        = Es un lenguaje de programaci\u00f3n dise\u00f1ado en 1979 por Bjarne Stroustrup. La intenci\u00f3n de su creaci\u00f3n fue extender al lenguaje de programaci\u00f3n C mecanismos que permiten la manipulaci\u00f3n de objetos. En ese sentido, desde el punto de vista de los lenguajes orientados a objetos, el C++ es un lenguaje h\u00edbrido. Posteriormente se a\u00f1adieron facilidades de programaci\u00f3n gen\u00e9rica, que se sumaron a los paradigmas de estructurada y programaci\u00f3n orientada a objetos. Por esto se suele decir que el C++ es un lenguaje de programaci\u00f3n multiparadigma.


# programacion competitiva
artemis.pcompetitiva.intro              = Las competencias de programaci\u00f3n a nivel mundial han demostrado ser una valiosa herramienta para el aprendizaje y desarrollo de habilidades relacionadas a la programaci\u00f3n en funci\u00f3n de resoluci\u00f3n de problemas, muchas de estas competencias emplean diversos aplicativos webs para el entrenamiento y evaluaci\u00f3n de los estudiantes.
artemis.pcompetitiva.introb             = Es un concurso de programaci\u00f3n algor\u00edtmica para estudiantes universitarios. Equipos de uno a tres integrantes, que representan a su universidad, trabajan para resolver los problemas de la vida real, fomentando la colaboraci\u00f3n, la creatividad, la innovaci\u00f3n y la capacidad de actuar bajo presi\u00f3n. A trav\u00e9s del entrenamiento y la competencia, los equipos se desaf\u00edan unos a otros para elevar la presi\u00f3n y la rapidez con el cual realizan los problemas.  
artemis.pcompetitiva.problema.intro     = Un problema de programaci\u00f3n competitiva es un peque\u00f1o ejercicio de programaci\u00f3n que puede abordar cualquier tema de la vida cotidiana, ciencias puras como la matem\u00e1tica o la f\u00edsica, un juego de mesa como el ajedrez o un rompecabezas. Utilizando la programaci\u00f3n se pueden resolver estos ejercicios y buscar una soluci\u00f3n \u00f3ptima al mismo utilizando matem\u00e1tica, algoritmos matem\u00e1ticos especializados o incluso l\u00f3gica b\u00e1sica.
artemis.pcompetitiva.intro.img.title    = XXXI Marat\u00f3n Nacional de Programaci\u00f3n ACIS-REDIS, Bogot\u00e1 - Colombia

#competencias
artemis.competencias.icpc.title     = The ACM-ICPC International Collegiate Programming Contest
artemis.competencias.icpc.text      = El Concurso Internacional de Programaci\u00f3n Colegial (International Collegiate Programming Contest ICPC) es un concurso de programaci\u00f3n algor\u00edtmica para estudiantes universitarios. Equipos de tres, que representan a su universidad, trabajan para resolver los problemas m\u00e1s reales del mundo, fomentando la colaboraci\u00f3n, la creatividad, la innovaci\u00f3n y la capacidad de desempe\u00f1arse bajo presi\u00f3n. A trav\u00e9s del entrenamiento y la competencia, los equipos se desaf\u00edan entre s\u00ed para elevar el nivel de lo posible. En pocas palabras, es el concurso de programaci\u00f3n m\u00e1s antiguo, m\u00e1s grande y m\u00e1s prestigioso del mundo.
artemis.competencias.icpc.textb     = El ICPC se remonta a 1970, cuando los pioneros del Cap\u00edtulo Alfa de la Sociedad de Honor de Ciencias de la Computaci\u00f3n de la UPE organizaron la primera competencia. La iniciativa se difundi\u00f3 r\u00e1pidamente dentro de los Estados Unidos y Canad\u00e1 como un programa innovador para aumentar la ambici\u00f3n, la capacidad de resoluci\u00f3n de problemas y las oportunidades de los estudiantes m\u00e1s s\u00f3lidos en el campo de la inform\u00e1tica.
artemis.competencias.icpc.textc     = Con el tiempo, el concurso se convirti\u00f3 en una competencia de varios niveles con la primera ronda de campeonato llevada a cabo en 1977. Desde entonces, el concurso se ha convertido en una colaboraci\u00f3n mundial de universidades que organizan competiciones regionales que hacen avanzar a los equipos a la ronda de campeonatos mundial anual,  Las finales mundiales de ICPC (ICPC World Finals). 
artemis.competencias.google.title   = Google\u2019s Coding Competitions
artemis.competencias.google.text    = Google Code Jam es una competencia anual de programaci\u00f3n en la que se pide a los programadores profesionales y estudiantes que resuelvan desaf\u00edos algor\u00edtmicos complejos en un tiempo limitado, utilizando el lenguaje de programaci\u00f3n de su elecci\u00f3n. Este concurso comienza en l\u00ednea y los programadores pueden practicar probando problemas de a\u00f1os pasados.
artemis.competencias.google.textb   = Google Hash Code es un desaf\u00edo de codificaci\u00f3n para equipos de estudiantes y profesionales de todo el mundo. Los mejores equipos ser\u00e1n invitados a una oficina de Google para la ronda final.
artemis.competencias.google.textc   = Google Kick Start es una competencia global de codificaci\u00f3n en l\u00ednea, que consta de rondas de tres horas de una variedad de desaf\u00edos algor\u00edtmicos dise\u00f1ados por ingenieros de Google. Estas competencias se llevan a cabo durante todo el a\u00f1o y los participantes pueden tener la oportunidad de ser invitados a entrevistarse en Google
artemis.competencias.acis.title     = Marat\u00f3n Nacional de Programaci\u00f3n ACIS - REDIS
artemis.competencias.acis.text      = La Marat\u00f3n Nacional de Programaci\u00f3n, organizada por la Asociaci\u00f3n Colombiana de Ingenieros de Sistemas ACIS sirve de mecanismo para clasificar a la Marat\u00f3n Regional Latinoamericana ICPC  que, a su vez, sirve de selectivo para participar en la final mundial de la International Collegiate Programming Contest.
artemis.competencias.ccpl.title     = Colombian Collegiate Programming League
artemis.competencias.ccpl.text      = Colombian Collegiate Programming League (CCPL) es la liga de competencia en programaci\u00f3n m\u00e1s grande de Colombia, realizando diferentes rondas por a\u00f1o en donde las diferentes entidades de educaci\u00f3n superior env\u00edan equipos de estudiantes a competir, las competencias se realizan en diferentes sedes cada ronda y funcionan como entrenamiento para las competencias clasificatorias nacionales en Colombia.
artemis.competencias.masinfo.label  = Mas informaci\u00f3n en: 

#paginas entrenamiento
artemis.entrenamiento.p\u00e1ginas.text          = La comunidad de programaci\u00f3n competitiva alrededor del mundo ha creado y mantenido varios recursos dedicados de internet para la programaci\u00f3n competitiva, ellos ofrecen competencias internas con o sin premios, tambi\u00e9n los archivos de problemas pasados tambi\u00e9n se encuentran en estos para entrenamiento.
artemis.entrenamieto.primera.nombre         = CodeChef
artemis.entrenamieto.primera.descripcion    = Administrado por  by Directi, hostea competencias de 10 d\u00edas de largo un par de competencias peque\u00f1as cada mes, provee una plataforma de creaci\u00f3n de competencias para institutos acad\u00e9micos gratuitamente. El top 10 de ganadores de las competencias grandes obtiene premios en met\u00e1lico y camisetas de tazas de t\u00e9.
artemis.entrenamieto.primera.sitio          = www.codechef.com
artemis.entrenamieto.segundo.nombre         = CodeCup
artemis.entrenamieto.segundo.descripcion    = Competencia anual de programaci\u00f3n IA organizada por la Dutch Olympiad in Informatics desde  2003. 
artemis.entrenamieto.segundo.sitio          = www.codecup.nl
artemis.entrenamieto.tercero.nombre         = Codeforces
artemis.entrenamieto.tercero.descripcion    = Recurso ruso, manten\u00eda por la universidad ITMO, la cual mayormente provee competencias peque\u00f1as una o dos por semana.
artemis.entrenamieto.tercero.sitio          = www.codeforces.com
artemis.entrenamieto.cuarto.nombre          = CodinGame
artemis.entrenamieto.cuarto.descripcion     = Rompecabezas, code golf, organiza regularmente competencias de IA y problemas de optimizaci\u00f3n.
artemis.entrenamieto.cuarto.sitio           = www.codingame.com
artemis.entrenamieto.quinto.nombre          = HackerEarth
artemis.entrenamieto.quinto.descripcion     = Compa\u00f1\u00eda Hind\u00fa que provee entornos de competencia para reclutamiento de personal.
artemis.entrenamieto.quinto.sitio           = www.hackerearth.com
artemis.entrenamieto.sexto.nombre           = HackerRank
artemis.entrenamieto.sexto.descripcion      = Ofrece problemas de programaci\u00f3n en diferentes dominios de las ciencias de la computaci\u00f3n, tambi\u00e9n aloja una competencia anual que permite conexi\u00f3n entre los programadores y los diferentes Startups de Silicon Valley.
artemis.entrenamieto.sexto.sitio            = www.hackerrank.com
artemis.entrenamieto.septimo.nombre         = Project Euler
artemis.entrenamieto.septimo.descripcion    = Gran colecci\u00f3n de problemas matem\u00e1ticos computacionales.
artemis.entrenamieto.septimo.sitio          = www.projecteuler.net
artemis.entrenamieto.octavo.nombre          = Topcoder
artemis.entrenamieto.octavo.descripcion     = Recurso Norteamericano, el cual organiza competencias y tambi\u00e9n provee problemas de clase industrial, como trabajos Freelance, realiza docenas de competencias cada a\u00f1o.
artemis.entrenamieto.octavo.sitio           = www.topcoder.com
artemis.entrenamieto.noveno.nombre          = Online Judge
artemis.entrenamieto.noveno.descripcion     = Contiene m\u00e1s de 10.000 problemas de entrenamiento, almacena los diferentes problemas realizados en competencias clasificatorias en todo el mundo.
artemis.entrenamieto.noveno.sitio           = www.onlinejudge.org


#Biblioteca - Basico
artemis.biblioteca.general.codigoejemplo.title              = C\u00f3digo de ejemplo:
artemis.biblioteca.basico.operadores.text                   = Los operadores l\u00f3gicos nos proporcionan un resultado a partir de que se cumpla o no una cierta condici\u00f3n, producen un resultado booleano, y sus operandos son tambi\u00e9n valores l\u00f3gicos o asimilables a ellos (los valores num\u00e9ricos son asimilados a cierto o falso seg\u00fan su valor sea cero o distinto de cero). Esto genera una serie de valores que, en los casos m\u00e1s sencillos, pueden ser parametrizados con los valores num\u00e9ricos 0 y 1. La combinaci\u00f3n de dos o m\u00e1s operadores l\u00f3gicos conforma una funci\u00f3n l\u00f3gica.
artemis.biblioteca.basico.lecturaescritura.text             = Las lecturas e impresiones de nuestros ejercicios de programaci\u00f3n competitiva, sus algoritmos base y sus modificaciones se realizan por la consola (STDIN, STDOUT), por lo que la programaci\u00f3n de entornos gr\u00e1ficos para nuestros c\u00f3digos no es v\u00e1lida, los siguientes c\u00f3digos muestran ejemplos de c\u00f3mo se realizan las entradas y salidas de diferentes tipos de variables.
artemis.biblioteca.basico.tiempodeejecucion.text            = El tiempo de ejecuci\u00f3n es el per\u00edodo en el que un programa es ejecutado por el sistema operativo. El per\u00edodo comienza cuando el programa es llevado a la memoria primaria y comienzan a ejecutarse sus instrucciones. El per\u00edodo finaliza cuando el programa env\u00eda la se\u00f1al de t\u00e9rmino (normal o anormal) al sistema operativo. Suele decirse tambi\u00e9n que un programa se encuentra "corriendo" mientras est\u00e1 siendo ejecutado. Otros tiempos de un programa son el tiempo de compilaci\u00f3n, el tiempo de enlazado y el tiempo de carga.
artemis.biblioteca.basico.expresionesregulares.text         = Una expresi\u00f3n regular, o expresi\u00f3n racional, es una secuencia de caracteres que conforma un patr\u00f3n de b\u00fasqueda. Tambi\u00e9n son conocidas como regex por su contracci\u00f3n de las palabras inglesas regular expression. Son principalmente utilizadas para la b\u00fasqueda de patrones de cadenas de caracteres u operaciones de sustituciones.
artemis.biblioteca.basico.expresionesregularesa.text        = \u2022  x|y: x o y
artemis.biblioteca.basico.expresionesregularesb.text        = \u2022  xy: x seguido de y
artemis.biblioteca.basico.expresionesregularesc.text        = \u2022  (): Agrupaci\u00f3n 
artemis.biblioteca.basico.expresionesregularesd.text        = \u2022  [abc]: Cualquiera de los caracteres entre corchetes. Pueden especificarse rangos, por ejemplo ([a-d] que equivale a [abcd]).
artemis.biblioteca.basico.expresionesregularese.text        = \u2022  [^abc]: Cualquier car\u00e1cter que no est\u00e9 entre los corchetes.
artemis.biblioteca.basico.expresionesregularesf.text        = \u2022  [a-zA-Z]: a a la z o A a la Z (Rango).
artemis.biblioteca.basico.expresionesregularesg.text        = \u2022  [a-z&&[def]]: d,e, o f (Intersecci\u00f3n)
artemis.biblioteca.basico.expresionesregularesh.text        = \u2022  [a-b&&[^bc]]: (Substracci\u00f3n) 
artemis.biblioteca.basico.expresionesregularesi.text        = \u2022  .: Cualquier car\u00e1cter individual, salvo el de salto de l\u00ednea
artemis.biblioteca.basico.expresionesregularesj.text        = \u2022  \d: Cualquier car\u00e1cter de digito, equivalente a [0-9]
artemis.biblioteca.basico.expresionesregularesk.text        = \u2022  \D: Cualquier car\u00e1cter que no sea del digito, equivalente a [^0-9]
artemis.biblioteca.basico.expresionesregularesl.text        = \u2022  \s: Cualquier car\u00e1cter individual de espacio en blanco (Espacios, tabulaciones, saltos de p\u00e1gina o saltos de l\u00ednea)
artemis.biblioteca.basico.expresionesregularesm.text        = \u2022  \S: Cualquier car\u00e1cter individual que no sea un espacio en blanco
artemis.biblioteca.basico.expresionesregularesn.text        = \u2022  \w: Cualquier car\u00e1cter alfanum\u00e9rico
artemis.biblioteca.basico.expresionesregulareso.text        = \u2022  \W: Cualquier car\u00e1cter que no sea alfanum\u00e9rico
artemis.biblioteca.basico.complejidad.text                  = En Ciencias de la Computaci\u00f3n, el t\u00e9rmino eficiencia algor\u00edtmica es usado para describir aquellas propiedades de los algoritmos que est\u00e1n relacionadas con la cantidad de recursos utilizados por el algoritmo. Un algoritmo debe ser analizado para determinar el uso de los recursos que realiza. La eficiencia algor\u00edtmica puede ser vista como an\u00e1logo a la ingenier\u00eda de productividad de un procesorepetitivo o continuo.
artemis.biblioteca.basico.ciclos.texta                      = Un condicional, como su nombre lo indica, es una condici\u00f3n para discernir entre una opci\u00f3n u otra, y en el proceso mental normalmente se manifiesta con un \u201cSi\u201d; por ejemplo: Si (va a llover), coge el paraguas. Sint\u00e1cticamente, IF es la palabra reservada para desencadenar el poder de los condicionales en el c\u00f3digo. ELSE expresa \u201cen el caso contrario\u201d. Siguiendo con el ejemplo anterior de la lluvia: if (va a llover) coge el paraguas else coge el ba\u00f1ador.
artemis.biblioteca.basico.ciclos.textb                      = Un bucle o ciclo, en programaci\u00f3n, es una secuencia que ejecuta repetidas veces un trozo de c\u00f3digo, hasta que la condici\u00f3n asignada a dicho bucle deja de cumplirse. Los tres bucles m\u00e1s utilizados en programaci\u00f3n son el bucle while, el bucle for y el bucle do-while.
artemis.biblioteca.basico.ciclos.ejemplo                    = Ejemplo de entrada : 5


#Estructuras de datos B\u00e1sicas
artemis.estructuras.descripcion.text                                    = Lo habitual es que un vector tenga una cantidad fija de memoria asignada, aunque dependiendo del tipo de vector y del lenguaje de programaci\u00f3n un vector podr\u00eda tener una cantidad variable de datos. En este caso, se les denomina vectores din\u00e1micos, en oposici\u00f3n, a los vectores con una cantidad fija de memoria asignada se los denomina vectores est\u00e1ticos. El uso de vectores din\u00e1micos requiere realizar una apropiada gesti\u00f3n de memoria din\u00e1mica. Un uso incorrecto de los vectores din\u00e1micos, o mejor dicho, una mala gesti\u00f3n de la memoria din\u00e1mica, puede conducir a una fuga de memoria. Al utilizar vectores din\u00e1micos siempre habr\u00e1 que liberar la memoria utilizada cuando \u00e9sta ya no se vaya a seguir utilizando. Lenguajes m\u00e1s modernos y de m\u00e1s alto nivel, cuentan con un mecanismo denominado recolector de basura que permiten que el programa decida si debe liberar el espacio bas\u00e1ndose en si se va a utilizar en el futuro o no un determinado objeto.
artemis.estructuras.vector.text                                         = Se le denomina vector o formaci\u00f3n (en ingl\u00e9s Array) a una zona de almacenamiento contiguo que contiene una serie de elementos del mismo tipo, los elementos de la matriz. Desde el punto de vista l\u00f3gico una matriz se puede ver como un conjunto de elementos ordenados en fila (o filas y columnas si tuviera dos dimensiones). Estas estructuras de datos son adecuadas para situaciones en las que el acceso a los datos se realice de forma aleatoria e impredecible. Por el contrario, si los elementos pueden estar ordenados y se va a utilizar acceso secuencial ser\u00eda m\u00e1s adecuado utilizar una lista, ya que esta estructura puede cambiar de tama\u00f1o f\u00e1cilmente durante la ejecuci\u00f3n de un programa.
artemis.estructuras.vectordinamico.text                                 = En programaci\u00f3n, un arreglo din\u00e1mico o Array din\u00e1mico, es un Array de elementos que crece o mengua din\u00e1micamente conforme los elementos se agregan o se eliminan. Se suministra como librer\u00edas est\u00e1ndar en muchos lenguajes modernos de programaci\u00f3n. 
artemis.estructuras.vectorsinrepetir.text                               = Set es una interfaz que ampl\u00eda la colecci\u00f3n. Es una colecci\u00f3n desordenada de objetos en la que no se pueden almacenar valores duplicados. Set tiene varios m\u00e9todos para agregar, eliminar, borrar, tama\u00f1o, etc. 
artemis.estructuras.matriz.text                                         = Es una tabla bidimensional de n\u00fameros consistentes en cantidades abstractas con las que se pueden realizar diferentes operaciones, como por ejemplo la suma, multiplicaci\u00f3n y descomposici\u00f3n de las mismas de varias formas, lo que tambi\u00e9n las hace un concepto clave en el campo del \u00e1lgebra lineal. Las matrices se utilizan para describir sistema de ecuaciones lineales, realizar un seguimiento de los coeficientes de una aplicaci\u00f3n lineal y registrar los datos que dependen de varios par\u00e1metros.
artemis.estructuras.diccionario.text                                    = Los mapas son contenedores asociativos que almacenan elementos de forma mapeada. Cada elemento tiene un valor clave y un valor asignado. No hay dos valores asignados que puedan tener los mismos valores clave
artemis.estructuras.pila.text                                           = Es una lista ordenada o estructura de datos que permite almacenar y recuperar datos, el modo de acceso a sus elementos es de tipo LIFO (del ingl\u00e9s Last In, First Out, \u00ab\u00faltimo en entrar, primero en salir\u00bb). Esta estructura se aplica en multitud de supuestos en el \u00e1rea de inform\u00e1tica debido a su simplicidad y capacidad de dar respuesta a numerosos procesos.
artemis.estructuras.cola.text                                           = Es una estructura de datos, caracterizada por ser una secuencia de elementos en la que la operaci\u00f3n de inserci\u00f3n push se realiza por un extremo y la operaci\u00f3n de extracci\u00f3n pop por el otro. Tambi\u00e9n se le llama estructura FIFO (del ingl\u00e9s First In First Out), debido a que el primer elemento en entrar ser\u00e1 tambi\u00e9n el primero en salir.
artemis.biblioteca.basico.condicionales_ciclos.condicional.text         = Un condicional, como su nombre lo indica, es una condici\u00f3n para discernir entre una opci\u00f3n u otra, y en el proceso mental normalmente se manifiesta con un \u201cSi\u201d; por ejemplo: Si (va a llover), coge el paraguas. Sint\u00e1cticamente, IF es la palabra reservada para desencadenar el poder de los condicionales en el c\u00f3digo. ELSE expresa \u201cen el caso contrario\u201d. Siguiendo con el ejemplo anterior de la lluvia: if (va a llover) coge el paraguas else coge el ba\u00f1ador.
artemis.biblioteca.basico.condicionales_ciclos.ciclo.text               = Un bucle o ciclo, en programaci\u00f3n, es una secuencia que ejecuta repetidas veces un trozo de c\u00f3digo, hasta que la condici\u00f3n asignada a dicho bucle deja de cumplirse. Los tres bucles m\u00e1s utilizados en programaci\u00f3n son el bucle while, el bucle for y el bucle do-while.
artemis.biblioteca.basico.excepciones.text                              = El manejo de excepciones es una t\u00e9cnica de programaci\u00f3n que permite al programador controlar los errores ocasionados durante la ejecuci\u00f3n de un programa inform\u00e1tico. Cuando ocurre cierto tipo de error, el sistema reacciona ejecutando un fragmento de c\u00f3digo que resuelve la situaci\u00f3n, por ejemplo retornando un mensaje de error o devolviendo un valor por defecto.
artemis.biblioteca.basico.excepciones.ejemplo_entrada.text              = Ejemplo de entrada = 5
artemis.biblioteca.basico.excepciones.c++_comentario.text               = No es necesario controlar las excepciones, no almacena nada nuevo por lo que  el programa mostrara el valor que anteriormente ten\u00eda esa posici\u00f3n de memoria 

#Biblioteca - identidades
artemis.biblioteca.identidades.text                             = Una identidad es la constataci\u00f3n de que dos objetos que matem\u00e1ticamente se escriben diferente, son de hecho el mismo objeto. En particular, una identidad es a una igualdad entre dos expresiones, lo que es cierto sean cuales sean los valores de las distintas variables empleadas. Las identidades, al confirmarse invariablemente su igualdad, suelen utilizarse para transformar una expresi\u00f3n matem\u00e1tica en otra equivalente, particularmente para resolver una ecuaci\u00f3n.

#Biblioteca - Busquedas
artemis.biblioteca.busquedas.fibonacci.text                     = La b\u00fasqueda de Fibonacci es una t\u00e9cnica basada en la comparaci\u00f3n que utiliza los n\u00fameros de Fibonacci para buscar un elemento en un array ordenado.
artemis.biblioteca.busquedas.fibonacci.text1                    = Similitudes con la b\u00fasqueda binaria:
artemis.biblioteca.busquedas.fibonacci.texta                    =-	Trabaja con arrays ordenados.
artemis.biblioteca.busquedas.fibonacci.textb                    =-	Es un algoritmo de dividir y conquistar.
artemis.biblioteca.busquedas.fibonacci.textc                    =-	Tiene una complejidad de registro y tiempo.
artemis.biblioteca.busquedas.fibonacci.textd                    = Diferencias con la b\u00fasqueda binaria:
artemis.biblioteca.busquedas.fibonacci.texte                    =-	La b\u00fasqueda de Fibonacci divide un array dado en partes desiguales
artemis.biblioteca.busquedas.fibonacci.textf                    =-	La b\u00fasqueda binaria usa el operador de divisi\u00f3n para dividir el rango. La b\u00fasqueda de Fibonacci no usa /, pero usa + y -. El operador de la divisi\u00f3n puede ser costoso en algunas CPU.
artemis.biblioteca.busquedas.fibonacci.textg                    =-	La b\u00fasqueda de Fibonacci examina elementos relativamente m\u00e1s cercanos en pasos subsiguientes. Por lo tanto, cuando la matriz de entrada es grande y no cabe en la memoria cach\u00e9 de la CPU o incluso en la RAM, la b\u00fasqueda de Fibonacci puede ser \u00fatil.
artemis.biblioteca.busquedas.fibonacci.texth                    =-	La idea es encontrar primero el n\u00famero de Fibonacci m\u00e1s peque\u00f1o que sea mayor o igual a la longitud de la matriz dada.
artemis.biblioteca.busquedas.saltos.text                        =  Al igual que Binary Search, Jump Search es un algoritmo de b\u00fasqueda para matrices ordenadas. La idea b\u00e1sica es verificar menos elementos (que la b\u00fasqueda lineal) saltando hacia delante con pasos fijos u salteando algunos elementos en lugar de buscar todos los elementos. En el peor de los casos, tenemos que realizar saltos de n / m y, si el \u00faltimo valor verificado es mayor que el elemento a buscar, realizamos comparaciones de m-1 m\u00e1s para la b\u00fasqueda lineal. Por lo tanto, el n\u00famero total de comparaciones en el peor de los casos ser\u00e1 ((n / m) + m-1). El valor de la funci\u00f3n ((n / m) + m-1) ser\u00e1 m\u00ednimo cuando m = \u221an. Por lo tanto, el mejor tama\u00f1o de paso es m = \u221an.
artemis.biblioteca.busquedas.saltos.texta                       = Puntos importantes:
artemis.biblioteca.busquedas.saltos.textb                       =-	Trabaja solo arreglos ordenados.
artemis.biblioteca.busquedas.saltos.textc                       =-	El tama\u00f1o \u00f3ptimo de un bloque a saltar es (\u221a n). Esto hace que la complejidad del tiempo de Jump Search O (\u221a n).
artemis.biblioteca.busquedas.saltos.textd                       =-	La complejidad temporal de la b\u00fasqueda por salto es entre la b\u00fasqueda lineal ((O (n)) y la b\u00fasqueda binaria (O (Log n)).
artemis.biblioteca.busquedas.saltos.texte                       =-	La b\u00fasqueda binaria es mejor que la b\u00fasqueda por salto, pero la b\u00fasqueda por salto tiene la ventaja de que retrocedemos solo una vez (la b\u00fasqueda binaria puede requerir saltos O (Log n), considere una situaci\u00f3n en la que el elemento a buscar es el elemento m\u00e1s peque\u00f1o o m\u00e1s peque\u00f1o que el m\u00e1s peque\u00f1o). Entonces, en un sistema donde el salto hacia atr\u00e1s es costoso, usamos Jump Search.
artemis.biblioteca.busqueda.diferencia_pares.parrafo1.text      = Dada una matriz sin orden y un n\u00famero n, busque si existe un par de elementos en la matriz cuya diferencia es n. El m\u00e9todo m\u00e1s simple es ejecutar dos bucles, el bucle externo selecciona el primer elemento (elemento m\u00e1s peque\u00f1o) y el bucle interno busca el elemento seleccionado por el bucle externo m\u00e1s n. La complejidad del tiempo de este m\u00e9todo es O (n ^ 2).
artemis.biblioteca.busqueda.diferencia_pares.parrafo2.text      = Podemos usar la ordenaci\u00f3n y la b\u00fasqueda binaria para mejorar la complejidad del tiempo a O (nLogn). El primer paso es ordenar el array en orden ascendente. Una vez que el array est\u00e9 ordenado, recorra el array de izquierda a derecha y, para cada elemento arr [i], la b\u00fasqueda binaria de arr [i] + n en arr [i + 1...n-1]. Si se encuentra el elemento, devuelva el par. Tanto el primer como el segundo paso toman O (nLogn). As\u00ed que la complejidad global es O (nLogn).
artemis.biblioteca.busqueda.diferencia_pares.parrafo3.text      = El segundo paso del algoritmo anterior se puede mejorar a O (n). El primer paso sigue siendo el mismo. La idea para el segundo paso es tomar dos variables de \u00edndice i y j, inicializarlas como 0 y 1 respectivamente. Ahora ejecuta un bucle lineal. Si arr [j] - arr [i] es m\u00e1s peque\u00f1o que n, debemos buscar un arr mayor [j], as\u00ed que aumente j. Si arr [j] - arr [i] es mayor que n, debemos buscar un arr mayor [i], entonces incremente i.
artemis.biblioteca.busquedas.missingno.texta                    = Se le da una lista de n-1 enteros y estos enteros est\u00e1n en el rango de 1 a n. No hay duplicados en la lista. Falta uno de los enteros en la lista.
artemis.biblioteca.busquedas.missingno.textb                    = 1) XOR todos los elementos del array, que el resultado de XOR sea X1.
artemis.biblioteca.busquedas.missingno.textc                    = 2) XOR todos los n\u00fameros del 1 al n, sea XOR sea X2.
artemis.biblioteca.busquedas.missingno.textd                    = 3) XOR de X1 y X2 da el n\u00famero que falta.
artemis.biblioteca.busquedas.minimumsum.texta                   = Dos elementos cuya suma es la m\u00e1s cercana a cero. Para cada elemento, encuentre la suma con cada otro elemento en el array y compare las sumas. Por \u00faltimo, devolver la suma m\u00ednima.
artemis.biblioteca.busquedas.minmax.texta                       = Cuando tenemos un Array en donde queremos buscar el valor m\u00e1s peque\u00f1o y el valor m\u00e1s grande del mismo de forma eficiente haciendo la menor cantidad de comparaciones.
artemis.biblioteca.busquedas.exponentialsearch.texta            = El nombre de este algoritmo de b\u00fasqueda puede ser enga\u00f1oso, ya que funciona en tiempo O (Log n). El nombre proviene de la forma en que busca un elemento. La b\u00fasqueda binaria exponencial es particularmente \u00fatil para b\u00fasquedas ilimitadas, donde el tama\u00f1o de la matriz es infinito.
artemis.biblioteca.busquedas.binarysearch.text                  = La b\u00fasqueda binaria, tambi\u00e9n conocida como b\u00fasqueda de intervalo medio o b\u00fasqueda logar\u00edtmica, es un algoritmo de b\u00fasqueda que encuentra la posici\u00f3n de un valor en un arreglo ordenado. Compara el valor con el elemento en el medio del arreglo, si no son iguales, la mitad en la cual el valor no puede estar es eliminada y la b\u00fasqueda sigue en la mitad restante hasta que el valor se encuentre. La b\u00fasqueda binaria es computada en el peor de los casos en un tiempo logar\u00edtmico, realizando  O (log n)  comparaciones, donde n es el n\u00famero de elementos del arreglo y log es el logaritmo.
artemis.biblioteca.busquedas.ternarysearch.texta                = La b\u00fasqueda ternaria es un algoritmo de dividir y conquistar que se puede usar para encontrar un elemento en un array. Es similar a la b\u00fasqueda binaria donde dividimos el array en dos partes pero en este algoritmo. En esto, dividimos el array dado en tres partes y determinamos cu\u00e1l tiene la clave (elemento buscado). Podemos dividir el array en tres partes tomando mid1 y mid2, que se pueden calcular como se muestra a continuaci\u00f3n.
artemis.biblioteca.busquedas.ternarysearch.textb                = mid1 = l + (r-l) / 3
artemis.biblioteca.busquedas.ternarysearch.textc                = mid2 = r - (r-l) / 3
artemis.biblioteca.busquedas.ternarysearch.textd                = Inicialmente, l y r ser\u00e1n iguales a 0 y n-1 respectivamente, donde n es la longitud de la matriz.
artemis.biblioteca.busquedas.ternarysearch.texte                = El array debe ordenarse para realizar una b\u00fasqueda ternaria en ella.

#biblioteca - ordenamientos
artemis.biblioteca.ordenamientos.threewaymerge.texta        = Merge sort envuelve separaci\u00f3n recursiva del array en dos partes, ordenamiento y finalmente uni\u00f3n de las mismas. Una variante de merge sort es llamado merge sort de tres v\u00edas donde en vez de separar el array en dos partes se separa en tres. Merge sort recursivamente rompe los arrays en arrays de tama\u00f1o medio, Merge de tres v\u00edas hace lo mismo en arrays de tama\u00f1o de un tercio.
artemis.biblioteca.ordenamientos.threewaymerge.textb        = Complejidad de tiempo: En caso de Merge Sort se tiene la ecuaci\u00f3n T(n) = 2T(n/2) + O(n). Igualmente en caso de Merge de tres v\u00edas se tiene la ecuaci\u00f3n(n) = 3T(n/3) + O(n) por lo que la aproximaci\u00f3n m\u00e1s cercana de su complejidad es: O(n log 3n).
artemis.biblioteca.ordenamientos.binaryinsertion.texta      = Podemos usar la b\u00fasqueda binaria para reducir el n\u00famero de comparaciones en la clasificaci\u00f3n de inserci\u00f3n normal. La clasificaci\u00f3n de inserci\u00f3n binaria utiliza la b\u00fasqueda binaria para encontrar la ubicaci\u00f3n adecuada para insertar el elemento seleccionado en cada iteraci\u00f3n.
artemis.biblioteca.ordenamientos.binaryinsertion.textb      = En la clasificaci\u00f3n de inserci\u00f3n normal, se necesitan comparaciones O(n) (en la iteraci\u00f3n n) en el peor de los casos. Podemos reducirlo a O (log n) mediante la b\u00fasqueda binaria.
artemis.biblioteca.ordenamientos.binaryinsertion.textc      = El algoritmo en su conjunto a\u00fan tiene un tiempo de ejecuci\u00f3n en el peor de los casos de O (n2) debido a la serie de intercambios necesarios para cada inserci\u00f3n
artemis.biblioteca.ordenamientos.bitonic.texta              = Bitonic Sort es un algoritmo paralelo cl\u00e1sico para ordenamiento. La ordenaci\u00f3n bit\u00f3nica hace comparaciones O (n Log 2n). El n\u00famero de comparaciones realizadas por Bitonic Sort son m\u00e1s que los algoritmos de clasificaci\u00f3n populares como Merge Sort [hace O (nLogn) comparaciones], pero Bitonic es mejor para la implementaci\u00f3n en paralelo porque siempre comparamos elementos en una secuencia predefinida y la secuencia de comparaci\u00f3n no. Depende de los datos. Por lo tanto, es adecuado para la implementaci\u00f3n en hardware y array de procesado paralelo. Para entender el ordenamiento bit\u00f3nico, primero debemos entender qu\u00e9 es la secuencia bit\u00f3nica y c\u00f3mo hacer una secuencia dada bit\u00f3nica.
artemis.biblioteca.ordenamientos.bitonic.textb              = Una secuencia es bit\u00f3nica si primero aumenta, luego disminuye. En otras palabras, una matriz arr [0...n-i] es Bitonic si existe un \u00edndice i donde 0 <= i <= n-1 tal que
artemis.biblioteca.ordenamientos.bitonic.textc              = x0 <= x1 ... .. <= xi y xi> = xi + 1 ... ..> = xn-1
artemis.biblioteca.ordenamientos.bitonic.textd              = Para formar una secuencia ordenada de longitud n a partir de dos secuencias ordenadas de longitud n / 2, se requieren comparaciones de log (n) (por ejemplo: log (8) = 3 cuando el tama\u00f1o de la secuencia. Por lo tanto, el n\u00famero de comparaciones T (n) de La clasificaci\u00f3n completa est\u00e1 dada por:
artemis.biblioteca.ordenamientos.bitonic.texte              = T (n) = log (n) + T (n / 2)
artemis.biblioteca.ordenamientos.bitonic.textf              = La soluci\u00f3n de esta ecuaci\u00f3n de recurrencia es:
artemis.biblioteca.ordenamientos.bitonic.textg              = T (n) = log (n) + log (n) -1 + log (n) -2 +\u2026 + 1 = log (n) \u2022 (log (n) +1) / 2
artemis.biblioteca.ordenamientos.bitonic.texth              = Como, cada etapa de la red de clasificaci\u00f3n consiste en n / 2 comparaciones. Por lo tanto un total de O (n log2n) comparaciones.
artemis.biblioteca.ordenamientos.bubble.text                = Ordenamiento burbuja es el algoritmo de ordenamiento m\u00e1s simple que existe, funciona intercambiando repetidamente los elementos adyacentes si est\u00e1n en orden incorrecto.
artemis.biblioteca.ordenamientos.cocktail.texta             = Cocktail Sort es una variaci\u00f3n de Bubble Sort. El algoritmo de clasificaci\u00f3n de burbuja siempre atraviesa elementos de la izquierda y mueve el elemento m\u00e1s grande a su posici\u00f3n correcta en la primera iteraci\u00f3n y el segundo m\u00e1s grande en la segunda iteraci\u00f3n, y as\u00ed sucesivamente. La clasificaci\u00f3n de c\u00f3ctel atraviesa una matriz dada en ambas direcciones alternativamente.
artemis.biblioteca.ordenamientos.cocktail.textb             = Las complejidades de tiempo son iguales, pero Cocktail se desempe\u00f1a mejor que Bubble Sort. Por lo general, el c\u00f3ctel es menos de dos veces m\u00e1s r\u00e1pido que el tipo burbuja. Considere el ejemplo (2, 3, 4, 5, 1). La clasificaci\u00f3n de burbuja requiere cuatro recorridos de matriz para este ejemplo, mientras que la clasificaci\u00f3n de c\u00f3ctel requiere solo dos recorridos.
artemis.biblioteca.ordenamientos.cocktail.textc             = Tiempo del peor caso y caso promedio O (n * n). Tiempo del mejor caso es O (n). El mejor caso ocurre cuando el array ya est\u00e1 ordenado.
artemis.biblioteca.ordenamientos.comb.text                  = Comb Sort es principalmente una mejora sobre Bubble Sort. La ordenaci\u00f3n de burbuja siempre compara valores adyacentes. As\u00ed que todas las inversiones se eliminan una por una. Comb Sort mejora en Bubble Sort usando un espacio de tama\u00f1o mayor que 1. El espacio comienza con un gran valor y se reduce en un factor de 1.3 en cada iteraci\u00f3n hasta que alcanza el valor 1. Por lo tanto, Comb Sort elimina m\u00e1s de una cuenta de inversi\u00f3n con cada Intercambio y funciona mejor que Bubble Sort. Aunque funciona mejor que Bubble Sort en promedio, el peor de los casos sigue siendo O (n^2).
artemis.biblioteca.ordenamientos.counting.texta             = El ordenamiento por conteo es una t\u00e9cnica de ordenamiento basada en claves entre un rango espec\u00edfico. Funciona contando el n\u00famero de objetos que tienen valores clave distintos (tipo de hashing). Luego, hacer algo de aritm\u00e9tica para calcular la posici\u00f3n de cada objeto en la secuencia de salida.
artemis.biblioteca.ordenamientos.counting.textb             = 1. La ordenaci\u00f3n de conteo es eficiente si el rango de datos de entrada no es significativamente mayor que el n\u00famero de objetos a clasificar. 
artemis.biblioteca.ordenamientos.counting.textc             = 2. No es una comparaci\u00f3n basada en la clasificaci\u00f3n. La complejidad del tiempo de ejecuci\u00f3n es O (n) con espacio proporcional al rango de datos.
artemis.biblioteca.ordenamientos.counting.textd             = 3. A menudo se usa como una sub-rutina para otro algoritmo de clasificaci\u00f3n como la clasificaci\u00f3n por radix.
artemis.biblioteca.ordenamientos.counting.texte             = 4. La ordenaci\u00f3n de conteo usa un hashing parcial para contar la ocurrencia del objeto de datos en O (1).
artemis.biblioteca.ordenamientos.counting.textf             = 5. La ordenaci\u00f3n de conteo tambi\u00e9n se puede extender para que funcione con entradas negativas.
artemis.biblioteca.ordenamientos.cycle.texta                = El ordenamiento de ciclos es un algoritmo de ordenamiento en el lugar, una ordenaci\u00f3n de comparaci\u00f3n que es te\u00f3ricamente \u00f3ptima en t\u00e9rminos del n\u00famero total de escrituras en el array original.
artemis.biblioteca.ordenamientos.cycle.textb                = Es \u00f3ptimo en t\u00e9rminos de cantidad de escrituras de memoria. Minimiza el n\u00famero de escrituras de memoria para ordenar (cada valor se escribe cero veces, si ya est\u00e1 en su posici\u00f3n correcta, o se escribe una vez en su posici\u00f3n correcta).
artemis.biblioteca.ordenamientos.merge.texta                = Al igual que Quick Sort, Merge Sort es un algoritmo de Dividir y Conquistar. Divide el arreglo de entrada en dos mitades, se llama a s\u00ed misma para las dos mitades y luego combina las dos mitades clasificadas. La funci\u00f3n merge () se usa para fusionar dos mitades.
artemis.biblioteca.ordenamientos.merge.textb                = El merge (arr, l, m, r) es un proceso clave que asume que arr [l...m] y arr [m + 1...r] est\u00e1n ordenados y combina los dos subarreglos ordenados en uno solo.
artemis.biblioteca.ordenamientos.merge.textc                = Merge Sort es \u00fatil para ordenar listas enlazadas en tiempo O (nLogn). En el caso de listas enlazadas, el caso es diferente principalmente debido a la diferencia en la asignaci\u00f3n de memoria de los arrays y las listas enlazadas. A diferencia de los arrays, los nodos de listas enlazadas pueden no estar adyacentes en la memoria. A diferencia del array, en la lista enlazada, podemos insertar elementos en el medio en O (1) espacio adicional y O (1) tiempo. Por lo tanto, la operaci\u00f3n de fusi\u00f3n de la ordenaci\u00f3n de fusi\u00f3n se puede implementar sin espacio adicional para las listas vinculadas.
artemis.biblioteca.ordenamientos.merge.textd                = En arrays, podemos hacer acceso aleatorio ya que los elementos son continuos en la memoria.
artemis.biblioteca.ordenamientos.pigeon.texta               = Ordenamiento nido de Paloma es un algoritmo de ordenamiento que es adecuado para ordenar listas de elementos donde el n\u00famero de elementos y el n\u00famero de valores de los mismos son aproximadamente lo mismo.
artemis.biblioteca.ordenamientos.pigeon.textb               = Este requiere un tiempo de  O(n + Rango) donde n es el n\u00famero de elementos en el array de entrada y Rango es el n\u00famero de posibles valores en el array. Este algoritmo es similar a Counting sort, pero difiere en la forma en que mueve los datos, dos veces.
artemis.biblioteca.ordenamientos.quick.texta                = Quick Sort es un algoritmo de Dividir y Conquistar. Selecciona un elemento como pivote y divide el array dado alrededor del pivote seleccionado. Hay muchas versiones diferentes de quick Sort que seleccionan pivote de diferentes maneras.
artemis.biblioteca.ordenamientos.quick.textb                = -	Elije siempre el primer elemento como pivote.
artemis.biblioteca.ordenamientos.quick.textc                = -	Siempre elije el \u00faltimo elemento como pivote.
artemis.biblioteca.ordenamientos.quick.textd                = -	Elige un elemento aleatorio como pivote.
artemis.biblioteca.ordenamientos.quick.texte                = -	Elije la mediana como pivote.
artemis.biblioteca.ordenamientos.quick.textf                = El proceso clave en quick Sort es partition (). El destino de las particiones es, dada un array y un elemento x del array como pivote, coloca x en su posici\u00f3n correcta en el array ordenado y coloca todos los elementos m\u00e1s peque\u00f1os (m\u00e1s peque\u00f1os que x) antes de x, y coloca todos los elementos mayores (mayores que x) despu\u00e9s de X. Todo esto debe hacerse en tiempo lineal.
artemis.biblioteca.ordenamientos.radix.texta                = La idea de Radix Sort es hacer una clasificaci\u00f3n de d\u00edgito por d\u00edgito desde el d\u00edgito menos significativo hasta el d\u00edgito m\u00e1s significativo. La ordenaci\u00f3n de Radix usa la ordenaci\u00f3n de conteo como una subrutina para ordenar.
artemis.biblioteca.ordenamientos.radix.textb                = Si tenemos bits log2n para cada d\u00edgito, el tiempo de ejecuci\u00f3n de Radix parece ser mejor que Quick Sort para una amplia gama de n\u00fameros de entrada. Los factores constantes ocultos en la notaci\u00f3n asint\u00f3tica son mayores para Radix Sort y Quick-Sort usa cach\u00e9s de hardware de manera m\u00e1s efectiva.
artemis.biblioteca.ordenamientos.shell.texta                = Shell Sort es principalmente una variaci\u00f3n de Insertion Sort. En la ordenaci\u00f3n por inserci\u00f3n, movemos los elementos solo una posici\u00f3n adelante. Cuando un elemento tiene que moverse mucho m\u00e1s adelante, hay muchos movimientos involucrados. La idea de shell Sort es permitir el intercambio de elementos lejanos. En shell Sort, hacemos el array h-ordenado para un gran valor de h. Continuamos reduciendo el valor de h hasta que se convierte en 1. Se dice que un array est\u00e1 ordenado por h si todas las sublistas de cada elemento h est\u00e1n ordenadas.
artemis.biblioteca.ordenamientos.shell.textb                = La complejidad de tiempo de la implementaci\u00f3n de shell Sort es O (n2). En la implementaci\u00f3n la brecha se reduce a la mitad en cada iteraci\u00f3n.
artemis.biblioteca.ordenamientos.tim.texta                  = TimSort es un algoritmo de ordenamiento basado en Insertion Sort y Merge Sort.
artemis.biblioteca.ordenamientos.tim.textb                  = -	Es un algoritmo de ordenamiento estable funciona en tiempo O (n Log n)
artemis.biblioteca.ordenamientos.tim.textc                  = -	Se utiliza en Arrays.sort () de Java, as\u00ed como en Python sorted() y C++ sort()
artemis.biblioteca.ordenamientos.tim.textd                  = -	Primero clasifica las piezas peque\u00f1as utilizando el ordenamiento de Inserci\u00f3n, luego fusione las piezas utilizando la combinaci\u00f3n de ordenaci\u00f3n por fusi\u00f3n (Merge).
artemis.biblioteca.ordenamientos.tim.texte                  = Dividimos el array en bloques conocidos como Run. Ordenamos esas ejecuciones utilizando la ordenaci\u00f3n por inserci\u00f3n una por una y luego las combinamos utilizando la funci\u00f3n de combinaci\u00f3n utilizada en Merge Sort. Si el tama\u00f1o del array es menor que run, entonces el array se clasifica simplemente utilizando el orden de inserci\u00f3n.
artemis.biblioteca.ordenamientos.tim.textf                  = El tama\u00f1o de run puede variar de 32 a 64, dependiendo del tama\u00f1o del array. Tenga en cuenta que la funci\u00f3n de combinaci\u00f3n funciona bien cuando los arreglos secundarios de tama\u00f1o son potencias de 2. La idea se basa en el hecho de que la ordenaci\u00f3n por inserci\u00f3n funciona bien para arreglos peque\u00f1os.
artemis.biblioteca.ordenamientos.tree.texta                 = Ordenamiento \u00e1rbol es un algoritmo de clasificaci\u00f3n que se basa en la estructura de datos del Binary Search Tree. Primero crea un \u00e1rbol de b\u00fasqueda binario a partir de los elementos de la lista de entrada o un array luego realiza un recorrido inorden en el \u00e1rbol de b\u00fasqueda binario creado para obtener los elementos ordenados.
artemis.biblioteca.ordenamientos.tree.textb                 = Su complejidad de tiempo es O (nLogn) en el mejor de los casos y O(n^2) en el peor.

# registro
artemis.registro.exito  = \u00c9xito
artemis.registro.creado = Cuenta creada con \u00e9xito, ya puede acceder via INICIO SESI\u00d3N
artemis.registro.error  = Error




















